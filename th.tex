\documentclass[oneside, 12pt]{book}


\usepackage{float} % must be before hyperref, needed by algorithm2e
%\usepackage[backref,hyperindex,colorlinks,citecolor=blue,pdftex,debug]{hyperref}
\usepackage[backref,hyperindex,pdftex,debug]{hyperref}
%\usepackage[pdftex,debug]%REMOVE THIS WHEN REMOVING THE COMMENT ON THE ABOVE LINE
\usepackage{bookmark}
\usepackage[all]{hypcap} % After hyperref, to anchor floats correctly.
\usepackage[algo2e,algosection,tworuled,noend,noline]{algorithm2e}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{graphics}
\usepackage{epsfig}
\usepackage{times}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{setspace}
\usepackage{color}
\usepackage{thmtools}
%\usepackage{manfnt}
\usepackage{mathrsfs}
% <http://psl.cs.columbia.edu/phdczar/proposal.html>:
%
% The standard departmental thesis proposal format is the following:
%        30 pages
%        12 point type
%        1 inch margins all around = 6.5   inch column
%        (Total:  30 * 6.5   = 195 page-inches)
%
% For letter-size paper: 8.5 in x 11 in
% Latex Origin is 1''/1'', so measurements are relative to this.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{mathptmx}



\sloppy

\usepackage{cheatpf}
% To go with the prooof environment in gacspf.sty:
% {proof}: the AMS proof environment
% {prooof} the Lamport proof environment
% {Proof} the AMS environment, with the Lamport environment inside.
% {pproof} the Lamport environment, beginning with ``Proof.'' (\pf\)
% but not ending with ~\qed.
\def\kwfont{\itshape} % Was scshape in gacspf.
\pfshortnumbers{6} % Use short step numbers for all levels >= 5
\setlength{\stepsep}{1ex}      % space above and below prooof step

\newcommand{\mathboldit}[1]{\boldsymbol{#1}}

\makeatletter

\newcommand{\myTimes}{
 % \usepackage{mathptmx}
 % % better sized Greek for mathptmx
 % \DeclareSymbolFont{letters}{OML}{txmi}{m}{it}
 % % For bold italics
 % \DeclareMathAlphabet{\mathbit}{OT1}{ptm}{bx}{it}
 % \renewcommand{\mathboldit}[1]{\mathbit{##1}}
 \usepackage{txfonts}
 % Replace some bad-looking fonts of txfonts.
 \renewcommand{\sfdefault}{cmss}
 \DeclareMathAlphabet{\mathsf}{OT1}{cmss}{m}{n}
 \SetMathAlphabet{\mathsf}{bold}{OT1}{cmss}{b}{n}
 \renewcommand{\ttdefault}{cmtt}
 \DeclareMathAlphabet{\mathtt}{OT1}{cmtt}{m}{n}
 \SetMathAlphabet{\mathtt}{bold}{OT1}{cmtt}{b}{n}

\DeclareSymbolFont{cmsymbols}{OMS}{cmsy}{m}{n}
\DeclareSymbolFont{ztmcmsymbols}{OMS}{ztmcm}{m}{n}
\DeclareRobustCommand*{\cmmathcal}[1]{\gdef\F@ntPrefix{m@thcalch@r}%
 \@EachCharacter ##1\@EndEachCharacter}

\DeclareMathSymbol{\m@thcalch@rA}{\mathord}{cmsymbols}{65}
\DeclareMathSymbol{\m@thcalch@rB}{\mathord}{cmsymbols}{66}
\DeclareMathSymbol{\m@thcalch@rC}{\mathord}{cmsymbols}{67}
\DeclareMathSymbol{\m@thcalch@rD}{\mathord}{cmsymbols}{68}
\DeclareMathSymbol{\m@thcalch@rE}{\mathord}{cmsymbols}{69}
\DeclareMathSymbol{\m@thcalch@rF}{\mathord}{cmsymbols}{70}
\DeclareMathSymbol{\m@thcalch@rG}{\mathord}{cmsymbols}{71}
\DeclareMathSymbol{\m@thcalch@rH}{\mathord}{cmsymbols}{72}
\DeclareMathSymbol{\m@thcalch@rI}{\mathord}{cmsymbols}{73}
\DeclareMathSymbol{\m@thcalch@rJ}{\mathord}{cmsymbols}{74}
\DeclareMathSymbol{\m@thcalch@rK}{\mathord}{cmsymbols}{75}
\DeclareMathSymbol{\m@thcalch@rL}{\mathord}{cmsymbols}{76}
\DeclareMathSymbol{\m@thcalch@rM}{\mathord}{cmsymbols}{77}
\DeclareMathSymbol{\m@thcalch@rN}{\mathord}{cmsymbols}{78}
\DeclareMathSymbol{\m@thcalch@rO}{\mathord}{cmsymbols}{79}
\DeclareMathSymbol{\m@thcalch@rP}{\mathord}{cmsymbols}{80}
\DeclareMathSymbol{\m@thcalch@rQ}{\mathord}{cmsymbols}{81}
\DeclareMathSymbol{\m@thcalch@rR}{\mathord}{cmsymbols}{82}
\DeclareMathSymbol{\m@thcalch@rS}{\mathord}{cmsymbols}{83}
\DeclareMathSymbol{\m@thcalch@rT}{\mathord}{cmsymbols}{84}
\DeclareMathSymbol{\m@thcalch@rU}{\mathord}{cmsymbols}{85}
\DeclareMathSymbol{\m@thcalch@rV}{\mathord}{cmsymbols}{86}
\DeclareMathSymbol{\m@thcalch@rW}{\mathord}{cmsymbols}{87}
\DeclareMathSymbol{\m@thcalch@rX}{\mathord}{cmsymbols}{88}
\DeclareMathSymbol{\m@thcalch@rY}{\mathord}{cmsymbols}{89}
\DeclareMathSymbol{\m@thcalch@rZ}{\mathord}{cmsymbols}{90}
%
% \DeclareMathSymbol{\m@thcalch@rA}{\mathord}{ztmcmsymbols}{65}
% \DeclareMathSymbol{\m@thcalch@rB}{\mathord}{ztmcmsymbols}{66}
% \DeclareMathSymbol{\m@thcalch@rC}{\mathord}{ztmcmsymbols}{67}
% \DeclareMathSymbol{\m@thcalch@rD}{\mathord}{ztmcmsymbols}{68}
% \DeclareMathSymbol{\m@thcalch@rE}{\mathord}{ztmcmsymbols}{69}
% \DeclareMathSymbol{\m@thcalch@rF}{\mathord}{ztmcmsymbols}{70}
% \DeclareMathSymbol{\m@thcalch@rG}{\mathord}{ztmcmsymbols}{71}
% \DeclareMathSymbol{\m@thcalch@rH}{\mathord}{ztmcmsymbols}{72}
% \DeclareMathSymbol{\m@thcalch@rI}{\mathord}{ztmcmsymbols}{73}
% \DeclareMathSymbol{\m@thcalch@rJ}{\mathord}{ztmcmsymbols}{74}
% \DeclareMathSymbol{\m@thcalch@rK}{\mathord}{ztmcmsymbols}{75}
% \DeclareMathSymbol{\m@thcalch@rL}{\mathord}{ztmcmsymbols}{76}
% \DeclareMathSymbol{\m@thcalch@rM}{\mathord}{ztmcmsymbols}{77}
% \DeclareMathSymbol{\m@thcalch@rN}{\mathord}{ztmcmsymbols}{78}
% \DeclareMathSymbol{\m@thcalch@rO}{\mathord}{ztmcmsymbols}{79}
% \DeclareMathSymbol{\m@thcalch@rP}{\mathord}{ztmcmsymbols}{80}
% \DeclareMathSymbol{\m@thcalch@rQ}{\mathord}{ztmcmsymbols}{81}
% \DeclareMathSymbol{\m@thcalch@rR}{\mathord}{ztmcmsymbols}{82}
% \DeclareMathSymbol{\m@thcalch@rS}{\mathord}{ztmcmsymbols}{83}
% \DeclareMathSymbol{\m@thcalch@rT}{\mathord}{ztmcmsymbols}{84}
% \DeclareMathSymbol{\m@thcalch@rU}{\mathord}{ztmcmsymbols}{85}
% \DeclareMathSymbol{\m@thcalch@rV}{\mathord}{ztmcmsymbols}{86}
% \DeclareMathSymbol{\m@thcalch@rW}{\mathord}{ztmcmsymbols}{87}
% \DeclareMathSymbol{\m@thcalch@rX}{\mathord}{ztmcmsymbols}{88}
% \DeclareMathSymbol{\m@thcalch@rY}{\mathord}{ztmcmsymbols}{89}
% \DeclareMathSymbol{\m@thcalch@rZ}{\mathord}{ztmcmsymbols}{90}
\let\mathcal\cmmathcal
}




\myTimes
%\usepackage{fouriernc}
%\usepackage{mathpazo}
%\usepackage[urw-garamond]{mathdesign}
%\usepackage[charter]{mathdesign}

%\usepackage[displaymath,textmath,sections,graphics,floats]{preview}
% \PreviewEnvironment{enumerate}

\makeatother


\setlength{\interspacetitleruled}{1ex}
\SetAlgoInsideSkip{smallskip}
\makeatletter
%\newcommand{\algocf@caption@tworuled}{\box\algocf@capbox\kern\interspacetitleruled}%
\renewcommand{\algocf@caption@tworuled}{\box\algocf@capbox\kern-\interspacetitleruled}
\makeatother
\newenvironment{algorule}[1][htb]{\renewcommand{\algorithmcfname}{%
Rule}\begin{algorithm2e}[#1]\SetAlFnt{\small\sf}\advance\lineskip by
2pt}{\end{algorithm2e}}
\newcommand{\mykeyword}[1]{\text{\KwSty{#1} }}
\newcommand{\algOr}{\mykeyword{or}}
\newcommand{\algAnd}{\mykeyword{and}}
\newcommand{\algNot}{\mykeyword{not}}
\newcommand{\algLet}{\mykeyword{let}}
%Peter: since there is a single transition, there is no need for ";", which
% normally separates actions in time.
% For separating actions on one line, we will use comma.
\DontPrintSemicolon % \; is only for starting a new line.
\SetKwIF{If}{ElseIf}{Else}{if}{then}{else if}{else}{}

\SetCommentSty{textrm}
\SetKwComment{Comment}{/\hspace{-0.2em}/ }{}
% \SetKwComment{Comment}{/*~}{~*/}
% These will make sure that for example parentheses outside $$ are not italic.
\SetArgSty{textrm}
\SetNlSty{textrm}{(}{)}

%%%%%%%  Author Notes %%%%%%%
%
\newcommand{\shownotes}{0}
\ifnum\shownotes=1
\newcommand{\authnote}[3]
{{ \textcolor{#3}{$\langle\hspace{-0.2em}\langle$\textsf{\footnotesize #1: #2}$\rangle\hspace{-0.2em}\rangle$}}}
%{ {$\langle\hspace{-0.2em}\langle$ \textsf{\footnotesize #1:}\par{#2}$\rangle\hspace{-0.2em}\rangle$}}
\else
\newcommand{\authnote}[2]{}
\fi
\newcommand{\Pnote}[1]{{\authnote{Peter}{#1}{cyan}}}
\newcommand{\Inote}[1]{{\authnote{Ilir}{#1}{blue}}}
\newcommand{\IMP}[1]{{\authnote{IMPORTANT}{#1}{red}}}
\newcommand{\REM}[1]{{\authnote{REMAINS}{#1}{red}}}
\newcommand{\TODO}[1]{{\authnote{TODO}{#1}{green}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand*{\xfill}[1][0pt]{%
\cleaders
\hbox to 1pt{\hss
\raisebox{#1}{\rule{1.2pt}{0.4pt}}%
\hss}\hfill}
%%%%%%%  Blueprints %%%%%%%
%
\newcommand{\showbprints}{0}
\ifnum\showbprints=1
\newcommand{\bpnote}[2]
{ { \rule[0.5ex]{5cm}{0.5pt}
    \textsf{#1 } \xfill[0.5ex] %rule{3cm}{0.5pt}
\vspace{2pt}
    \par{\footnotesize #2}
    \rule[0.5ex]{4.5cm}{0.5pt}
    \textsf{End of the #1 } \xfill[0.5ex] %rule{3cm}{0.5pt}
    \vspace{1.5pt}
   }
 }
\else
\newcommand{\bpnote}[2]{}
\fi

\newcommand{\blueP}[1]{{\bpnote{Section highlights}{#1}}}
\newcommand{\bp}[1]{{\bpnote{Section highlights}{#1}}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\newcommand{\sign}{{\operatorfont sign}}
\newcommand{\argmin}{{\operatorfont argmin}}
\newcommand{\flo}[1]{{\lfloor #1\rfloor}}
\newcommand{\cei}[1]{{\lceil #1\rceil}}
\newcommand{\vek}[1]{\mathbf{#1}}
%\newcommand{\iplus}{+_i}
%\newcommand{\iminus}{+_i}
\newcommand{\iplus}[1]{\oplus_{#1}}
\newcommand{\iminus}[1]{\ominus_{#1}}

\newcommand{\iPlus}{{\;\oplus_{i}\;}}
\newcommand{\iMinus}{{\;\ominus_{i}\;}}

\newcommand{\Plus}{{\;\oplus\;}}
\newcommand{\Minus}{{\;\ominus\;}}


% the following lists need package enum.
\newenvironment{bullets}{\begin{enumerate}[\textbullet]}{\end{enumerate}}
\newenvironment{dashes}{\begin{enumerate}[\bfseries\textendash]}{\end{enumerate}}
\newenvironment{flushdescription}{\leftmargini=1em\begin{description}}
{\end{description}}

\newcommand{\df}[1]{\emph{#1}}
\newcommand\set[1]{\left\{#1\right\}}
%\newcommand\setof[1]{\mathopen\{\,#1\,\mathclose\}}
\newcommand\setOf[2]{\left\{\,#1 : #2\,\right\}}
\newcommand\Paren[1]{{\left( #1\right)}}
\newcommand\ang[1]{{\mathopen\langle #1\mathclose\rangle}}

\newcommand{\opint}[2]{(#1,#2)}
\newcommand{\clint}[2]{[#1,#2]}
\newcommand{\lint}[2]{[#1,#2)}
\newcommand{\rint}[2]{(#1,#2]}

\newcommand{\fld}[1]{\ensuremath{\textit{#1}}}
\newcommand{\rul}[1]{\ensuremath{\texttt{\slshape #1\/}}}

\newcommand{\increment}[1]{#1\mathord{+}\mathord{+}}
\newcommand{\decrement}[1]{#1\mathord{-}\mathord{-}}






%Rules ***************************************************
\newcommand{\Alarm}{\rul{Alarm}}
\newcommand{\Comp}{\rul{Compute}}
\newcommand{\Calc}{\rul{Calculate}}
\newcommand{\Transfer}{\rul{Transfer}}
\newcommand{\Commute}{\rul{Relocate}}
\newcommand{\MAJ}{\rul{Col-maj}}
\newcommand{\Move}{\rul{Move}}
\newcommand{\Recover}{\rul{Recover}}
\newcommand{\cU}{\rul{Univ}}
\newcommand{\getTxt}{\rul{writeProgBit}}
\newcommand{\ruRecConCheck}{\rul{RecCheck}}

\newcommand{\ruSwing}{\rul{Swing}}
\newcommand{\Kill}{\rul{Kill}}
\newcommand{\Purge}{\rul{Purge}}
\newcommand{\Euthan}{\rul{Die}}
\newcommand{\AdjGuardian}{\rul{AdjGuardian}}
\newcommand{\PreProcess}{\rul{PreProcess}}
\newcommand{\rulConvHigh}{\rul{setSimParams}}
\newcommand{\rulSetNonAl}{\rul{SetNonAl}}
\newcommand{\ruAddrJmp}{\rul{AddrJmp}}
\newcommand{\SLine}{\rul{SLine}}

\newcommand{\Mark}{\rul{Mark}}
\newcommand{\Locate}{\rul{Locate}}
\newcommand{\Clean}{\rul{Clean}}
\newcommand{\Plan}{\rul{Plan}}
\newcommand{\RangeCheck}{\rul{RangeCheck}}
\newcommand{\Commit}{\rul{Commit}}
\newcommand{\Mop}{\rul{Mop}}
\newcommand{\ruAux}{\rul{AuxRule}}
\newcommand{\getOrders}{\rul{Destroy}}
\newcommand{\StateTransf}{\rul{StateTransf}}
\newcommand{\ruTransferSw}{\rul{theTransferSweep}}
\newcommand{\UsefulComp}{\rul{UsefulComp}}
\newcommand{\UsefulSimComp}{\rul{UsefulSimComp}}
\newcommand{\UsefulSimTransf}{\rul{UsefulSimTransf}}
\newcommand{\SideSim}{\rul{SideSim}}

%\newcommand{\CreateCol}{\rul{CreateCol}}
\newcommand{\Exec}{\rul{Exec}}
\newcommand{\Assay}{\rul{Assay}}
\newcommand{\GiveUp}{\rul{GiveUp}}
\newcommand{\Mediate}{\rul{Mediate}}
\newcommand{\Bootstrap}{\rul{BootStr}}
\newcommand{\InitCover}{\rul{InitCover}}
\newcommand{\Gather}{\rul{Gather}}
\newcommand{\RebRestore}{\rul{RebStructRst}}
%Constants ***************************************************

\newcommand{\Normal}{\mathrm{Normal}}
\newcommand{\Marking}{\mathrm{Marking}}
\newcommand{\Locating}{\mathrm{Locating}}
\newcommand{\Planning}{\mathrm{Planning}}
\newcommand{\Mopping}{\mathrm{Mopping}}
\newcommand{\Recovering}{\mathrm{Recovering}}
\newcommand{\Bridging}{\mathrm{Bridging}}
\newcommand{\dir}{\mathrm{dir}}
\newcommand{\trail}{\mathrm{trail}}
\newcommand{\bpad}{\mathrm{bitpad}}
\newcommand{\si}{\mathrm{si}}
\newcommand{\sa}{\mathrm{sa}}
\newcommand{\st}{\mathrm{st}}
\newcommand{\Coordinated}{\mathrm{Coordinated}}
\newcommand{\failed}{\mathrm{failed}}

\newcommand{\Healing}{\mathrm{Rebuild}}
\newcommand{\CreateCol}{\mathrm{CreateCol}}
\newcommand{\Bridge}{\mathrm{Bridge}}
\newcommand{\OK}{\mathrm{Ok}}
\newcommand{\NeedMoreToDecide}{\mathrm{NeedMoreToDecide}}
\newcommand{\Damaged}{\mathrm{Rifted}}
\newcommand{\type}{\mathrm{type}}
\newcommand{\CleanUp}{\mathrm{CleanUp}}
\newcommand{\MoveOn}{\mathrm{MoveOn}}
\newcommand{\Fillin}{\mathrm{FillIn}}
\newcommand{\NewBorn}{\mathrm{NewBorn}}
\newcommand{\Outer}{\mathrm{Outer}}
\newcommand{\SmallWs}{\mathrm{SmallWs}}
\newcommand{\FullWs}{\mathrm{FullWs}}
\newcommand{\TrArm}{\mathrm{TrArm}}
\newcommand{\Status}{\mathrm{Status}}
\newcommand{\Renew}{\mathrm{Renew}}


\newcommand{\PenetrationLen}{\mathrm{PenLen}}
\newcommand{\YardDepth}{\mathrm{YDepth}}
\newcommand{\CompRep}{3}
\newcommand{\MajRep}{m}
\newcommand{\TfRep}{3}
\newcommand{\TfMajRep}{m_{c}}
\newcommand{\TfLast}{\mathrm{TransferLast}}
\newcommand{\TfStart}{\mathrm{TfSt}}
\newcommand{\TfSw}{\mathrm{TfSw}}
\newcommand{\EuthanSw}{\mathrm{DieSw}}
\newcommand{\AuxSw}{\mathrm{AuxSw}}
%\newcommand{\Bridge}{\mathrm{Bridge}}
\newcommand{\Neighbor}{\mathrm{Neighbor}}
\newcommand{\Base}{\mathrm{Member}}
\newcommand{\Member}{\mathrm{Member}}
\newcommand{\SideExt}{\mathrm{SideExt}}
\newcommand{\True}{\mathrm{True}}
\newcommand{\False}{\mathrm{False}}
\renewcommand{\d}{d}
\newcommand{\D}{D}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\f}{f}
\newcommand{\front}{\mathrm{front}}
\newcommand{\mstep}{\mathrm{step}}
\newcommand{\piv}{\mathrm{pivot}}

\newcommand{\Bad}{\mathrm{Bad}}
\newcommand{\iTrans}{\mathrm{Bad}}
\newcommand{\Damage}{\mathrm{Damage}}
\newcommand{\Stem}{\mathrm{Stem}}
\newcommand{\Noise}{\mathrm{Noise}}
\newcommand{\Vacant}{\mathrm{Vacant}}
%\newcommand\Tu {\mathrm{T}}
\newcommand\Tl {{T_\bullet}}
\newcommand\tu {{T^\bullet}}
\newcommand{\Tu}[1]{T_{#1}^\bullet}
\newcommand{\Tus}{\tu^*}

\newcommand{\cA}{\mathcal{A}}
\newcommand{\cI}{\mathcal{I}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cZ}{\mathcal{Z}}
\newcommand{\Zg}{\mathcal{Z}_g}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cG}{\mathcal{G}}

\newcommand{\I}{\mathcal{I}}
\newcommand{\Un}{\mathrm{Unv}}
\newcommand{\U}{U}
\newcommand{\cmp}{\mathrm{cmp}}
\newcommand{\transf}{\mathrm{trans}}
\newcommand{\Uc}{U_{\cmp}}
\newcommand{\Ut}{U_{\transf}}
\newcommand{\X}{\mathcal{X}}

\newcommand{\C}{C}
\newcommand{\K}{K}
\newcommand{\pS}{pS}
\newcommand{\cV}{c_V}
\newcommand{\cu}{c_U}
\newcommand{\dmg}{\mathrm{dar}}
\newcommand{\cB}{c_\dmg}
\newcommand{\ci}{\mathrm{c}}
\newcommand{\ti}{\mathrm{t}}
\newcommand{\ri}{\mathrm{r}}
\newcommand{\wi}{\mathrm{w}}
\newcommand{\Dc}{D_\ci}
\newcommand{\Dt}{D_\ti}
\newcommand{\Dr}{D_\ri}
\newcommand{\Dw}{D_\wi}

\newcommand{\cT}{c_T}
\newcommand{\cb}{c_\beta}
\newcommand{\dw}{\mathrm{dwell}}
\newcommand{\isl}{\mathrm{isl}}
\newcommand{\cis}{c_\isl}
\newcommand{\cbQ}{c_Q}
\newcommand{\cH}{c_H}
\newcommand{\cW}{c_W}
\newcommand{\cC}{c_C}
\newcommand{\Sd}{S_d}

\newcommand{\cdw}{c_\dw}
\newcommand{\reb}{\mathrm{reb}}
\newcommand{\calc}{\mathrm{calc}}
\newcommand{\Sreb}{S_{\reb}}
\newcommand{\SCalc}{S_{\calc}}
%\newcommand{\sS}{\mathcal{S}}
%\newcommand{\sM}{\mathcal{M}}
\newcommand{\sS}{\mathscr{S}}
\newcommand{\sM}{\mathscr{M}}
\newcommand{\lptr}{\twoheadleftarrow}
\newcommand{\rptr}{\twoheadrightarrow}



\newcommand{\blank}{\text{\textvisiblespace}}
\newcommand{\state}{\mathrm{state}}
\newcommand{\start}{\mathrm{start}}
\newcommand{\tape}{\mathrm{tape}}
\newcommand{\pos}{\fld{pos}}
\newcommand{\h}{h}
\newcommand{\Last}{\mathrm{Last}}
\newcommand{\BirthLast}{\mathrm{BirthLast}}
\newcommand{\BirthSpreadLast}{\mathrm{BirthSpreadLast}}
\newcommand{\Configs}{\mathrm{Configs}}
\newcommand{\E}{E}
\newcommand{\R}{R}
\newcommand{\B}{B}
\newcommand{\Histories}{\mathrm{Histories}}
\newcommand{\MaxAffected}{\mathrm{MaxAffected}}
\newcommand{\Z}{Z}
\newcommand{\mrk}{\mathrm{mrk}}
\newcommand{\loc}{\ell_\mrk}
\newcommand{\g}{\vek{g}}
\newcommand{\ga}{\mathrm{g}}
%\newcommand{\h}{\vek{h}}
\newcommand{\dg}{d_{\g}}
\newcommand{\MaxSweep}{\mathrm{MSw}}
\newcommand{\TransferFieldMajStart}{\mathrm{TransferFieldMajStart}}
\newcommand{\TransferStart}{\mathrm{TrStart}}
\newcommand{\CompStart}{\mathrm{CmpSt}}
\newcommand{\TransferSw}{\mathrm{TrSweep}}
\newcommand{\Birth}{\mathrm{Birth}}
\newcommand{\Data}{\mathrm{Data}}



%Functions, operators ***************************************************
\newcommand{\encode}{\mathrm{encode}}
\newcommand{\decode}{\mathrm{decode}}
\newcommand{\maj}{\mathop{\mathrm{maj}}}
\newcommand{\LEnd}{\mathop{\mathrm{LEnd}}}
\newcommand{\REnd}{\mathop{\mathrm{REnd}}}
\newcommand{\base}{\mathop{\mathrm{base}}}
\newcommand{\fDir}{\mathop{\text{Dir}}}
\newcommand{\TurnPoint}{\mathop{\text{TurnPoint}}}




%Fields ***************************************************
\newcommand{\Decision}{\fld{Decision}}
\newcommand{\toBeKilled}{\fld{toBeKilled}}
\newcommand{\cStatus}{\fld{c.Status}}
\newcommand{\Prog}{\fld{Prog}}
\newcommand{\Addr}{\fld{Addr}}
\newcommand{\cAddr}{\fld{c.Addr}}
\newcommand{\cBrAd}{\fld{c.BrAddr}}
\newcommand{\cVisAddr}{\fld{c.VisAddr}}
\newcommand{\cVisSw}{\fld{c.VisSw}}
\newcommand{\cVisDrift}{\fld{c.VisDrift}}
\newcommand{\level}{\fld{lev}}



\newcommand{\Gap}{\fld{Gap}}
\newcommand{\cNonAligned}{\fld{c.NonAligned}}
\newcommand{\NonAligned}{\fld{NonAligned}}
\newcommand{\clAlign}{\fld{c.lGap}}
\newcommand{\crAlign}{\fld{c.rGap}}
\newcommand{\lAlign}{\fld{lGap}}
\newcommand{\rAlign}{\fld{rGap}}
\newcommand{\stp}{\fld{stp}}
\newcommand{\tmp}{\fld{tmp}}

\newcommand{\Rec}{\fld{Rec}}
\newcommand{\cRec}{\fld{c.Rec}}
\newcommand{\Info}{\fld{Info}}
\newcommand{\cInfo}{\fld{c.Info}}
\newcommand{\majInfo}{\fld{majInfo}}
\newcommand{\Arb}{\fld{Reb}}
\newcommand{\cArb}{\fld{c.Reb}}
\newcommand{\Active}{\fld{Active}}


\newcommand{\Bir}{\fld{Bir}}
\newcommand{\cBir}{\fld{c.Bir}}
\newcommand{\BrLen}{\fld{BrLen}}
\newcommand{\BirthLen}{\fld{BirthLen}}
\newcommand{\BirthSw}{\fld{BirthSw}}
\newcommand{\Creation}{\fld{Creation}}

\newcommand{\cSimInfo}{\fld{c.SimInfo}}
\newcommand{\cSimState}{\fld{c.SimState}}
\newcommand{\cSimDrift}{\fld{c.SimDrift}}
\newcommand{\cSimStatus}{\fld{c.SimStatus}}
\newcommand{\SimState}{\fld{SimState}}
\newcommand{\SimInfo}{\fld{SimInfo}}
\newcommand{\SimDrift}{\fld{SimDrift}}
\newcommand{\SimStatus}{\fld{SimStatus}}
\newcommand{\Output}{\fld{Output}}



\newcommand{\cKind}{\fld{c.Kind}}
\newcommand{\Kind}{\fld{Kind}}

\newcommand{\Drift}{\fld{Drift}}
\newcommand{\cDrift}{\fld{c.Drift}}
\newcommand{\cAuxDrift}{\fld{c.AuxDrift}}

\newcommand{\Zigzag}{\rul{Zigzag}}
\newcommand{\ZigDepth}{\fld{ZigDepth}}
\newcommand{\ZigDir}{\fld{ZigDir}}
\newcommand{\cZig}{\fld{c.Zig}}

\newcommand{\cHold}{\fld{c.Hold}}
\newcommand{\Mode}{\fld{Mode}}
\newcommand{\Stage}{\fld{Stage}}

\newcommand{\IntvLength}{\fld{IntvLn}}
\newcommand{\StepCount}{\fld{Count}}
\newcommand{\MajAddr}{\fld{I}}
\newcommand{\kK}{\fld{killed}}
\newcommand{\lK}{\fld{isl}}
\newcommand{\lCuts}{\fld{cuts}}
\newcommand{\State}{\fld{State}}
\newcommand{\majState}{\fld{majState}}
\newcommand{\majDrift}{\fld{majDrift}}
\newcommand{\majSweep}{\fld{majSweep}}
\newcommand{\Core}{\fld{Core}}
\newcommand{\cCore}{\fld{c.Core}}
\newcommand{\cCoreCand}{\fld{c.CoreCand}}
\newcommand{\cState}{\fld{c.State}}
\newcommand{\Sweep}{\fld{Sw}}
\newcommand{\cSweep}{\fld{c.Sw}}
\newcommand{\Af}{\fld{Doomed}}
\newcommand{\cAf}{\fld{c.Doomed}}
\newcommand{\Ef}{\fld{flagE}}
\newcommand{\G}{\fld{NonAdj}}
\newcommand{\SideTrack}{\fld{SideTrack}}
\newcommand{\Dir}{\fld{Dir}}
\newcommand{\cDir}{\fld{c.Dir}}
\newcommand{\MajCand}{\fld{MajCand}}
\newcommand{\EndPt}{\fld{EndPt}}
%\newcommand{\Ver}{\fld{Ver}}
%\newcommand{\cVer}{\fld{c.Ver}}
\newcommand{\verType}{\mathrm{Type}}

\newcommand{\cOrigSimInfo}{\fld{c.OrigSimInfo}}
\newcommand{\cOrigSimState}{\fld{c.OrigSimState}}

%%%%%%%%%%%%%%%%% Math notation

\newcommand{\bbZ}{\mathbb{Z}}
\newcommand{\bbN}{\mathbb{N}}
\newcommand{\bbQ}{\mathbb{Q}}
\newcommand{\bbR}{\mathbb{R}}


\newcommand{\customqed}[1]{{\renewcommand{\qedsymbol}{#1}\qed}}
\newcommand{\varqed}{\customqed{\hbox{$\lrcorner$}}}

\newcommand{\true}{\mathit{true}}
\newcommand{\false}{\mathit{false}}


\theoremstyle{plain}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{fact}[theorem]{Fact}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}

\theoremstyle{definition}
%\newtheorem{definition}[theorem]{Definition}
\newtheorem{xmp}[theorem]{Example}
\newenvironment{example}{\begin{xmp}}{\varqed\end{xmp}}



\newtheorem{Definition}[theorem]{Definition}
\newenvironment{definition}{\begin{Definition}}{\varqed\end{Definition}}


%\newtheorem{Example}[theorem]{Example}
%\newenvironment{exm}{%
% \begin{Example}}{\varqed\end{Example}}

\newtheorem{Problem}[theorem]{Problem}
\newenvironment{problem}{%
 \begin{Problem}}{\varqed\end{Problem}}

\newtheorem{Notation}[theorem]{Notation}
\newenvironment{notation}{%
 \begin{Notation}}{\varqed\end{Notation}}

\declaretheorem[style=definition,numbered=no]{Section blueprint}
%\newtheorem{blueprint}[theorem]{Section blueprint}
\newenvironment{bprint}{\begin{blueprint}} {\varqed\end{blueprint}}

\theoremstyle{remark}
\newtheorem{rem}[theorem]{Remark}
\newenvironment{remark}{\begin{rem}}{\varqed\end{rem}}


% \txt does not change font in changing environments.
\newcommand{\txt}[1]{\text{\rmfamily\mdseries\upshape{#1}}}




\newcommand{\z}{z}
\newcommand{\N}{\mathbf{N}}
\newcommand{\GOTO}{\mathrm{GOTO }}
\newcommand{\Iif}{\mathrm{IF }}
\newcommand{\tstep}{\mathrm{step}}
\newcommand{\fault}{\mathrm{fault}}
\newcommand{\ddiv}{\mathrm{div}}

\newcommand{\tth}{\text{th}}
\newcommand{\ie}{\emph{i.e.,} }
\newcommand{\eg}{\emph{e.g.,} }







%\topmargin      0.0in
%\headheight     0.5in %0.3
%\headsep        0.0in
%\oddsidemargin  0.5in
%\evensidemargin 0.5in
%\textheight     8.5in
%\textwidth      6.0in


\usepackage{fancyhdr}
\usepackage[us,12hr]{datetime} % `us' makes \today behave as usual in TeX/LaTeX
\fancypagestyle{plain}{
\fancyhf{}
\chead{\thepage}
%\rfoot{Compiled on {\ddmmyyyydate\today} at \currenttime}
%\lfoot{Page \thepage}
\footskip=0pt
\renewcommand{\headrulewidth}{0pt}
}

\fancypagestyle{prelim}{
\fancyhf{}
%\chead{\thepage}
\cfoot{\thepage}
%\rfoot{Compiled on {\ddmmyyyydate\today} at \currenttime}
%\lfoot{Page \thepage}
\footskip=18pt
\renewcommand{\headrulewidth}{0pt}
}

\pagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\topmargin      0.0in
\headheight     0.15in %0.3
\headsep        0.35in
\oddsidemargin  0.5in
\evensidemargin 0.5in
\textheight     8.5in
\textwidth      6.0in


\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\makeatletter
\renewcommand\chapter{\if@openright\cleardoublepage\else\clearpage\fi
                    \thispagestyle{fancy}%
                    \global\@topnum\z@
                    \@afterindentfalse
                    \secdef\@chapter\@schapter}
\makeatother


%\date{\today}


\begin{document}

\pagenumbering{roman}
%\maketitle
\doublespacing
\input{./title-page.tex}





%\onehalfspacing




%\pagebreak



\pagestyle{plain}
\cleardoublepage
\pagenumbering{arabic}
%\setcounter{page}{12}





\chapter{Introduction}


\begin{flushright}
{\it I don't gamble, but I would bet \$5 that such a machine exists.}

(P. G\'{a}cs in one of our meetings on March 2007)
\end{flushright}


In its most basic form, a Turing machine consists
of a machine of finite memory with an ability to
read and write symbols on an infinitely long tape
made up of memory locations called \df{cells}
as well as the ability to move left or right these locations.
One step of a Turing machine consists
of reading of the symbol from the \df{current cell}---
the cell under its read/write head,
examining its internal state,
and conditional on these two values,
writing a new symbol on the current cell and
moving the head to the left or to the right, or leaving it
on the same location.
This simple model of computation
has become the definition of computable.

From the point of view of  computability theory,
different definitions of the set of allowable operations used in computation,
that is, different models of computation,
are equivalent: they yield the same set of computable functions.
However, the situation differs
when taking into consideration the possibility that
due to some external factors,
a machine may behave differently of its operational rules.
The (im)possibility of computing any given
function with a computing machine whose components
exhibit transient failures
depends on many intrinsic features of the model.

The main question in such studies is if a machine
can carry out its computation of any computable
function despite occasional
violations of their transition function,
with some moderate trade-offs in space and time.
In particular, we are interested in the case
when these violations --- called \df{faults} ---
occur independently of each other
with some small probability.

To the best of our knowledge, Alan Turing made
the first mention
of ``errors of functioning'' of a computing machine
in~\cite{Turing:CanMachinesThink}, alas without offering
of any viable solution or answer if the computation
can be made robust against ``mechanical or electrical fault(s)''.





The problem of constructing fault-proof machines
from components that can fail independently at random
with probability $\varepsilon$ was first considered
by von Neumann in~\cite{vonNeumann} in 1956
who addressed the problem in the Boolean circuits model.
His solution was based on repeating each gate $R$ times,
then periodically suppressing errors by taking several
random majorities,  similar to how data are protected
using a repetition code in a reliable transmission problem.
However, majority gates can fail as well, which now introduces
a new goal: to avoid accumulation of of errors while
keeping the size of the majority gates constant.

In 1985, Pippenger showed that for any given fault-free circuit
of size $c$,  its  equivalent fault-tolerant circuit $C_F$  is of
size $O(|c|\log_2{|c|})$, and for all inputs, the probability
that an output of $C_F$ is in error is within $O(\varepsilon)$ (see~\cite{NC}).

New advances along this path were made in~\cite{DSpielman} by Spielman, who
gave a general purpose approach to ``coded computation''.
Later, in~\cite{Savage}, Rachlin and Savage extended this framework,  reduced the overhead
of the Spielman's approach, and allowed for the use of different codes
and different topologies of networks of noisy computing elements.

The question has been considered in uniform models
of computation as well.
A simple rule for two-dimensional cellular automata
that keeps one bit forever even though
each cell can fail with some small probability
was given in~\cite{Toom}.
A 3-dimensional reliably computing cellular automaton
was constructed in~\cite{PGReif}.

Alas, as suggested in~\cite{Kihong},
all simple one-dimensional cellular automata
appear to be ``ergodic'' (forgetting everything
about their initial configuration in time independent
of the size).

The first, complex, nonergodic cellular automaton
was constructed in~\cite{PG:1986}, and improved upon
in~\cite{GacsSorg97}.
It supports a hierarchical organization,
based on an idea given in~\cite{Kurdjumov}.
Cells are organized in
units that perform fault-tolerant simulation of another
automaton (of the same kind).
The latter simulates even more reliably a third
automaton of a similar kind, and so on.

The question of fault-tolerant computation with
Turing machines (where arbitrarily large
bursts may occur with correspondingly small probability) is
raised in 1987 by Manuel Blum.
As in the case of one-dimensional cellular automata,
no simple solution to this problem appears to exist.

Below we give a construction of a Turing machine that, with
polynomial overhead, can
simulate any other Turing machine, even when
faults occur independently of each other with some small
probability.

As this is the first draft of a --- surprisingly ---
complex construction
with many complex proofs, we recommend to the reader to focus in
the layout of the machine in Chapter~\ref{sec:blueprint} and
on the proof of the main result in Chapter~\ref{ch:proof-main-thm}.
This work is a follow-up of the construction of a Turing
machine that can withstand isolated bursts of faults given
in~\cite{Bursts}, and certain parts of the present work,
like Section~\ref{sec:recovery} or
Chapter~\ref{sec:1-level-noise},
are a more general treatment from the aforementioned work.
%Parts of chapters~\ref{ch:recovery}, \ref{ch:proof-main-thm}, and
%\ref{sec:larger-damage}, will be subjected to changes.




%In~\cite{Turing}, Turing spelled out the phenomena of
%``errors in functioning'' of a machine, but he did not
%offer any solution.

%\section{The outline of our contribution}
%
%In this work, we prove the existence
%of a Turing machine that can simulate
%any other Turing machine, even
%when faults occur independently of each other
%with some small probability.
%
%We will first give
%a construction of a Turing machine $M_1$,
%that simulates any other Turing machine, and
%is able to withstand bursts whose size
%is at most $\beta$, $\beta>0$ that are not closer to each other
%than $V = O(\beta^2)$.
%The initial version of this construction appears in~\cite{SOFSEM12}.
%
%Then, as suggested in~\cite{Kurd},
%we use this machine as a building
%block for the Turing machine that will be able to
%withstand faults occurring independently of each
%other with some small probability.
%The construction is based on the building of
%a tower of simulations, consisting of
%machines $M_1$, $M_2$, \dots ,  that have essentially
%the same program as machine $M_1$ that can withstand
%isolated bursts of faults.
%This construction is made possible by using the
%construction from the proof of the
%Kleene's Fixed Point Theorem
%(see~\cite{ShenVer}, p.~42).





\section{Related work}
\label{ch:related}

As elaborated above, most of the work in the study
of reliable computation was done in other models
of computation.
Here we present an overview of the research focusing on
Turing machines and noisy environments.

%A study of ``large deviations'' of
%``noisy'' Turing machines is given
%in~\cite{asarin}.

The title of~\cite{asarin} suggests some connection with our
work, but that
paper's interest is completely different: it examines the expressional ability,
in terms of the arithmetical hierarchy, of Turing
machines whose storage tapes are exposed
to stochastic noise that tends to zero.
%Each step of these machines consists of the ``noisy stage''
%and the ``progress stage''.
%In the first stage, all cells change their content
%independently of each other with probability $\varepsilon\ll 1$.
%During the second stage, the transition function is applied
%as usual.
%The paper gives an exact characterization of the (expressional)
%power of these machines in terms of the arithmetical hierarchy.

A proof that any Turing machine $M$ can be simulated
by a closed-form analytic map $f_M : \bbR^3 \rightarrow \bbR^3$ ,
even in the case where some noise is added to the initial
configuration or during the evolution of the system,
is given in~\cite{TMwithMaps}.


\section{On the importance of the problem}

%In theory, computational systems are expected to
%function reliably for arbitrary long times.
%Alas, certain realities of the physical world cannot
%be ignored in their design.
%It is natural to assume that no component of a computing
%device is  fail-proof, and that components can communicate
%only with a finite number of other component in
%a bounded distance.






The impact of a fault in our model is bound to the
current cell --- the cell where the head is positioned.
Therefore, the information stored on the tape in other
cells remains unchanged.
In the studies of fault-tolerant computation with machines
composed of unreliable components, this assumption is
not natural, even from the theoretical point of view; it is
hard to prevent the decay of information stored far from the head.
Therefore, Turing machines are not the best model for
studying reliable computation.

However, this work could be viewed as an
exploration of the ``boundary'' between machines
that are universal and can compute reliably, and those that
are universal but cannot compute reliably.
An example of the latter is a two-counter machine,
that is known to be universal.
Alas, when its operation is subjected
to noise, the best one can do with such a machine
is to keep one bit forever.

Hierarchical construction is not unknown in nature,
life sciences, and engineering.
Recent software models exhibiting adaptability and evolution
are hierarchical~\cite{Nowostawski04anarchitecture}.
Constructions of a fault-tolerant one-dimensional cellular
automaton and of robust tilings (where
 the rules of matching tiles can be violated independently
 with some probability) are also hierarchical (see~\cite{DurShenRomTil,GacsSorg97}).
Considering this problem on simple models
will yield more insight on the nature and crucial properties
of error-correcting processes.
It is intriguing that for one-dimensional
machines such a complex solution is needed.
We hope that this construction may shed some light
on the limitations imposed by the underlying geometry
of the machine.

Last but not least,
recent developments in the field of molecular computation,
show the need for a study of fault-tolerance on the Turing
machine model of computation.
Namely, it is known that an organelle found in cells ---
the ribosome ---  reads information encoded in gene transcripts known
as messenger RNAs (mRNAs) and translates
it into amino acid sequences to form proteins.
The symbolic alphabet of mRNA is made up of
nucleotide trios called codons, each of which
corresponds to a specific amino acid.
As the ribosome processes the mRNA strand ---
one codon at a time ---
helper molecules called transfer
RNAs (tRNAs) deliver the correct amino acid.
The tRNA confirms the
codon match, then releases the amino acid
to join the growing chain.
The way these ``bio-computers''
operate resembles Turing machines:
they store information in strings of symbols (over
some finite alphabet), and both process
these strings sequentially according to fixed rules.


Charles Bennett in~\cite{Bennett} described a
``truly chemical Turing machine'' with
a linear tape analogous to RNA.
Another design was given by Rothemund in~\cite{Rothemund}.
(A good survey on the topic, some recent developments
in the field, and another design of a molecular Turing machine
can be found in~\cite{EhudKobi}.)
%In the cited work, authors report successful implementation
%of a programable finite automaton that runs \emph{in vitro}.
The design of such devices should
be implementable from biomolecules (biopolymers)
that utilize standard operations of biomolecular machines.
These machines should be capable of sensing a
biomolecular input and capable of  synthesizing
a biomolecular output.
Given the probabilistic nature of the computation at this scale
and the imprecise behavior of biomolecular elements, certain
transitions would inevitably be faulty, besides the ``decay'' of
the information stored on the tape far from the head.
%This problem is even more pronounced when such a ``computer''
%is ``deployed'' into a cell to perform certain tasks, like
%acting as a ``cellular doctor'' or conducting some intracellular
%experiments.
Realization of this idea is tightly coupled with the issue
of fault-tolerance of such Turing machine-like devices.
%Bringing  such a computer to life, would represent
%a fundamental advance in the integration of computation with its
%environment.



\section{Our result}

Our contribution uses one of the standard definitions of a Turing
machine, with the exception that our machine does not
have a halting state.

\begin{definition}[Turing machine]\label{def:TM}
    A Turing machine $M$ is defined by a tuple
        \begin{align*}
             \left(\Gamma,\Sigma,\delta,q_{\start},F\right).
        \end{align*}
    Here, $\Gamma$ is a finite set of \df{states},
    $\Sigma$ is a finite alphabet, and
        \begin{align*}
             \delta: \Sigma\times \Gamma\to \Sigma\times\Gamma\times\{-1,0,+1\}
        \end{align*}
    is a transition function.
    The tape alphabet $\Sigma$ contains at least the distinguished
    symbols $\blank,0,1$ where $\blank$ is called the \df{blank symbol}.
    The distinguished state $q_{\start}$ is called the \df{starting state}.
    The set $F$ of \df{final states} has the property that whenever $M$ enters a
    state in $F$, it can only continue from there to another state in $F$, without
    changing the tape.

    The tape is blank at all but finitely many positions.

    A \df{configuration} is a tuple
        \begin{align*}
             (q,\h,x),
        \end{align*}
    where $q\in\Gamma$, $\h\in\bbZ$ and $x\in\Sigma^{\bbZ}$.


    The work of the machine can be described as a sequence of configurations
    $C_{0},C_{1},C_{2},\dots$, where $C_{t}$ is the configuration at time $t$.
    If $C=(q,\h,x)$ is a configuration then we will write
        \begin{align*}
             C.\state=q,\quad C.\pos=\h, \quad C.\tape=x.
        \end{align*}
    Here, $x$ is also called the \df{tape configuration}.

    The cell at position $h$ is the  \df{current cell}.

    \end{definition}

Though the tape alphabet may contain
non-binary symbols, we will restrict input and output to binary.


    In case of a noiseless operation, let
        \begin{align}\label{eq:M()}
            M(x, t)
        \end{align}
    denote the configuration at time $t$, when started
    from an input binary string $x$
    written on the tape starting from position 0,
    with head position 0 and the
    starting state.
    Thus, the symbol at tape position $p$ at time
    $t$ can be written
        \begin{align*}
             M(x,t).\tape[p].
        \end{align*}

%For an arbitrary binary string $x$, let
%        \begin{align}\label{eq:M()}
%            M(x,t)
%        \end{align}
%    denote the configuration at time $t$, when started from a binary input string $x$
%    written on the tape starting from position 0, with head position 0 and the
%    starting state.
%    Thus, the symbol at tape position $p$ at time $t$ can be written
%        \begin{align*}
%             M(x,t).\tape[p].
%        \end{align*}
    The transition function $\delta$ tells us how to compute the next
    configuration from the present one.
    When the machine is in a state $q$, at tape position $\h$, and
    observes tape cell with content $a$, then denoting
         \begin{align*}
           (a',q',j)=\delta(a,q),
         \end{align*}
    it will change the state to $q'$, change the
    tape cell content to $a'$ and move to tape position to $\h+j$.
    For $q\in F$ we have $a'=a$, $q'\in F$.


\begin{definition}[Fault]\label{def:fault}
    We say that a \df{fault} occurs at time $t$ if the output $(a',q',j)$ of the
    transition function at this time is replaced with some other value
    (which is then used to compute the next configuration).
\end{definition}


\begin{definition}[Codes]\label{def:codes}
    Let $\Sigma_{1},\Sigma_{2}$ be two finite alphabets.
    A \df{block code} is given by a positive integer $Q$--- called
    the \df{block size} ---
    and a pair of functions
    \begin{align*}
            \psi_{*} :\Sigma_{2}\to\Sigma_{1}^{Q},
            \quad
            \psi^{*}:\Sigma_{1}^{Q}\to\Sigma_{2}
    \end{align*}
    with the property $\psi^{*}(\psi_{*}(x))=x$.

   % Each block code gives rise to a natural
%    \df{tape configuration code} which is a pair of functions
%    \begin{align*}
%            \phi_{*} :\Sigma_2^{\bbZ}\to\Sigma_{1}^{\bbZ},
%            \quad
%            \phi^{*}:\Sigma_{1}^{\bbZ}\to\Sigma_{2}^\bbZ.
%    \end{align*}
%    If $\xi=\dotsm \xi(-1)\xi(0)\xi(1)\dotsm$ is an infinite string of letters of $\Sigma_{2}$
%    then $\phi_{*}(x)$ is the string
%    \begin{align*}
%        \dotsm\psi_{*}(\xi(-1))\psi_{*}(\xi(0))\psi_{*}(\xi(1))\dotsm,
%    \end{align*}
%    while for decoding an infinite configuration $\xi'$ we subdivide it first into
%    blocks of size $Q$ (starting with $\xi'(0)\dotsm\xi'(Q-1)$), decode each block
%    separately, and concatenate the results.
\end{definition}



 For simplicity,
 we will consider only computations whose result
 is a single symbol, at tape position 0:
 \begin{align*}
    M(x,t).\tape[0]
  \end{align*}
at any time $t$ in which $M(x,t).\state$ is a final state.


\begin{theorem}\label{thm:main-main}
There is a constant $\varepsilon_0 > 0$ such that,  for
any Turing machine
     $G$
with alphabet $\Sigma$ and
 state set $\Gamma$,
 the following can be constructed:
  \begin{enumerate}
  \item  An integer $Q$;
      %   depending
         % linearly on  $|p|$ and logarithmically
       %  polynomially on the size
       %  of $\Sigma$ and $\Gamma$;


  \item  A block code
        $(\phi_*, \phi^*)$ of blocksize
        \begin{align*}
           Q^{K-1}
        \end{align*}
        where
        For $K = c_1\log\log T_G + c_2$, for $T_G$ given below;


  \item A Turing machine $M_{1}$ whose
        set of final states is empty and
        whose number of states and alphabet
        size depend logarithmically on
        those of $G$;
%        $Q$;

  \item A function $f$ defined on the alphabet of $M_1$;
 \end{enumerate}
 such that the following holds.

 Suppose that on input $x$ machine $G$ reaches a final
 state at time $T_G$, and denote by
 $\xi$ its initial configuration.


 Assume that $M_1$ starts its work from the initial state
 and the initial
 tape configuration
    \begin{align*}
        \phi_{*}(\xi):=\dotsm\phi_{*}(\xi.\tape[-1], s_{-1})\phi_{*}(\xi.\tape[0], s_0)\phi_{*}(\xi.\tape[1], s_1)\dotsm,
    \end{align*}
where $s_i = \xi.q$, if $i=0$, and $s_i=\blank\;$,   otherwise.
Assume further that
 during its operation, faults occur independently at random
 with some fixed probability that is $\leq \varepsilon_0$.
 Let $t$ be any time such that $C T_G < t < Q C T_G$,
 where
 \begin{align*}
    C = (\log T_G)^{O(1)}.
   %C= &(D Q^2)^{K-1}%\\
   %C_2= &D^{2K+1}Q_{(K+1)(K+2)}.
 \end{align*}
 %for some constant $D$, $D>0$.

 Then
 \begin{align}\label{eq:main-thm}
     f(M_1(\phi_{*}(x), t).\tape[0])= G(x,T_G).\tape[0]
 \end{align}
 holds with probability at least $1 - O(\varepsilon_0)$.
\end{theorem}
%
%Since  $K = c_1 \log\log T_G + c_2$,
%the time dilation needed to read the result
%of $G$ in a designated cell and the space redundancy are bounded by
%$$(\log T_G )^O(1).$$

\section{Overview of the construction}


%We consider computation of a Turing machine when its
%operation is subjected to some ``noise'' that ---at certain moments
%of computation --- causes a violation of its
%transition function.
%The state of the machine after a fault is arbitrary.
%The content of the cell where the head was during a fault
%is arbitrary.
%After a fault, the head can stay over the cell
%where the fault occurred, or move to one of its
%two neighbors.

Faults may occur in a sequence
of consecutive times that we call \df{bursts}.
Our focus is on
faults that can occur with some small probability independently
of each other.

 A \df{simulation} of a machine $M_2$ by $M_1$
 is a correspondence between
 configurations of $M_2$ and $M_1$ which remains invariant
 during the computation with eventual time dilation.
 We say that machine $M_1$ simulates machine $M_2$ if
 there is a simulation of $M_2$ by $M_1$.
 Later, we will give a more precise definition of
 the simulation.

A construction of a Turing machine that
simulates ``reliably'' any other
Turing machine even when it is subjected to
isolated bursts of faults of constant size,
is given in~\cite{Bursts}.
By \df{reliably} we mean that the machine can
decode the simulated computation from the histories
of the simulating machine despite occasional damages.

%Such a machine has two error-recovering mechanisms.
%One is built - in in the encoding used to represent
%the simulated machine.
%The other mechanism is used to restore the state
%of the simulation itself.
%The first mechanism uses an error-correcting code,
%and the second mechanism uses a ``local structure''--- logs
%of the status of the simulation on the
%tape ---
%that guarantees that the operation of the simulating
%machine is resumed after a burst, using
%a constant time and constant space error-recovery procedure, where
%both constants depend on the burst size.



%It relies on two error-recovery mechanisms.



\subsection{A machine that can withstand isolated bursts of faults}
Let us give a brief overview of machine $M_1$ that
can withstand isolated bursts of faults.


The state
and a cell of machine $M_1$ have different fields.
Fields $\cInfo$ and $\cState$ of a cell store the tape content
and the current state of the simulated machine
using some error-recovery code.
The cells of machine $M_1$ are grouped into
intervals of consecutive cells called \df{colonies}.
The number of cells in a colony is denoted by $Q$.
%, and
%it depends on the value of the $\level$ field of the state.

Since one colony contains many cells, each cell
has a field that contains its address within
the colony.
To keep track of the state of the simulation,
machine $M_1$ keeps the address of the
current cell on the head together with a program
counter.
One step of the simulated machine is simulated
by a constant number of steps of machine
$M_1$, that we call \df{work period}.
One work period of $M_1$ lasts for
$\U_1 = O(Q^2)$ steps.

The basic operating step for a Turing machine consists
of examining the symbol currently under its read/write head,
examining its internal state (of which there are only a finite number),
and conditional on these two values, writing a new symbol
on the current location,  and eventually moving in the neighboring
position.

Machine $M_1$ performs these steps in two phases.
In the \df{computation phase} the machine
examines the state and the current symbol of the simulated
machine $M_2$ by
sweeping
the \df{base colony} --- the colony that corresponds to the
current cell of $M_2$---
and decoding from the strings stored in
$\cState$ and $\cInfo$ respectively.
Then, it applies the transition function of $M_2$
(which is stored on the head of $M_1$) and obtains
the new symbol, the new state, and the direction
where the head of $M_2$ will move.
It will store these values by encoding them and
spreading the codeword to appropriate fields
of the colony.

If the direction of $M_2$ is zero, then this work period
is essentially finished.
Otherwise, the head will transfer the $\State$ in the neighbor
colony.
Once this is completed,
it will start a new work period starting from the
first cell of the appropriate neighbor
colony.

%At each step of the simulation, the machine writes the
%values of the address field and the program counter
%on the active cell.
%We will call this the \df{structure}.

This machine has two error-correcting mechanisms.
The first mechanism is concerned with the ``correctness''
of the information and of the computation and it
relies on an error-correcting code and some redundant
repetitions of the crucial computational steps.
This mechanism is ``built-in'' in the simulation itself.
However, the simulation could be interrupted or perturbed
by a burst in an arbitrary way.
For this reason, such a machine must contain a mechanism that
restores its state, so it can continue  with the simulation
in case that such an event occurs.
To facilitate this, the machine has a
``simulation structure'' ---
a storage designed to save the progress of the simulation.
In normal circumstances, the state of the head will always
be ``coordinated'' with the cell it is scanning.
If not an $\Alarm$ goes off, and a recovery mechanism
begins.
The recovery procedure performs local repairs
of the structure, and the machine continues
with the simulation.
The recovery procedure uses only constant time and constant space,
where both constants depend on the burst size.


%
%In case that a burst occurs,
%then there is a recovery procedure which,  within
%$O(\beta)$ steps of $M_1$, restores the normal operation
%of $M_1$, \ie $M_1$ contines with the simulation of $M_2$.
%
%The recovery procedure repairs only the structure, that is,
%it only restores the normal functioning of $M_1$.
%Eventual alterations done to the $\Info$ and the $\State$
%are handled by the error-correcting code
%that is used to store the symbol and the state
%of the simulated machine.



\subsection{The hierarchical construction}

In order to build a machine that can resist faults that
occur independently of each other with some small probability,
we take the approach suggested in~\cite{Kurdjumov},
and implemented in~\cite{GacsSorg97} for the case of
one-dimensional cellular automata, and in~\cite{DurShenRomTil}
for tiling.
Namely, we will build a \df{hierarchy of simulations}
where $M_1$ simulates machine
$M_2$ and can withstand
low frequency bursts of faults.
Machine $M_2$ has the same program as $M_1$.
Machine $M_2$ simulates machine $M_3$, and so on.


One cell of machine $M_3$ corresponds to one colony
of machine $M_2$.
Correspondingly, one cell of $M_2$ corresponds
to one colony of machine $M_1$.
This means, that one cell of $M_3$ corresponds
to $O(Q^2)$ cells of $M_1$.
Further, one step of machine $M_3$ is simulated by one
work period of $M_2$.
Then, one step of $M_2$ is simulated
by one work period of $M_1$.
Hence, one step of $M_3$ is simulated by
$O(Q^4)$ steps of $M_1$.

Per construction, machine $M_1$ can withstand
bursts of faults whose size is $\leq \beta$ that
are separated by at least $V$ fault-free steps.
Machines $M_2$, $M_3$, \dots have the same program, so it
would be natural to expect that machine
$M_1$ can withstand larger bursts
of size $\leq \beta Q_1$ that
are separated by at least
$O(Q^2)$ fault free steps.
This is possible since damage caused by such large bursts
and a large burst itself
at level $M_1$, can be ``interpreted''
as an isolated island
on the scale of the second level.
On the scale of the first level, this damage
is extensive --- spanning several colonies.
Machine $M_1$ will not be able to ``restore
completely'' the entire damage created by
such --- larger, but sparser --- bursts,
since all repairs that these machines can do to their
structure are local --- spanning a couple of cells
(see Fig.~\ref{fig:essence}).
Instead, $M_1$ will try to restore a
large enough portion of the
tape, so it can continue with
the simulation of $M_2$.
Machine $M_{2}$ will contribute
to correction of this damage as
long as it ``runs'',
that is, as long as the simulation of
$M_2$ by $M_1$ is being carried out.
The way that  $M_2$ contributes is by
running its own recovery procedure.

Even if the head of $M_1$ is in an interval
of damaged area where its recovery procedure
fails to restore the structure, we must make sure that
it ``cleans-up'' large enough portion of the
tape or creates a new colony, so the simulation
of $M_2$ can be continued.

If the recovery procedure of $M_2$ starts,
then the simulating machine will go over
the damaged area and establish appropriate
``healthy'' structure there.

All machines above $M_1$ in the hierarchy are
``virtual'': the only hardware in the construction
is machine $M_1$ that
%does the entire ``work''.
carries out the entire computation.

The first tricky issue in constructing such object is that
machine $M_1$ needs to contain its own description and the
description for constructing $M_2$, which must contain
the description for constructing machine $M_3$ and have
the same error-correcting properties as $M_1$, and so on.
Though at the first glance this may seem impossible, we
can achieve this by
using the construction from the proof of the Kleene's Fixed-point Theorem.
We first fix a programming language and write an interpreter
for it.
Then, machine $M_1$ simulates the interpreter which is fed with
the program of machine $M_1$ in the fixed programming language.
Hence, this self-description has two roles: (1) it is a recipe
for controlling the construction of $M_2$; and
(2) it represents the data that will be written verbatim
on the tape so the universal interpreter can execute it
as a universal Turing machine would do.
The program is not stored on the tape as it may get
corrupted by the noise,
hence it is hardwired in $M_1$.
During the computation phase of each work period,
the machine will write
its own program on a working track of the base colony,
hence feeding the interpreter for the fixed programming
language.



\begin{figure}[h]
\centering
\includegraphics[width=4in]{hpics/essence.pdf}
\caption[The essence of hierarchical construction]{
    A burst of size $\beta$ that spans $\beta$
    cells of $M_2$ corresponds to
    a large burst on $M_1$ that spans $\beta$ colonies.
    %The interval that needs the str Such damage is out of the scope of $M_1$'s recovery
%    capabilities.
%    If $M_2$ can heal from such an island, then so does
%    $M_1$
%    since $M_1$ simulates $M_2$.
    Note that the underlying structure of cells of machine
    $M_2$ is ruined by the burst
\label{fig:essence}}
\end{figure}

In this way, we build an infinite sequence of simulations, which
essentially makes machine $M_1$ able to withstand larger but sparser
bursts of faults.
We will usually refer to this simulation as ``the central simulation''.

Since the $M_1$ uses the universal interpreter, which in turns
simulates the same program, it is natural to ask
how  machine $M_1$ simulates a given Turing machine $G$?
For this task, we will have a separate simulations running
on each machine $M_i$.
This may sound patently conflicting in the sense that
the head of $M_1$, and hence the heads of $M_2$, $M_3$, \dots
 have ``their own agenda'' that is independent of $G$.
However, this is doable;
every machine $M_i$, $i>0$, performs
the oblivious simulation of machine $G$ on some separate
set of fields of the tape.
The higher the index of the machine that performs this
``side-simulation'', the higher the reliability (see Figure~\ref{fig:tower-intro}).
In this way, we will not loose universality,
and we will still
remain within a polynomial time dilation of this ``side -simulation''
of the customer's machine $G$.


\begin{figure}[h]
\centering
\includegraphics[width=4in]{hpics/tower-intro.pdf}
\caption[The tower of simulations]{
    A ``tower'' of simulations and the ``side-simulation'' of
    a customer's machine $G$; The arrow shows the direction of the
    reliability increase
\label{fig:tower-intro}}
\end{figure}




\subsection{From combinatorial noise to probabilistic noise model}

The construction we gave in the previous subsection
was related to increasing bursts that are not frequent.
In essence, that noise model is combinatorial.
To deal with probabilistic noise combinatorially,
we define the set of faulty times $\Noise$ as follows.
We first add the first level noise consisting of
violations of the transition function
that have ``low frequency''.
Then, we add the low frequency breaches of
the first level noise condition to create the second level
noise, and so on.
Set $\Noise$ obtained in this way will be ``sparse'' (in the measure
theoretical sense).

Compositions of reliable simulations are
even more reliable.
Hence, a sufficiently large hierarchy of such
simulations can resist even probabilistic noise:
A machine positioned high enough in the hierarchy can simulate
any other machine $G$ under any noise that incites machine
faults of machine $M_1$ to occur independently of each other with some
small probability $\varepsilon>0$.





%Consider machine $M_1$.
%We group its cells into constant size entities called
%the \df{colonies}.
%A cell of $M_2$ will be encoded in a colony of $M_1$.
%Throughout this paper, simulated cells (say cells of $M_2$ simulated
%by $M_1$) will be referred to as \df{macro-cells}.
%In general, if we are considering cells of $M_i$, $i>1$,
%then cells of $M_{i+1}$ will be called macro-cells, and cells of
%$M_{i-1}$ will be called micro-cells.




\subsection{Difficulties}\label{sec:novelties}

The hierarchical construction may seem natural, but
maintaining its structure in presence of bursts presents
some serious difficulties.

Let us spell-out some of the problems caused by larger
bursts, and some general ways they can
be solved or avoided.


\begin{bullets}

\item The state of $M_1$ after a fault is arbitrary.
All cells of $M_1$ that were visited by the head
during a burst have arbitrary content.
A large burst of $M_1$ can modify the order of
entire colonies or put them apart.
Then the simulated cells of $M_2$ can be \df{non-adjacent} (or misplaced), \ie
their distance is $<\B$, where $\B$ is the cell body size.

To overcome this problem conceptually, we need
to introduce the notion of a \df{generalized Turing machine}
allowing for non-adjacent cells.
Each such machine has a parameter $\B$ that is called the \df{cell body size}.
For example, cell body size of
a Turing machine per Definition~\ref{def:TM}
is $1$.
%For this reason, and for some other that we will when the distance between
%two cells can be more than  $\B$,$\B\geq 1$ where
%$\B$ is the cell size.
%Normally, two neighboring cells should be within a
%distance of $<\B$ from each other.


    \item %As in~\cite{Bursts},
    Noise can create \df{islands} over
     which the predictability of the machine is limited.
     However, now these islands may have also the invisible structure
     of their underlying (invisible) simulation destroyed.
     Therefore these areas should not simply be blank, since
     even blankness implies predictable behavior.
     Instead, they will be called \df{damaged}.
     We can mark them by a new cell state called $\Bad$.
     When we are in or near damage then even in the absence of faults,
     the predictability of the behavior of the machine will be
     severely limited.

    \item
        What to do with the damage?

        Damaged cells will be killed, and new cells will be
        created instead.

    \item What to do when the head is in a middle of an empty area
       where no structure exists?

        We will create rules that keep everything
        filled with cells, even if these are
        not part of the main computation.
        We introduce a ``less specialized'' kind of a cell
        called a \df{stem cell}.
        Stem cells are like the blank cells of $M_1$ in the sense that
        they will be easy to write
        over, but a stem of the second level is still
        simulated by a colony of the first level.

        When a colony simulates a transition
        to a vacant cell (\df{dying}), its own cells
        turn to stem cells.

        We will see below that stem cells will
        also carry some information.


%        \item If the recovery fails for whatever reason,
%          then a new alarm is called.
%          However, this is not sufficient: we will also move left
%          within the recovery area until we find an interval
%          of size $\beta$ containing at least one live cell,
%          kill the interval and move to the right to do the same
%          on the right half.
%          Once this is completed, come to the center of the interval
%          and call $\Alarm$.
%          Now, the recovery may succeed or fail.
%          In the latter case, the killing process is repeated.
%          Eventually, the entire interval may be emptied, in which
%          case, a new colony will be created.
%
%          Killing one cell is sufficient.
%          The result of this rule is that any big mess that cannot be locally
%          repaired will be gradually killed.%, with the head moving over it to
%%          the left.

        \item If the recovery fails because the repair that is needed to
         restore the state of the machine is impossible,
         then it ``gives up''.
         This is an indication of a larger mess in a colony structure, and
         hence a special rule is needed to rebuild the colony structure.
         This rule will initiate a process that will sweep and analyze a
         larger part of the tape around the head's position.
         The goal of the rule is to asses the ``damage'' and take certain actions
         like
         killing an interval and creating a new colony.


%        \item What to do when after a new alarm, the head is found
%          in the middle of an
%          area containing only stem cells (if at all)?
%          Start a new colony of stem cells (i.e. simulating blank cells). %that will represent a stem cell.
%          If you meet a live cell during the building process, call alarm.

        %\item For a full definition of the model,
%          it is necessary to say how the head is
%          represented.
%          The notion of a colony is not a part of the definition
%          of a Turing machine.
%          Hence, we will refer to the cells of the simulated
%          machine as the \df{big cells}.
%
%         When the head is not on a big cell,
%         one cannot abstract away from its position,
%         since the gap between two such cells can be very large.
%         When a particular big cell is observed,
%         it may be confusing to refer to the head's
%         actual position
%         as inherited from lower-ordered cells simulating
%         the present one, since the head will make some trips
%         between two neighbor colonies before the base colony is moved.
%
%         We take a mixed solution: when the head observes
%         a big cell, its position is
%         declared to be at the left end.
%         But it can also be anywhere between macro-cells.
%
%         Legal transition of the head starting on a cell
%         is always between neighbor cells.
%         If the head is outside a big cell,  then it will
%         end up in a nearby big cell soon which
%         can be the one that is newly created.

\end{bullets}

\subsection{A shortcut solution}

    We have mentioned that a construction of a fault-tolerant
    one-dimensional cellular automata is given
    in~\cite{GacsSorg97}.
    Since Turing machines are universal, it is tempting to think
    that by just simulating such automaton, we would derive
    a fault-tolerant Turing machine.
    Indeed, if we are given a Turing machine $G$, its input and
    its space requirement $m=S(x)$, then we can
    define a specific Turing machine $M_m$ that
    works on a \df{circular tape} of size $O(m)$, whose
    head moves only to the right.
    Then at each step it passes, it simulates a fault-tolerant
    cellular automaton $C$, which in turn simulates any given
    machine $G$ reliably.
    However, the requirement of a circular tape introduces
    the need of input size-dependent hardware.

    Alas, it seems very hard to define a
    fault-tolerant sweeping
    behavior on a regular Turing machine that could
    simulate cellular automaton $C$, without recreating
    the entire hierarchical construction that is used
    in $C$ already.

\section{Notational conventions}\label{sec:notational-conventions}

Below, we give some important notational conventions that we
will obey throughout this work.



\begin{flushdescription}

\item [Natural numbers and integers] \hfill

We assume that $\bbN=\set{0,1,2,\dots }$.
By $\bbZ$ we denote the set of
integers.
Then,
\begin{align}
   \bbZ_{>0}&=\setOf{x}{x\in \bbZ,\;  x>0}, \\
   \bbZ_{\geq 0}&=\setOf{x}{x\in \bbZ,\;  x\geq 0}.
\end{align}

\item [Intervals] \hfill

We use the standard notation for intervals.
Namely, for $a$ and $b$, $a\leq b$,
\begin{align}
   [a,b]&=\setOf{x}{a\leq x \leq b}, \\
   [a,b)&=\setOf{x}{a\leq x < b}, \\
   (a,b]&=\setOf{x}{a< x \leq b}, \\
   (a,b)&=\setOf{x}{a< x < b}.
\end{align}

Instead of
\begin{align*}[x+a, x+b),\end{align*}
whenever we see that it is beneficial for
the exposition,  we will write
\begin{align*}x + [a,b).\end{align*}
Similarly for other types of intervals.

Also, for any interval $I := [a,b)$, we will
write $x + I$, instead of $x + [a,b) = [x + a, x+ b)$.

\item [Ordered pairs] \hfill

Ordered pairs are also denoted by
\begin{align*}(a,b),\end{align*}
but it will be clear from the context if we are
referring to an ordered pair or open interval.

\item [Comparing the order of a number and an interval]\hfill

For a given number $x$ and interval $I$, we
write
\begin{align*} x \geq I \end{align*}
if for every $y\in I$,  $x \geq y$.
Similarly for $x>I$, $x\leq I$, and $x<I$.


\item [Distance] \hfill

The distance between two real numbers $x$ and $y$ is defined
in a usual way:
\begin{align*}
    d(x,y)= |x-y|.
\end{align*}

The \df{distance
of a point $x$ from interval $I$}  is
\begin{align*}
    d(x,I)= \min_{y\in I}d(x,y).
\end{align*}

\item [Topological objects: ball, neighborhood, ring, stripe]
\hfill

We define a \df{ball of radius $r$, $r>0$, centered
at $x$} in a standard way
\begin{align*}
    B(x,r)= \setOf{y}{d(x,y)\leq r}.
\end{align*}

Also,  a \df{$r$-neighborhood of interval } $I$,
is
\begin{align*}
    \setOf{x}{d(x,I)\leq r}.
\end{align*}

A \df{$r$-ring} around interval $I$ is
\begin{align*}
    \setOf{x}{d(x,I)\leq r \txt{ and } x \notin I}.
\end{align*}

A \df{$r$-stripe to the right of interval $I$} is
\begin{align*}
    \setOf{x}{d(x,I)\leq r \txt{ and } x \notin I \txt{ and } x>I}.
\end{align*}


\item[Logarithms] Unless specified differently,
the base of logarithms throughout this work is 2.

\end{flushdescription}




\section{The model}

Standard definitions of Turing machines, do not
include operations like ``cell creation'' or ``cell killing'', nor
they allow for cells to be non-adjacent.
%Noise can damage some parts of the tape, at least temporarily:
%we introduce a special cell state $\Bad$ to mark such cells.
For this reason, we need to introduce the notion of a \df{generalized
Turing machine}.
Besides the common features that we have seen in a classical definition
of a Turing machine in Definition~\ref{def:TM}, in the definition
of a generalized Turing machine we introduce
an integer $\B \geq 1$ that denotes the cell body size,
and the upper bound $\Tu{}$ on the transition time.
(On a classical Turing machine, both these values can be taken
as 1.)
Further, we enrich the alphabet and the set of all possible
states with some distinguished states, like $\Bad$ and $\Vacant$.


\begin{definition}[Generalized Turing machine]\label{def:gen-TM}
    A \df{generalized Turing machine} $M$ is defined by a tuple
        \begin{align*}
             \left(\Gamma,\Sigma,\delta,q_{\start},F,\B,\Tu{}\right),
       \end{align*}
    where $\Gamma$ and $\Sigma$ are two finite sets
    called the \df{set of states} and the \df{alphabet},
    respectively,
        \begin{align*}
             \delta: \Sigma\times \Gamma \times \{0,1\}
             \to \Sigma\times \Gamma
        \end{align*}
    is the \df{transition function}, and $\Tu{}$ is
    the bound on the transition time.
    The integer $\B\geq 1$ is called the
    \df{cell body size}.


    Each element of $\Gamma$ and $\Sigma$
    is a tuple
    \begin{align*}
        q=(q_{1},q_{2},\dots,q_{k}),
    \end{align*}
    where the individual elements
    of the tuple will be called \df{fields}, and will
    have symbolic names.
    Some of the fields of an element of $\Sigma$ may
    have names identical to fields of an element of $\Gamma$,
    and will be distinguished by a prefix $\fld{c.}$.% (like $\cInfo$).

    Among the elements of a tape alphabet $\Sigma$, we distinguish
    the states $\Bad,\Vacant,0,1,$ % and $\dot{1}$,
    and the field $\cDir \in \set{\lptr, \rptr}$ that
    points towards the head.
    We also distinguish the field $\G \in \set{\true, \false}$
    %and $\Mode \in\set{\Normal, \Recovering, \Healing}$
    of states in $\Gamma$.
   % The role of the distinguished state $\dot{1}$ will be explained
%    later.

    % point
    The symbol $\Bad$ will mark \df{damaged} parts of the tape.

    The distinguished state $q_{\start}$ is called the
    \df{starting state}, and the set $F$ is the set of \df{final states}.

\end{definition}

Intuitively, the damage can be considered as an ``upheaval'' for
the head of the machine,
as the underlying cell structure inside the damage that simulates it
is ruined (see Figure~\ref{fig:essence}).

%    As we have seen in the previous definition,
%    the transition function has an extra input
%    parameter that is supplied by the simulation environment.
%    In the following definition, we make the role of this
%    parameter clear.


%     Under certain conditions,
%     the value of the input parameter $\G$ of
%     the transition function and
%     the value of the field $\cDir$ of the current
%     cell, are
%     determined by the simulation
%     environment.
%     Similarly,  is set by the simulation environment.

\begin{definition}[Configuration]\label{def:config}

     Consider a generalized Turing machine
        \begin{align*}
             M = \left(\Gamma,\Sigma,\delta,q_{\start},F,\B,\Tu{}\right).
       \end{align*}

    A \df{configuration} is a tuple
        \begin{align*}
             (q,\h,x),
        \end{align*}
    where $q\in\Gamma$, $\h\in\bbZ$ and $x\in\Sigma^{\bbZ}$.

    A \df{cell} is position $p\in\bbZ$ such that
    $x[p]\notin \set{\Vacant, \Bad}$ and
    interval $p+[0,\B)$ being its \df{body}.%, and
%    $\B$ its \df{body size}.

    Whenever $x[\h]\notin\set{\Bad, \Vacant}$,
    there is a cell at position $\h$.

    A certain cell whose body is
    within
    $2.5\B$ from $h$ whenever $x[h]\neq \Bad$
    is called the \df{current cell}.
    Whenever the head is not on a cell that is $\Bad$,
    the current cell must exist.

    Position $0$ is distinguished, and we will
    call it the \df{origin} of the tape.

    The tape is $\Vacant$ everywhere but in finitely many positions.

    We require that the distance of neighbor cells
    is at least $\B$.

    For a tape configuration $x$ we define the \df{damage set}%
     \begin{align*}
          x.\Damage=\setOf{p}{x[p]=\Bad}.
     \end{align*}

     We require that for all $p\notin x.\Damage$,
     $x[p].\cDir$ points towards the head.

    Let
    \begin{align*}
         \Configs_{M}
    \end{align*}
    denote the set of all possible configurations
    of a Turing machine $M$.



%    If $\delta(a,q,\G)=(a',q',j)$ then we will write
%        \begin{align*}
%            &\delta(a,q,\G).{\tape}=a',\\
%            &\delta(a,q,\G).{\state}=q', \txt{and} \\
%            &\delta(a,q,\G).{\pos}=j.
%        \end{align*}
    % It expresses the intent
%     that the current cell changes its content
%     to $a'$, %and its distinguished
%     %field $\cDir$ to be set to $j$;
%     the state to change to $q'$;
%     the head to change its position by moving to a position
%     $d j\B$, $d\in[\B, 2\B)$,  from its previous position.

\end{definition}


%    The transition function $\delta$ tells us how to compute the next
%    configuration from the present one.
%
%    If $\delta(a,q, \G) = (a',q',j)$ then we will write
%    \begin{align*}
%        \delta(a,q, \G).{\tape} = a',
%        \quad
%        \delta(a,q, \G).{\state} = q',
%        \quad \delta(a,q, \G).{\pos} = j,
%    \end{align*}
%    and require that
%    $ a'.\cDir = j $,
%    where $\G$ is an input parameter to the
%    transition function.
%
%    One transitional step
%    \begin{align*}
%        \mstep_M: (a,q,\G) \mapsto (a', q',  d',\G'),
%    \end{align*}
%    is performed according to the transition function
%    where $\G'$ %and $\Dir'$ are
%    is determined by the transition process.
%    The total time needed to complete the transition process
%    does not exceed $\Tu{}$.
%
%


%It is important to point out here that the definitions above
%pertains only to the machines that will be simulated and
%not the hardware that we are using: on the hardware level,
%two cells will always be adjacent to each other.


%\begin{definition}[Configuration]\label{def:config}
%    Let us be given a generalized Turing machine
%        $$M=(\Gamma,\Sigma,\delta,q_{\start},F,B,\Tu).$$
%    A \df{configuration} of $M$ is a tuple
%        \begin{align*}
%             (q,\h, x),
%        \end{align*}
%    where $q \in \Gamma$, $\h \in \bbZ$ and $x \in \Sigma^{\bbZ}$.
%    Here, $x$ is also called the \df{tape configuration}.
%    Positions $p\in\bbZ$ on the tape will also be called \df{sites}.
%    The tape configuration is $x$:
%    the content of the tape cell at position $p$ is
%    $x[p]$.
%%    If $C=(q,\h,x)$ is a configuration then we will write
%%    \begin{align*}
%%         C.\state=q,\quad C.\pos=\h, \quad C.\tape=x.
%%    \end{align*}
%\end{definition}





%
%\section{Outline of the work}
%\Inote{Commented out}
%%In Chapter~\ref{sec:blueprint} we construct a generalized Turing machine
%$M$ that simulates a given machine $G$ obliviously when
%bursts of faults of size not exceeding $\beta$ that
%are separated with at least $V$ fault-free steps occur.
%This machine is able to simulate any other machine step-by-step, and
%in particular we will force $M_1$ to simulate itself.
%
%In Chapter~\ref{sec:integrity} we will give the first
%tools in analyzing our machine.
%Namely, there we will define the integrity of the simulation
%structure and give an algorithm that repairs local damages of
%the structure.
%This chapter is followed by the description of the recovery
%procedure and the healing procedure.






%\include{sec-trajectory}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{The Tower}\label{sec:theTower}

%THIS IS STILL A SEPARATE CHAPTER to make
%the navigation easier.
%It will merge with the previous one to make
%a natural flow of the narrative.

%In this section, we will introduce the mathematical framework
%needed for our construction.
%We will first define the notions of history and trajectory, and
%then define the notion of the simulation.
%
%In this chapter will spell out a crucial lemma for our
%construction that states that the simulation of a trajectory is
%a trajectory too.
%%This lemma will be used to prove the Main lemma, which yields
%%our Main Theorem.
%
%Finally, we will show here that by considering
%large and larger bursts, we encapsulate the model
%when faults occur at random independently of each other
%with some small probability.
%This is a relatively known result and for
%a nice treatment we refer the reader to~\cite{DurShenRomTil}.




\section{Trajectory, simulation, and the tower}


The notion of a trajectory will play a central role in
the formal treatment.
It uses the fact that when the head is at some
place, at some times a \df{fault} can occur.
We will denote by
\begin{align}\label{eq:noise-first}
   \Noise, \quad \Noise\subseteq \bbZ\times \bbZ_{\geq 0}
\end{align}
the set of $(p,t)$, such that
a fault occurs at time $t$ when the head is at
position $p$.


\begin{definition}[History]\label{def:history}
    Let us be given a generalized Turing machine
        \begin{align*}
          M = \left(\Gamma, \Sigma, \delta, q_{\start}, F, B, \Tu{} \right).
        \end{align*}
    Consider a sequence
    $\eta = (\eta(0), \eta(1), \dots)$
    of configurations with
    $\eta(t) = (q(t), \h(t), x(t))$,
    along with a noise set
    $\Noise$. %\subseteq \bbZ_{\geq 0}$.

    If $x(t)[p]\notin \set{\Bad, \Vacant}$,
    then we will say that there is a \df{cell} at position $p$
    at time $t$.

    Whenever \( (h(t),t)\not\in \Noise \),
    a configuration $\eta(t)$ and time $t$
    is \df{noise-free}.

%    If the head is not in the damage set then it must be on a cell.

    The pair
    \begin{align*}
       (\eta,\Noise)
    \end{align*}
    will be called a
    \df{history} of $M$ if the following conditions hold.

        \begin{bullets}
            %\item Computation always starts from
%                  a starting state $q(0) = q_{\start}$.

            \item In two consecutive configurations,
                  the content of the positions not in
                  $\h(t) + (-\B, \B)$, remains the same:
                  $x(t+1)[n] = x(t)[n]$ for all $n \notin \h(t) + (-\B, \B)$.

            \item If $t$ and $t'$ are two times such
                  that $t \leq  t'$, then
                       $|\h(t) - \h(t')| < t' - t$.

            \item The \df{switching times}
                  are the times when one of the following can change:
                  the state, the position of the current cell,
                  and the state of the current cell.

%
%            \item At each noise-free time, and when $x(t)[h(t)]\neq \Bad$,
%                  the head is
%                  is within a distance of $2.5\B$ from the
%                  current cell.

            \item At each noise-free switching time the head is on
                  the new current cell. %, and it is
%                  never farther than $2.5\B$ from the current cell.
                  In particular,
                  when at a switching time a current cell becomes
                  $\Vacant$,
                  the head must already
                  be on another (current) cell.

            \item
                   The interval between
                   two consecutive switching times is the \df{dwell period}.
                   In the absence of noise and damage, the length
                   of the dwell period never exceeds
                   $\Tu{}$.

%            \item At each noise-free time $t$,
%                  for every position $p$ such that
%                  $x(t)[p]\neq \Bad$, $\cDir$ field of
%                  $x(t)[p]$ points
%                  to the head $h(t)$.

        \end{bullets}

    Let
        \begin{align*}
            \Histories_{M}
        \end{align*}
    denote the set of all possible histories of $M$.

\end{definition}


\begin{remark}[Step and transition]
  Though it is natural to use the word `step' when
  describing operation of a generalized Turing machine,
  we will avoid it, and instead use terminology
  defined in Definition~\ref{def:history}.
\end{remark}


The transition function $\delta$ of a generalized Turing machine,
imposes constraints on histories: those
histories obeying the constraints will be called trajectories.

Suppose that the machine is in a state $q$, at tape position $\h$,
let $a$ be the content of the current cell. %and $\G \in \set{\true, \false}$.
Then,  denoting
$(a',q',j) = \delta(a,q)$,
the \emph{intent} is expressed that
at the next switching time, the state change to $q'$,
the current cell changes its content to $a'$ and its
distinguished field $\cDir$ to change to $j$,
and the head moves to the nearest cell in direction $j$.
Further, the new state $q'$ will remember
if the distance between the new current cell and
the previous one is more than $\B$, by setting
its distinguished field $\G$
to $\true$.


An interval $I\subseteq \bbZ$ is \df{damage-free}
if for every $p\in I$, $x[p]\neq \Bad$.

We say that a cell \df{dies} if it becomes $\Vacant$.



\begin{definition}[Trajectory]\label{def:traj}
   A history
   $(\eta, \Noise)$
   with
   $\eta(t) = (q(t),\h(t),x(t))$ of
   a generalized Turing machine
    \begin{align*}
             M = \left(\Gamma,\Sigma,\delta,q_{\start},F,\B,\Tu{}\right)
    \end{align*}
   is called a \df{trajectory} of $M$ if the following
   conditions hold,  provided that
   $\clint{t}{t + \Tu{} }$ is noise-free.

  % In what follows we use a constant $c$ to be fixed later.

   Denote $$(a, q, p) = (x(t)[\h(t)], q(t),\h(t)),$$
   and let $$(a',q',j) = \delta(a,q),$$
   for $j\in \set{ 0, \pm 1}$.

\begin{enumerate}

\item\label{i:bound-on-damage}
  The damage may be extended only to a distance \( 2\B \).
  The next time the head moves over such an extension,
  the new damage will all be erased.

\item\label{i:def.traj.transition}(Transition function)
    %\begin{enumerate}[(a)]
%        \item \label{i:def.traj.transition.(a)}
%              Suppose that the body $[x, x+\B)$ of
%              the current cell $x$ is disjoint from damage.
%
%              Then unless $x$ dies, the state of the machine
%              is $q'$ and the state of $x$ is $a'$.
%
%              At the time of transition switch,
%              the damage is still disjoint from the body of $x$, %$[x, x+\B)$,
%              even if the cell died.
%
%       \item\label{i:def.traj.transition.(b)}
%
%        Suppose that, in addition to~\ref{i:transition-funtion.a},
%        there is a new current cell \( y \),
%        and the shortest interval containing the bodies of \( x \)
%        and \( y \) is disjoint from damage,
%        and its size is \( <3\B \).
%        Further one of the following holds:
%        \begin{enumerate}[(i)]
%        \item Cell \( y \) existed before.
%        \item\label{i:transition-function.b.2} The smallest interval containing the bodies of \( x \) and \( y \)
%        is at a distance most \( 0.5\B \) from the damage.
%        \end{enumerate}
%
%        Then the machine state, the state of \( x \)
%        (including when it dies), and
%        the direction of \( y \) from \( x \) are directed
%        by the transition function.
%
%        In case~\eqref{i:transition-function.b.2}
%        the length of the dwell period is bounded by \( \Tu{} \).
%
%        If \( y \) did not exist before then it
%        is adjacent to \( x \).




%
%               Let $y_{-1}$ and $y_1$ be two positions
%               such that
%               $\B \leq |x - y_{i}|< 2\B$, $i\in\set{\pm 1}$,
%               and let $y_0 = x$.
%
%             %Suppose that $j\in\set{0,\pm 1}$ is the direction . % (resp., $j=-1$).
%             Suppose that the shortest interval
%             containing the body of $x$ and
%             the body of cell $y_j$ %$y_j + [0, \B)$
%             is disjoint from damage, and its size is $<3\B$,
%             for the direction $j$.
%
%%             In particular, if $y_j$ is not
%%             vacant, then $\cDir(y_j)=-j$.
%
%             Then the transition function determines
%             that the new state is $q'$,
%             $y_j$ is the new current cell, $a'$ is
%             the new content of $x$, and $\cDir(x)=j$.
%             The distinguished field $\G$ of $q'$
%             is set to true only if $\B<|x-y_j|$.
%
%
%             Let $y_j = x + j\B$, ($j\neq 0$), % (resp., $y_{-1} = x - $).
%             and
%             suppose that $y_j + [0,\B)$ %(resp., $y_{-1}-[Q\B, 0)$)
%             is
%             vacant.
%             Then, the transition function determines
%             that the new current cell will be
%             $y_j$, $\cDir(x) = j$, and
%             the $\G$ field of the new state $q'$ is
%             set to $\false$.
%
%      \item\label{i:def.traj.transition.(c)}
%            Suppose that in addition to \eqref{i:def.traj.transition.(b)},
%            the shortest interval containing the
%            bodies of $x$ and $y_j$%and $[y_j, y_j + \B)$
%            are at a distance at least $0.5\B$
%            from the damage, and
%            the head is damage-free during the
%            dwell period in question.
%            Then $x$
%            only dies if directed by the transition function.
%
%            Also, the length of the
%            dwell period is bounded by $\Tu{}$.

%\item\label{i:transition-function} (Transition function)

Suppose that there is a transition, and
the shortest interval
containing the body of the current cell \( x \) and the
new cell \( y \) is at a distance at least \( 0.5\B \)
from damage.

Then the machine state, the state of \( x \) (including when it dies), and
the direction of \( y \) from \( x \) are directed by the transition function.
If \( y \) did not exist before then it is adjacent to \( x \).

Further the length of the dwell period is bounded by \( \Tu{} \).


     % \end{enumerate}


  \item \label{i:def.traj.attack-from-outside}
    (Attacking damage from outside)

    Suppose that the body of the current cell $x$
    is disjoint from damage, and
    the transition function directs the head
    towards the damage to the right (resp., left),
    while $x$ is at least $0.5\B$ removed from the damage
    on the left (resp., right).

    This event
    will be called an \df{attack on the damage}.
    Then %at the time this cell changes state (possibly dies),
    there are two possibilities.
    Either the transition function is carried out, and the head moves
    to the right (resp., left).
    Then the damage will recede
    all the way from the body of the
    new current cell $y$.% that carries the symbol $\dot{1}$, until
%    the end of the switching time.
    %Also, $\cDir(x) = 1$ (resp., $\cDir(x) = -1$).


Or, the damage can extend to the left (resp., right) not farther than
 $ x $ (resp., $x + \B$).
Whenever the head comes left  of \( x \) (resp., right of $x + \B$) again,
the  damage will recede by a distance at
least \( 2\B \) from %the body of
\( x \).%, and $\Mode = \Recovering$.



   % Or, the transition function will not be carried
%    out, and cell $x$ dies.
%    Then, its body, the body of the new current
%    cell  and the space in between them
%    do not intersect the damage, and
%    the body of the
%    new current cell $y$ is $<2\B$ from
%    the body of $x$, and at
%    least $0.5\B$ apart
%    from damage in the direction of the attack.
 %   Further, before the state of $y$
 %   changes, it will carry the symbol  $\dot{1}$.
    %The $\cDir$ fields of the cells
%    that became damage-free
%    point to the new current cell.


\item \label{i:def.traj.damage-within}(Clearing damage from within)
There is a constant $ c_{1} $ with the following property.
Let $ I $ be a space interval of size $ 3\B $.
If the head spends a total time of at least $ c_{1}\Tu{} $ inside
$ I $ (while possibly
entering repeatedly), then $ I $ becomes damage-free.



%   There is a constant $c_1$ with the following
%   property.
%   Let $I$ be a space interval of size $2\B$.
%   If the head spends a total
%   time of at least $c_1\Tu{}$
%   inside $I$ (while possibly entering repeatedly), then $I$
%   becomes damage-free.
  % The $\cDir$ of cells that became damage-free point
%   towards the head.


%
%\item \label{i:def.traj.damage-spread}(Damage growth)
%   Whenever the head steps off from an interval $I$ of size
%   $2\B$ in a damage-free interval $A$ next to it,
%   then, a  subinterval of $A$ of size $<\B$ next to $I$
%   can turn to $\Bad$.
%   The damage in $A$ will be removed
%   together with the damage of $I$ within
%   at most $c_2\Tu{}$.
\end{enumerate}
\end{definition}


Until this moment, we used the term ``simulation'' to denote
a correspondence between configurations of
two machines which remains preserved during the computation.


\begin{definition}[Central simulation] \label{def:simulation-central}
Let $M_{1},M_{2}$ be two generalized Turing machines, and let
\begin{align*}
    \varphi_{*}:\Configs_{M_{2}} \to \Configs_{M_{1}}
\end{align*}
be a mapping from configurations of $M_{2}$
to those of $M_{1}$, such that it maps
starting configurations into starting configurations.
We will call such a map a \df{configuration encoding}.

Let
\begin{align*}
   \Phi^{*}:\Histories_{M_{1}} \to \Histories_{M_{2}}
\end{align*}
be a mapping.%, and let $\I$ be a
%nonempty set of tape configurations containing
%the image of the encoding $\varphi_*$.

%\Inote{ I thought that I will make use of $\I$, but I did not.
%I will remove the appearance of $I$ all over.}

The pair $(\phi_{*}, \Phi^{*}) $
is called a \df{simulation} (of $ M_{2} $ by $ M_{1} $) if for every
trajectory $ (\eta, \Noise) $ with initial
configuration $ \eta(0)=\phi_{*}(\xi) $,
the history $ (\eta^{*},\Noise^{*})=\Phi^{*}(\eta,\Noise) $ is
a trajectory of machine $ M_{2} $.

We say that $M_{1}$ \df{simulates} $M_{2}$ if there is a
simulation
$(\varphi_{*},\Phi^{*})$ of $M_{2}$ by $M_{1}$.
\end{definition}


\section{Hierarchical codes}\label{sec:hieararch-codes}

Recall the notion of a code in Definition~\ref{def:codes}.

\begin{definition}[Code on configurations]\label{def:configuration-code}
%Let $\Sigma_1$ and $\Sigma_2$ be two alphabets.

Consider a block code
\begin{align*}
   \psi_{*}:\Sigma_{2}\times(\Gamma_{2}\cup\{\emptyset\})\to\Sigma_{1}^{Q},
 \end{align*}
with an appropriate decoding function, $\psi^{*}$, and $a\in \bbZ$.
We require
\begin{align}\label{eq:B_2-B_1-Q}
  \B_{2} = Q \B_{1}.
\end{align}


    Each block code $(\psi_{*},\psi^{*})$
    gives rise to a
  \df{code on configurations}, which is a pair of functions
    \begin{align*}
        \phi_{*} :\Configs_{M_2} \to \Configs_{M_1},
        \quad
        \phi^{*}:\Configs_{M_1} \to \Configs_{M_2}
    \end{align*}
    that encodes configurations of $M_2$
    into configurations of $M_{1}$.

    Let $\xi$ be a configuration of $M_2$.%=\dotsm \xi(-1)\xi(0)\xi(1)\dotsm$ is
%    an infinite string of letters of $\Sigma_{2}$
    To each state of $\xi$, we associate state of $\phi_*(\xi)$
    that has $\G = \false$, and $\phi_*(\xi).\pos = \xi.\pos$.

    To determine $\phi_*(\xi).\tape[i\B_2, \dots, (i+1)\B_2 - \B_1]$,
    we compute $\psi_*(\xi.\tape[i], s)$, where
    $s$ is the state of $\xi$ if $i = \xi.\pos$, and $\emptyset$ otherwise.
    Further, $\cDir$ of $\phi_*(\xi).\tape[i]$, must point towards
    the head, for all $i$.

    For decoding an infinite configuration $\xi'$
    we subdivide it first into
    blocks of size $\B_2$ (starting with $\xi'(0)\dotsm\xi'(\B_2 - \B_1)$),
    decode each block
    separately using $\psi^*$, and concatenate the results.
 \end{definition}

 Not all configurations can be obtained by encoding.
 We distinguish those that can, with a special name.
 \begin{definition}[Code configuration]\label{def:code-config}
   A configuration $\xi$ is called a \df{code
   configuration} if the decoded configuration
   $\phi^*(\xi)$ covers an interval around the origin
   of the tape with
   adjacent cells and leaves the rest vacant.
   Further,
   the following relation must be satisfied
    \begin{align}\label{eq:codeconfig-condition}
      \phi_*(\phi^*(\xi))=\xi.
    \end{align}
 \end{definition}


Now we introduce the basic operation between two codes.

\begin{definition}[Code composition]\label{def:code-composition}
  If $\varphi=(\varphi_*, \varphi^*)$ and $\rho=(\rho_*, \rho^*)$ are
  two codes, then the code
  $\varphi \circ \rho$  is called the \df{composition} of
  $\varphi$ and $\rho$,
  and is defined by
  \begin{align*}
     (\varphi\circ \rho)_*(\xi) = \varphi_*(\rho_*(\xi)) \quad \txt{ and} \quad
     (\varphi\circ \rho)^*(\xi')= \varphi^*(\rho^*(\xi')),
  \end{align*}
  where $\xi$ and $\xi'$ are %configurations of $M_1$ and $M_2$,
  two configurations of machines
  whose cell body sizes are in an appropriate relation.
\end{definition}

We can apply the code composition on a code or itself many times.

\begin{definition}[Hierarchical code]\label{def:hierarchical-code}
For $k\geq 1$, let $\Sigma_k$ be an alphabet, $\Gamma_k$ be
a set of states, $Q_k$ the colony size of a generalized
Turing machine $M_k$, and
let $\phi_k$
be a code on configurations that is
defined by a block code
  \begin{align*}
       \psi_k: \Sigma_{k+1}\times(\Gamma_{k+1}\cup\{\emptyset\})
       \rightarrow \Sigma_k^{Q_k}.
  \end{align*}

  The triple $(\Sigma_k,\Gamma_k,  \phi_k)$, ($k\geq 1)$,  is
  called a \df{hierarchical code}.

For a configuration $\xi$, we define $\xi^k$ recursively as
follows
\begin{equation}\label{eq:hierarchical-config}
\begin{aligned}
  &\xi^1 = \xi, \\
  &\xi^{k + 1} = \phi_k^*(\xi^k).
\end{aligned}
\end{equation}

For the given hierarchical code, the configuration
$\xi$ is called a \df{code configuration} if
for every $k>0$, $\xi^k$ is a code configuration for the code
$(\Sigma_k,\Gamma_k,  \phi_k)$.%, for each $k$.
\end{definition}


Let us give a name to the object that we want to construct.

\begin{definition}[A tower]\label{def:tower}
    Let $M_1$, $M_2$, \dots, be a sequence of generalized Turing machines,
    and let $(\varphi_{1*},\Phi_1^{*})$,
            $(\varphi_{2*},\Phi_2^{*})$,
    \dots, be a sequence of simulations such that
    $M_i$ simulates $M_{i+1}$ using $(\varphi_{i*},\Phi_i^{*})$.
    We require that for every $i>0$,
    $\varphi_{i*}(\xi_{i+1})$
    is an initial code configuration
    of $M_i$, where $\xi_{i+1}$ is an
    initial code configuration
    of $M_{i+1}$.
    A pair of such sequences is called a \df{tower}.
\end{definition}


\begin{figure}[h]
\centering
\includegraphics[width=4in]{hpics/tower.pdf}
\caption[The blueprint of the tower]{
    A tower of simulations and the ``side-simulation'' of
    a customer's machine $G$
\label{fig:tower}}
\end{figure}







\section{The Noise}\label{sec:noise}

Let $\vek{r}=(r_1, r_2)$, $r_1, r_2\geq 0$,
be a radius vector.
A \df{ball} centered at $\vek{x}$
of radius $\vek{r}$ (it is actually a rectangle) is
\begin{align}\label{eq:ball1}
  B(\vek{x},\vek{r}) = \setOf{\vek{y}}{|y_i - x_i| \leq r_i, i=1,2}.
\end{align}

%Let \( P =(P_1, P_2) \) be a vector, $P_1, P_2>0$.
%Then we define the following metric function
%\begin{align}\label{eq:dP}
%  d_{P}(\vek{x},\vek{y}) =\max{|x_{1}-y_{1}|/P_{1},|x_{2}-y_{2}|/P_{2}}.
%\end{align}
%To measure the distance between two vectors,
%we define the following metric function
% $d_P(\vek{x}, \vek{y})$:
%for two points $\vek{x}=(x_1, x_2)$ and $\vek{y}=(y_1, y_2)$, and
%$a_1, a_2\geq 0$,
%$d_P(\vek{x}, \vek{y}) = (a_1, a_2)$ if and only if
%$|y_i - x_i| \leq a_i, i=1,2$.

A point $\vek{x}$ is \df{$(\vek{r},\vek{r}^*)$-isolated}
from $\Noise$ if
$$(B(\vek{x},\vek{r}^*)\setminus B(\vek{x}, \vek{r}))\cap \Noise = \emptyset.$$

Let
\begin{align}
  D(\Noise,\vek{r}, \vek{r}^*) =
     \setOf{\vek{x}}{\vek{x} \txt{ is not } (\vek{r}, \vek{r}^*)\txt{-isolated
  from } \Noise}.
\end{align}

\begin{definition}[Sparsity]
Let $\Noise^{(1)} = \Noise$,
%We obtain $\Noise^{(2)}$ from $\Noise^{(1)}$ by
%deleting
Then, for $k>1$,
\begin{align}\label{eq:noise^k}
    \Noise^{(k+1)} = D(\Noise^{(k)}, \beta(\B_k, \Tu{k}), (\B_{k+1}, \Tu{k+1})).
\end{align}

Set $\Noise^{(k)}$ is called the \df{$k$-noise set}
of $\Noise$.

Set $\Noise$ is \df{$(\vek{r}, \vek{r}^*)$-sparse}
if $D(\Noise, \vek{r}, \vek{r}^*)=\emptyset$.
It consists of $(\vek{r}, \vek{r^*})$-isolated points.

It is \( k \)-\df{sparse} if $\Noise^{(k+1)}=\emptyset$.
It is \df{sparse} if \( \bigcap_{k}\Noise^{(k)}=\emptyset \).
\end{definition}





\subsection{From bursts to random faults}


%In the following lemma, we give
%The following lemma gives the conditions that the sequence
%of  $\{(\beta_i, V_i)\}_{i>0}$
%must satisfy.

Let $\beta \geq 9$.



\begin{lemma}[Sparsity]\label{lem:sparsiness}
Let $[Q_i]_{i>0}$ be a non-decreasing sequence
of positive integers,
and let $[\Tu{i}]_{i>0}$ be an increasing sequence
of positive integers
such that %\( \log\beta\le \log\frac{\rho_{k+1}}{\rho_{k}}\ll 1.5^{k} \).
\begin{align}\label{eq:assumption}
  \lim_{k\rightarrow\infty}\frac{\log(\U_{k} Q_k)}{1.5^k}=0,
\end{align}
where $\U_k = \Tu{k+1}/\Tu{k}$.
Let $\B_k = Q_{k-1} \B_{k-1}$.

For sufficiently small \( \varepsilon \),
for every \( k\ge 1 \) the following holds.

Let
\begin{align*}
    \Noise = \Noise_\varepsilon\subseteq \bbZ\times \bbZ_{\geq 0}
\end{align*}
be a random set
where each element $(p,t)$ belongs to it independently
from the other ones with some probability $\leq \varepsilon$.



Then for each point $\vek{x}$  and each \( k \),
 \begin{align*}
   \Pr\set{B(\vek{x},(\B_k, \U_{k}))\cap \Noise^{(k)}\neq\emptyset}
     <2\varepsilon \cdot 2^{-1.5^{k}}.
 \end{align*}

\end{lemma}

\begin{proof}

Let \( k=1 \).
Rectangle \( B(\vek{x},(\B_1, \Tu{1})) \) is a single point, hence
the probability of our event is $<\varepsilon$.
(It follows that with probability 1, the set \( \Noise \) is sparse.)

Our event
 depends at most on the
rectangle \( B(\vek{x},3(\B_{k}, \Tu{k})) \).
Let us prove it, by induction, for \( k+1 \).
Let
\begin{align}\label{eq:pk}
   p_{k}=2\varepsilon\cdot 2^{-1.5^{k}}.
\end{align}

Suppose \( \vek{y} \in\Noise^{(k)}\cap B(\vek{x},(\B_{k+1}, \Tu{k+1})  ) \).
Then, according to the definition of $\Noise^{(k)}$,  there is a point
\begin{align}\label{eq:sparse-as}
 \vek{z} \in
 B(\vek{y},\Tu{k+1})\cap\Noise^{(k)}\setminus B(\vek{y},\beta(\B_{k}, \Tu{k})).
 \end{align}
Consider a standard partition of the (two-dimensional) space-time into
rectangles \( K_{p}=\vek{c}_{p}+[-\B_{k}, \B_k)\times [-\Tu{k}, \Tu{k}) \)
with centers \( \vek{c}_{1},\vek{c}_{2},\dots \).
The rectangles \( K_{i},K_{j} \) containing \( \vek{y} \) and \( \vek{z} \)
respectively
intersect \( B(\vek{x}, 2(\B_{k+1}, \Tu{k+1}) \).
The triple-size rectangles \( K'_{i}=c_{i} + [-3\B_{k}, 3\B_k)\times [-3\Tu{k}, 3\Tu{k}) \) and
\( K'_{j} \) are disjoint, since by~\eqref{eq:sparse-as}
 \( |y_1 - z_1|>\beta\B_{k} \)
and \( |y_2 - z_2|>\beta\Tu{k} \).

The set \( \Noise^{(k)} \) must intersect two rectangles \( K_{i} \),
\( K_{j} \) of size \( 2(\B_{k}, \Tu{k}) \)
separated by at least \( 4(\B_{k}, \Tu{k}) \),
of \( B(\vek{x},2(\B_{k+1}, \Tu{k+1})) \).

By the inductive hypothesis, the event \( \cF_{i} \) that
\( K_{i} \) intersects \( \Noise_{k} \) has probability bound \( p_{k} \).
It is independent of the event \( \cF_{j} \), since these events depend
only on the triple size disjoint rectangles \( K'_{i} \) and \( K'_{j} \).

The probability that both of these events hold is at most \( p_{k}^{2} \).
The number of possible rectangles
\( K_{p} \) intersecting \( B(\vek{x},2(\B_{k+1}, \Tu{k+1})) \) is
at most
\( C_{k}:=((2\U_{k} Q_{k})+2)^{2} \), so
the number of possible pairs of rectangles
is at most \( C_{k}^{2}/2 \), bounding the
probability of our event by
 \begin{align*}
   C_{k}^{2}p_{k}^{2}/2.
 \end{align*}
From here, using~\eqref{eq:pk} we have
 \begin{align*}
   C_{k}^{2}p_{k}^{2}/2
    &=
      2 C_{k}^{2}\varepsilon^{2} 2^{-1.5^{k+1}}\cdot 2^{-0.5\cdot 1.5^{k}}
   \\ &=2\varepsilon 2^{-1.5^{k+1}} \cdot \varepsilon
        C_{k}^{2}2^{-0.5\cdot 1.5^{k}}.
 \end{align*}
Since $\frac{\log{\U_{k} Q_k}}{1.5^k}$ tends to $0$ as $k\rightarrow \infty$,
the last factor
is \( \le 1 \) for sufficiently small  \( \varepsilon \).
\end{proof}




%
%\begin{proposition}[See \cite{DurShenRomTil}]\label{lem:sparsiness}
%  If for every $j$,
%  $12\sum_{i < j} V_i < \beta_{j} \leq V_{j}$
%  and $\sum_{i}{\frac{\log{V_i}}{3^i}}<\infty$,
%  then,
%  for every sufficiently small $\varepsilon>0$,
%  for every $x \in \bbZ_{\geq 0}$, and every $k>0$,
%  \begin{align}\label{eq:Prob-F}
%       \Pr\left[\exists y \text{ s.t. } |x - y| \leq V_{k}
%        \text{ and }
%        y \in \Noise^{(k)}\right]
%        < O(V_k)\varepsilon^{3^{k}}\cdot 2^{O(3^{k})}.
% \end{align}
%\end{proposition}
%\begin{proof}
%  Let us first estimate the probability that an arbitrary
%  chosen $x$ belongs
%  to  $\Noise^{(k)}$.
%
%  If $ x \in \Noise^{(k)}$, then
%  $x_0 = x \in \Noise^{(k-1)}$
%  and it does not belong to any $(\beta_{k}, V_{k})$-bi-burst
%  (otherwise it would have been removed).
%
%  Consider a $\beta_k/2$-neighborhood $I_1$ of $x$ in $\Noise$.
%  If $I_1$ were a burst, then it should not be there.
%  Hence, there is some $x_1$ that is in a $V_k$-neighborhood
%  of $I_1$ and not in $I_1$ itself.
%
%  Consider a $\beta_k/2$-neighborhood $I_2$ of $x_1$ in $\Noise$.
%  The lengths of $I_1$ and $I_2$ do not exceed $\beta_k$
%  and they are $V_k$ apart.
%  However, $I_1$ and $I_2$ cannot form a bi-burst since otherwise
%  they should have been removed.
%  So the only reason why these two sets remain
%  is that some $x_2\in\Noise^{(k-1)}$ that is not in $I_1\cup I_2$ is in
%  its $V_k$-neighborhood of this union.
%  Therefore, there exists $x_1, x_2 \in \Noise^{(k)}$
%  such that
%  \begin{align*}
%     \beta_{k}/2 < |x - x_1|, |x - x_2|, |x_1 - x_2| \leq
%    2\beta_{k}/2 + 2V_{k} < 3V_{k}.
%  \end{align*}
%
%  We continue with this process further: since for every
%  $i\in\set{0,1,2}$, $x_i\in\Noise^{(k-1)}$,
%  then for every $i$, there exist
%   $x_{i1}$, $x_{i2}$,
%   such that
%   $x_{i0}, x_{i1}, x_{i2}\in \Noise^{(k-2)}$,
%   where $x_{i0} = x_i$ and
%   \begin{align*}
%       \beta_{k-1}/2 < |x_i - x_{i1}|, |x_i - x_{i2}|, |x_{i1} - x_{i2}| \leq
%    2\beta_{k-1}/2 + 2V_{k-1} < 3V_{k-1}.
%   \end{align*}
%
%
%  We continue with this process until we reach the ground level.
%  The above process describes a ``lineage tree'', which essentially
%  serves as a certificate showing why $x \in \Noise^{k}$.
%  Diameters of the subtrees rooted at $x_0$ and $x_1$
%  (\ie the largest paths in them)
%  describe
%  the distance between the farthest points, that is,
%  estimated size of the bi-bursts containing these points.
%  These diameters are
%      $\leq 3V_{k} + 3V_{k-2} + 3V_{k-3} + \dots + 3V_1$.
%  Lemma's first condition guarantees that the
%  intervals spanned by these two
%  subtrees do not intersect each other.
%
%  Our tree has $3^{k}$ leaves that
%  belong to $\Noise_\varepsilon$.
%  Since every $x \in \Noise_\varepsilon$ occurs
%  with equal probability, our tree is a ``valid'' certificate
%  (\ie the nodes denote faulty times) with
%  probability at most $\varepsilon^{3^{k}}$.
%
%  Now, we estimate the number of such trees for
%  a given $x$ and $k$.
%  To specify $x_1$ and $x_2$, we need to specify their distances
%  from $x_0$ and on which of its sides it is positioned.
%  Since their distances do not exceed $3V_{k}$, for
%  this specification
%  we need $4\log{(6V_{k})}$ bits.
%  Similarly, to specify $x_{01}$ and $x_{02}$ relative
%  to $x_{00}$,  and $x_{11}$ and $x_{12}$ relative to $x_{10}$,
%  and $x_{21}$ and $x_{22}$ relative to $x_{20}$,
%  we need no more than
%  $6\cdot 2\log{(6V_{k-1})}$ bits, and so on.
%  For the whole tree we need no more than
%  \begin{align*}
%           &4\log{(6V_{k})} + 12\log{(6 V_{k-1})}
%           +  \dots
%           +  4\cdot 3^{k-1}\log{(6V_{1})} \\
%           &= 4\cdot 3^k \left(\log{(6V_{1})} + 1/3 \log{(6V_{2})} + \cdots + 1/3^{k-1} \log{(6V_{k-1})}  \right)
%  \end{align*}
%  bits.
%  Due to the second condition of the Lemma,
%  the sum
%    $\log{(6V_{1})} + 1/3 \log{(6V_{2})} + \cdots + 1/3^{k-1} \log{(6V_{k-1})} $
%  converges to some constant, therefore
%  we need a sequence of $O(3^k)$ bits to describe such a tree.
%  There are at most $2^{O(3^{k})}$ binary sequences of length
%  $O(3^{k})$.
%  Therefore, there are at most
%  $2^{O(3^{k})}$ such trees.
%
%  The probability
%  that $x \in \Noise^{(k)}$
%  is bounded by $\varepsilon^{3^{k}} 2^{O(3^{k})}$.
%  This probability converges to 0 for small $\varepsilon$.
%
%  Now, we need to compute
%  \begin{align}\label{eq:prob-burst}
%      \Pr\left[\exists y \text{ s.t. } |x - y| \leq V_{k}
%        \text{ and }
%        y \in \Noise^{(k)}\right],
%  \end{align}
%  for any $k$ and $x$.
%
%  Since for a given $x$, we can choose
%  $V_k$ points $y$ such that
%  $|x - y| \leq V_{k}$, the desired
%  probability is at most
%  \begin{align*}
%        O(V_{k})\cdot \varepsilon^{3^{k}} 2^{O(3^{k})}%
%%         =  3 ^{\log{V_k} + \log{\varepsilon \cdot 2^{k}} + O(2^{k})},
%  \end{align*}
%  which converges to $0$ for small $\varepsilon$,
%  because according to the second condition of our lemma,
%  $\log{V_k} \ll 3^k$.
%\end{proof}

\begin{definition}[$\Noise$ and $\Noise^*$]\label{rem:noise-and-noise*}
    Following the spirit of the notation stemming from
    the notation of a code and the layout of the tower,
    where,  $\varphi_*$ stands
    for the encoding and $\varphi^*$ for decoding,
    whenever possible we will avoid the indexes denoting
    the noise, machines, and trajectories.
    For example, when considering machines  $M_i$ and $M_{i+1}$,
    we will usually drop the index $i$ and instead
    we will refer to these machines as $M$ and $M^*$ respectively.
    We will do the same for their histories and their trajectories.
%    Therefore, whenever we write $\Noise^*$, we mean the
%    set obtained from $\Noise$ when all the $(\beta, V)$-bi-bursts
%    are removed from it.
\end{definition}




\section{The trajectory lemma}


Later on, we will explicitly define a tower and its
corresponding sequence of simulations
\begin{align*}
    \sS = \left[(\varphi_{i*},\Phi_i^{*})\right]_{i\geq 1}.
\end{align*}


The main difficulties of this work are concentrated in
establishing of the following lemma.

\begin{lemma}[Trajectory]\label{lem:trajectory}

  For any $i \geq 1$,
  if
    $(\eta, \Noise^{(i)})$ is a trajectory
    of $M_i$, then
    $(\Phi^{*}(\eta), \Noise^{(i+1)})$ is
    a trajectory of machine $M_{i+1}$.

%  In short,
%  any trajectory $(\eta, \Noise)$ of $M$,
%  $(\eta^*, \Noise^*)$ is a trajectory of $M^*$.
\end{lemma}

\section{Outline}

This dissertation is organized as follows.
Chapter~\ref{sec:blueprint} presents the outline of the simulation.
The two recovery mechanisms are Chapter~\ref{ch:recovery}.
In Chapter~\ref{sec:1-level-noise} we outline how
machine $M$, whose trajectory is $(\eta, \Noise)$,
copes with isolated bursts, provided that no $\Noise^*$
occurs.
This chapter is based on the work~\cite{Bursts}, with a
small difference that in the present work, the cell structure in small
``islands'' of the tape may not exist at all.
The proof of the Main Theorem is given in
Chapter~\ref{ch:proof-main-thm}.
Finally, Chapter~\ref{sec:larger-damage} is devoted to
the proof of Lemma~\ref{lem:trajectory}.

As stated at the beginning of this chapter,
parts of chapters~\ref{ch:recovery}, \ref{ch:proof-main-thm}, and
\ref{sec:larger-damage}, will be subjected to changes.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{The Simulation}\label{sec:blueprint}

In this chapter, we present the blueprint of a generalized Turing machine
\begin{align*}
M = \left(\Gamma, \Sigma, \delta, q_{\start}, F, \B,  \Tu{}\right)
\end{align*}
that simulates any generalized Turing machine $M^*$. %, even if
%during its operation
%bursts of faults of length at most $\beta$, separated
%by at least $V$ fault free steps, may occur.


\section{Universal Turing machine}\label{sec:UTM}

We will describe our construction in terms of
universal Turing machines,
operating on binary strings as inputs and outputs.
For this reason, we must introduce a way how
to encode a program of a machine to a universal Turing machine.


\begin{definition}[Standard pairing]
    For every alphabet $\Sigma$ that we will consider, we
    assume that there is a standard ordering of its
    elements: $\Sigma=\{s_{1},\dots,s_{n}\}$.
    This gives rise to a code
     \begin{align*}
    (\gamma_{*},\gamma^{*}),
     \end{align*}
    where $\gamma_{*}(s_{i})$ is the base 2 notation
    of the number $i$, padded
    from the front to length $\cei{\log n}$.
    For example, if $\Sigma=(s_{1},s_{2},s_{3})$
    then the codewords are $01,10,11$.

    For binary string $x=x(1)\dotsm x(n)$ let us introduce the map
     \begin{align*}
       x^{o} = x(1)x(1)x(2)x(2)\dotsm x(n)x(n)01.
     \end{align*}
    If $s$ is a symbol in some alphabet $\Sigma$ then
    by $\ang{s}$ we will understand
    $(\gamma_{*}(s))^{o}$, and call it the
    \df{standard prefix-free code} of $s$.
    Similarly,
     \begin{align*}
            \ang{s,t} &=\Paren{(\gamma_{*}(s))^{o}\gamma_{*}(t)}^{o},
    \\ \ang{s,t,u} &= \ang{s,\ang{t,u}},
     \end{align*}
    and so on.
\end{definition}

We have $|x^{o}|=2|x|+2$.
A shorter code with the same prefix-free property
could be defined as $z^{o}x$, where $z$ is the
binary notation of $|x|$.
But minimizing the code length is not our concern here.


\begin{definition}[Universal Turing machine]\label{def:univ-TM}
     We say that Turing machine $U$ is \df{universal}
     among Turing machines with
     binary inputs and outputs, if for every Turing machine $M$,
     for all binary strings $x$, there is a binary string $p_{M}$
     such that $M$ reaches a final state on input $x$
     if and only if $U$ reaches a final state on input $\ang{p_{M}}x$,
     further in this case we have $U(\ang{p_{M}}x)=M(x)$.
     A universal Turing machine is will be called \df{flexible}
     if whenever $U(\ang{p,q}x)$ halts, also $U(\ang{p}q)$ halts, and
      $U(\ang{p,q}x)=U(U(\ang{p}q)x)$.
     In other words  if a program has the form $\ang{p,q}$ then $U$
     first applies as a preprocessing step the program $p$ to $q$,
     and then it starts work on the result attached in front of $x$.

     It is well-known that there are flexible universal Turing machines.
     Let us fix one and call it
     \begin{align*}\Un.\end{align*}

     Consider an arbitrary Turing machine $M$ with
     state set $\Gamma$, alphabet $\Sigma$, and transition
     function $\delta$.
     A binary string $p$ will be called a
     \df{transition program} of $M$ if
     whenever $\delta(a,q)=(a',q',j)$ we have
     \begin{align*}
          \Un(\ang{p}\ang{a,q})=\ang{a',q',j}.
     \end{align*}
     We will also require that the computation
     induced by the program makes
    $O(|p|+|a|+|q|)$ left-right turns.
\end{definition}

The transition program just provides a way to
compute the transition function of
$M$ by the universal machine,
it does not restrict the
Turing machines that can be simulated this way,
since for every transition
function there is some program computing it with
these restrictions (maybe
just by table look-up).




\begin{remark}[The universal interpreter]\label{rem:interpreter}
In the construction provided by the textbooks,
the program is generally a string
encoding a table for the transition function
$\delta$ of the simulated machine
$M$.
Other types of program are imaginable:
some simple transition functions can
have much simpler programs.
However, our fixed machine is good enough:
if some machine $U'$ simulates $M$ via a
very simple program $q$, then
our $\Un$ will simulate $M$ via program
$\ang{r,p_{U'},q}(=\ang{r,\ang{p_{U'},q}})$,
where the fixed program $r$ is such that
$\Un(\ang{r}\ang{x,y})=\ang{x}\ang{y}$.
Now
 \begin{align*}
     \Un(\ang{r,p_{U'},q}x)=\Un(\ang{p_{U'}}\ang{q}x)=
       U'(\ang{q}x) = M(x).
 \end{align*}
\end{remark}


\subsection{Rule language}\label{sec:language}

Instead of writing a single huge transition table,
we present the transition
function as a set of \df{rules} for our universal
interpreter $\Un$.

Each rule consists of some conditional statements,
similar to the ones seen in
an ordinary program:
 ``{\bf if }{\em condition} {\bf then} {\em statement}'', where the condition
is testing values of some fields of the state and the observed cell, and
the statement  can be an \df{assignment} of a value to a field
of the state or cell symbol, or a command to move the head.
Rules can call other rules, but these calls will never form a cycle.
Calling other rules is just a shorthand for nested conditions of this
type.

Even though rules are written like procedures of a program,
they describe a single transition.
When several consecutive statements are given, then they
(almost always) change different fields of the state or
cell symbol, so they can be executed simultaneously.
Otherwise and in general, even if a field is updated in
some previous statement, in all following statements that use
this field, its old value is considered.

Assignment of value $x$ to a field $y$ of the state or cell symbol will
be denoted by $y \gets x$.
We will also use some conventions introduced by the C language:
namely,
$x\gets x+1$ and $x\gets x-1$ are abbreviated to $\increment{x}$ and
$\decrement{x}$ respectively.

Rules can also have parameters, like $\ruSwing(a,b,u,v)$.
Since each rule is called only a constant number of times in the whole program,
the parametrized rule can be simply seen as a shorthand.

Though many times for clarity purpose we will describe
the rules using plain English, we assume that a reader
can always write all the rules using these language
conventions.

Later, we will add some additional features to this language.



\section{The fields}\label{sec:fields}

Recall from Definition~\ref{def:gen-TM} of
a generalized Turing machine that
each state of $M$ and each state of a cell is a tuple,
$q=(q_{1},q_{2},\dots,q_{k})$,
whose individual elements
are called \df{fields} and
have symbolic names.
Recall also that we the prefix $\fld{c.}$
to distinguish between the fields of a state and the
fields of a cell
(like $\cSweep$).


We will call the direction ($-1$ for left, 0 for none,
and $+1$ for right)
of the simulated machine the \df{drift}.

The tape of the simulating machine is split into blocks of
$Q$ consecutive cells of size $\B$,
called \df{colonies}.
For this reason, each cell has a specific $\cAddr$
field, that stores the address of the cell within
the colony.
In order to keep track of the position of the head
within a colony, we use the field $\Addr$ of the
state.

The head will make some global sweeping movements
over a colony.
We will count the sweeps using the field $\Sweep$ of the state.
We will use the term \df{sweep direction} of the
machine when referring to the direction of the
simulating machine in this sweeping movement.

One step of a typical Turing machine consists of
the following operations.
 \begin{enumerate}
   \item\label{i:TM-ops-reading}
        Reading of the content of the current cell.
   \item\label{i:TM-ops-computing}
         Computing of the new value of the current cell, of the
         new state and of the drift from transition function
         based on the
         content that was read on the current cell
         and based on the current
         state.
   \item \label{i:TM-ops-update-cell}Writing of the new content on
         the current cell.
   \item \label{i:TM-ops-update-state}Updating of the state.
   \item \label{i:TM-ops-move}Moving of the head according to the drift.
 \end{enumerate}
We will show how machine $M$
performs each of these operations.
The content of a cell of $M$ and its state, will be
encoded in the cells of the corresponding colony.
Hence, to perform the last task, the global
sweeping movement must encompass the neighbor colony
if the drift is nonzero, since the state of the simulated
machine must be transferred to the colony that
corresponds to the next cell of the simulated machine.



The array of values of the same field of the cells will be
called a \df{track}.
The most basic fields of the state and of cells are listed below.
Later we will introduce other fields.
We emphasize that each field of a cell has also a possible value
$\emptyset$ corresponding to the case when the state is blank.


\begin{enumerate}
    \item
    Fields $\Addr$ and $\cAddr$ range from $-Q$ to $2Q-1$.
    The values $-Q$ to $-1$ are taken during the left drift,
    while the values $Q$ to $2Q-1$ during a right drift.
    During the first sweep of the work period, $\Addr$ is
    reduced modulo $Q$.

%    (Later, we will extend the range of $\Addr$ and $\cAddr$.

%    Its counterpart on the tape $\cAddr$ ranges from $0$ to $Q-1$.
%    To identify uniquely the position, each cell has
%    a $\cKind_1$ field that takes value in $\{\Bridge, \Neighbor_1, \Neighbor_2\}$.

    \item $\Drift$ stores the direction of the simulated machine.
    It may have values $\emptyset,-1,0,1$.
    The value $\emptyset$ corresponds to the case when
    the new $\Drift$ is still not computed, and will
    also be the default value (for example in vacant cells).

    \item $\Dir$ stores the direction of the previous step.

    \item Field $\Sweep$ numbers the sweeps through the colony.
    The first right sweep has number 1, and this way each
    right sweep is odd, each left sweep is even, thus the
    sweep direction of the head is completely determined by
    the parity of $\Sweep$ when the head is not on the
    ``turning'' points.
    In the turning points, $\Sweep$ is incremented.

    Field $\cSweep$ holds the number of the most recent sweep
    of the colony.
    The turning points will depend on the value of $\Sweep$.
    Sometimes, while sweeping, the head steps outside of the
    colony.
    In this case,
    the $\Sweep$ will be stored in the $\cVisSw$.


    \item The $\Info$ track of a colony stores
    information of the cell it is simulating.
    The $\State$ track of a colony stores the
    current state of the machine it is simulating.

    \item $\Prog$ track in a colony stores the
      program of the simulated machine.

    \item\label{i:fields.kind}
     $\cKind$ is a special field of a cell that takes values
       from the set
       \begin{align}\label{eq:kind-domain}
          \Upsilon=\{\Member, \Neighbor, \Bridge, \Stem, \Vacant \}.
       \end{align}
%

%     A cell is \df{empty} if at least $\cAddr$ and $\cSweep$ are empty.
%     or $\cKind = \Vacant$.


    \item     We define
    \begin{align}
       \Core=(\Addr, \Sweep, \Drift, \Kind)
    \end{align}
        and
    \begin{align}
        \cCore=(\cAddr, \cSweep, \cDrift, \cKind, \cVisSw).
    \end{align}
%    where $\cKind\in\{\Vacant, \Bridge, \Neighbor, \emptyset, \Stem\}$.



    \item $\Af$ field of a cell will be set to true if
    this cell belongs to a colony that ``represents'' a cell
    that wants to become ``vacant''.
    (We will explain  this notion later.)


    \item The $\Mode$ field of the head
        takes values in $\{\Normal,\Recovering, \Healing\}$.
        In the absence of faults, the state would never
         leave the normal mode.
        On noticing any disorder, the state will switch
        to recovery mode, with the goal of eventually
        returning to normal mode.
        The simulation is carried out while in the normal mode.

    The fields used in recovery mode are all
    collected as subfields of the field
    $\Rec$ of the state, and the field $\cRec$ of the cell state.
    They will be introduced in the definition of the recovery rule.

    In particular, when the field
     \begin{align}\label{eq:cRecCore}
      \cRec.\Core
     \end{align}
    is not $0$, we will call the cell \df{marked for recovery}.

    Similarly, the fields used in rebuild mode are all
    gathered as subfields of the field $\Arb$ of the state,
    and the field $\cArb$ of the cell state.
    We will use them in the definition of the rebuild rule.

    Finally, when the field
    In particular, when the field
     \begin{align}\label{eq:cArbCore}
      \cArb.\Core
     \end{align}
    is not $0$, we will call the cell \df{marked for rebuild}.

    \item\label{i:fields.zigging}
    The sweep-through is interrupted by switchbacks
    called \df{zigging}.
    While in the normal mode, the process depends
    on two fixed parameters
    \begin{equation}\label{eq:Z}
     \begin{aligned}
      &\Z \\
      &\Z_b, \;\;\; \Z_b<\Z,
     \end{aligned}
     \end{equation}
    that we will define later.
%    where $\beta$ is the bound on the size of bursts.
    This process is controlled by the fields $\ZigDepth$ and $\ZigDir$.

    We assume that $Q$ is a multiple of $\Z - \Z_b$, that is
    \begin{align}\label{eq:constraint-on-Z}
        \Z - \Z_b \; | \; Q.
    \end{align}
    Every $\Z-\Z_b$ forward steps are accompanied by $\Z$ steps
    backward and forward, for a total of  $3\Z-\Z_b$
    steps.

\end{enumerate}

For a moment, assume that the simulation structure
of $M$ is restored and the mode of the machine
is $\Normal$.

The colony that corresponds to the current cell of the
simulated machine is
called the \df{base colony}.
%The cells of the base colony have $\cKind = \Member$.
Later, we will give a more precise definition that
does not depend on what machine is simulating.

Once the drift is known, the union of the base colony
with the neighbor colony in the direction of the drift
is called the \df{extended base colony}.

Our machine does not have final states,
since a fault could terminate the entire computation.

%For some $D>0$,
One  step of the simulated machine is simulated by
\begin{align}\label{eq:U}
\U %= DQ^2
\end{align}
steps of
$M$ that will consist one unit called \df{work period}.

Let
\begin{align}\label{eq:Last}
   \Last(d)
\end{align}
be the number of the last sweep of period
whose drift is $d$.
%This constant will be defined
%in~\eqref{eq:Last}.






\section{Coding}

Recall the notion of code given in Definition~\ref{def:codes}.

\begin{definition}[Error-correcting code]\label{def:err-code}
     A block code is $(\beta,t)$-\df{burst-error-correcting},
     if for all $x\in\Sigma_{2}$, $y\in\Sigma_{1}^{Q}$ we
     have $\psi^{*}(y)=x$ whenever $y$ differs from
     $\psi_{*}(x)$ in at most $t$ intervals of size $\le\beta$.
\end{definition}

\begin{example}[Repetition code]\label{xmp:tripling}
  Suppose that $Q\ge 3\beta$ is divisible by 3,
  $\Sigma_{2}=\Sigma_{1}^{Q/3}$, $\psi_{*}(x)=xxx$.
  Let $\psi^{*}(y)$ be obtained as follows.
  If $y=y(1)\dots y(Q)$, then $x=\psi^{*}(y)$ is defined as follows:
    $x(i)=\maj(y(i),y(i+Q/3),y+2Q/3)$.
    For all $\beta\le Q/3$, this is a
    $(\beta,1)$-burst-error-correcting code.

    If we repeat 5 times instead of 3, we get a $(\beta,2)$-burst-error-correcting
    code. %(there are also much more efficient such codes than just repetition).
 \end{example}


As we will be using the repetition frequently,
we need to define the notion of the majority.

    \begin{definition}[Majority]\label{def:majority}
        Let $x=(x_{1},\dots,x_{n})$ be a sequence of symbols
        from a finite alphabet $\Sigma=\{a_{1}, a_{2},\dots, a_{m}\}$.
        For each $j=1,2,\dots,m$, let  $k_{j}$ be the number of
        occurrences of $a_{j}$ in $x$, $k_{1} + k_{2} + \dots + k_{m} = n$.
        Then,
            \begin{align*}
                 \maj(x_{1},x_{2},\dots,x_{n}) = a_{k},
            \end{align*}
        where  $k = \arg\max_{j}{k_{j}}$.
    \end{definition}

    In the Section~\ref{sec:majority}, we will show how to compute
    a majority of values in a sequence of cells using only one
    pass over the sequence.



\subsection{A way to encode a cell and state of a Turing machine}
\label{sec:coding}



Recall the notion of a code on configurations given
in the Definition~\ref{def:configuration-code}.
Let us specify such a code $(\phi_*, \phi^*)$.

Let us assume that generalized Turing machine
\begin{align*}
    M = \left(\Gamma, \Sigma, \delta, q_{\start}, F, \B,  \Tu{}\right)
\end{align*}
simulates generalized Turing machine
\begin{align*}
M^* =
\left(\Gamma^*, \Sigma^*, \delta^*, q_{\start}^*, F*^, \B^*,  \Tus\right).
\end{align*}


Let
\begin{align}\label{eq:penLen}
    \PenetrationLen
\end{align}
be  a constant to be defined later.



For simplicity, let us assume that
$\Gamma^*\cup\set{\emptyset}$,
and the alphabet $\Sigma^*$ are subsets of the set of  binary strings
$\{0,1\}^{\ell}$ for some $\ell<Q$ (we can always ignore some states or tape
symbols, if we want).
%We will then use the same code $(\upsilon_{*},\upsilon^{*})$
%for both the states of machine $M^*$ and its alphabet.
Let $(\upsilon_{*}, \upsilon^{*})$ be a % systematic
$(\beta,2)$-burst-error-correcting block code
\begin{align*}
  \upsilon_{*}: \{0,1\}^{\ell} \cup \set{\emptyset}
   \to\{0,1\}^{(Q-2\PenetrationLen)\B}.
\end{align*}
(The length of the code is not $Q$, only $(Q-2\PenetrationLen)\B$,
since we will place the
codeword at a distance $\PenetrationLen\B$ from both colony ends.)

We could use, for example, the repetition code of Example~\ref{xmp:tripling}.
Other codes are also appropriate, but we require that they have some fixed,
constant programs $p_{\encode}$, $p_{\decode}$
on the universal machine $\Un$, in the following sense:
 \begin{align*}
   \upsilon_{*}(x)=\Un(\ang{p_{\encode}}x),\quad
   \upsilon^{*}(y)=\Un(\ang{p_{\decode}}y).
 \end{align*}
Also, these programs must work in quadratic time and
linear space on a one-tape
Turing machine (as the repetition code certainly does).

For any bit string $b$ and $a,b\in\bbZ{\geq 0}$,
we define the \df{bit padding function}
\begin{align}\label{eq:padding}
   \bpad(s,a,b) = 0^a s 0^b,
\end{align}
that prepends $a$ zeros to it, and appends
$b$ zeroes to it.

Let us now define the block code $(\psi_*, \psi^*)$,
and the corresponding  code on configurations $(\phi_*, \phi^*)$.

Let $\xi$ be an initial configuration of $M^*$, and
let $s$ be its state.

%starting
%state $q_{\start}^*$.

The encoding of the block code $\psi_*$  is defined as follows:
\begin{equation}\label{eq:psi}
\begin{aligned}
   \psi_*(\xi.\tape[i], s) & = \bpad(\upsilon_{*}(\xi.\tape[i]), \PenetrationLen,\PenetrationLen,),
\\ \psi_*(\xi.\tape[i], s) & =
   \bpad(\upsilon_{*}(\emptyset), \PenetrationLen,\PenetrationLen,), \txt{ if } i\neq \xi.\pos \\
   \psi_*(\xi.\tape[i], s) & = \bpad(\upsilon_{*}(s), \PenetrationLen,\PenetrationLen),
   \txt{ if } i = \xi.\pos .
\end{aligned}
\end{equation}

In cells of the base colony
and its left neighbor  colony,
the $\cSweep$ and $\cDrift$ fields are set
to $\Last(+1)-1$,  $1$, and $\Last(+1)$,  $1$,
respectively.
In the right neighbor colony,
these values are $\Last(-1)$ and $-1$
respectively.
In all other cells, these values are empty.
We assume that the $\cAddr$
fields of each colony are filled properly:
the $\cAddr$ of the $j\tth$ cell of a colony
is $j \bmod \B^*$.
The $\cHold$ values are empty in each cell.
All other fields have also their initial (or empty)
values.

The corresponding decoding function
$\psi^{*}$ is obtained by applying the decoding
function $\upsilon^{*}$ to
$\cInfo$ and $\State$ tracks between addresses $\PenetrationLen\B$
and $Q-\PenetrationLen\B$
of $M$.


To encode configuration $\xi$ to $M$, we
use the corresponding code on configurations as follows.
For the tape we set
\begin{equation}\label{eq:init}
\begin{aligned}
   \phi_*(\xi).\tape[i\B^*,\dots,(i+1)\B^* - \B].\Info   & = \upsilon_{*}(\xi.\tape[i]),
\\ \phi_*(\xi).\tape[i\B^*,\dots, (i+1)\B^*-\B].\State  & =
   \upsilon_{*}(\emptyset), \txt{ if } i\neq \xi.\pos \\
   \phi_*(\xi).\tape[i\B^* ,\dots, (i+1)\B^*-\B].\State  & = \upsilon_{*}(s)
   \txt{ if } i = \xi.\pos \\
   \phi_*(\xi).\tape[i].\cDir &= 1 \txt{ if } i<\xi.\pos \\
   \phi_*(\xi).\tape[i].\cDir &= -1 \txt{ if } i>\xi.\pos \\
   \phi_*(\xi).\tape[i].\cDir &= 0 \txt{ if } i=\xi.\pos,
\end{aligned}
\end{equation}
and for the state of $\xi$, we set
\begin{equation}\label{eq:init-state}
\begin{aligned}
   &\phi_*(\xi).\G = \false \\
   &\phi_*(\xi).\Sweep = 1 \\
   &\phi_*(\xi).\Mode = \Normal \\
   &\phi_*(\xi).\Addr = 0 \\
   &\phi_*(\xi).\pos = \xi.\pos.
\end{aligned}
\end{equation}


    The corresponding decoding of an infinite
    configuration $\xi'=\phi_*(\xi)$,
    we subdivide it first into
    blocks of size $\B^*$ (starting with
    $\xi'(0)\dotsm\xi'(\B^* - \B)$),
    decode each block
    separately using $\psi^*$, and
    concatenate the results.



This definition of decoding will be refined for
configurations that are not in the range of the encoding
function, since the
location of the base colony must also be found using decoding.



%When encoding an initial configuration, we must
%also specify how to set other fields of the tape.

%The corresponding decoding function
%$\phi^{*}$ is obtained by applying the decoding
%function $\upsilon^{*}$ to just the $\cInfo$ track
%of $M$ to obtain the tape of the simulated machine,
%and just the  $\cState$ track of the base colony
%to obtain its state.



\begin{figure}[h]
\centering
\includegraphics[width=5in]{hpics/coding.pdf}
\caption[Coding]{Coding $\phi_*$ obtained from $\upsilon_*$
\label{fig:coding}}
\end{figure}





\section{Simulation structure and coordination}

%Later, in Definition~\ref{def:healthy1},
% we will define what does it mean
%for a configuration to be \df{healthy}.

The first task of each simulation step is to check if the state
of the machine and the current cell are in a certain relationship.
When this condition is breached (due to some burst), machine calls
$\Alarm$ --- a rule that will initiate the recovery.
Below, we will specify these conditions, but later, we will
aggregate them into one, that we call the \df{coordination}.


The sketch of the main rule of machine $M$ is given in
Rule~\ref{alg:main1}, where
$\Comp$, $\Transfer$, and $\Commute$ are
three rules defined below.

\begin{algorule}[h!] \caption{{\bf Main rule}\label{alg:main1}}
  \If{$\Mode=\Normal$}{
    \lIf{\algNot $\Coordinated$}{$\Alarm$}\;
    \lElseIf{$1 \leq \Sweep < \CompStart$}{$\PreProcess$\;}
    \lElseIf{$\CompStart \leq \Sweep < \TransferStart$}{ $\Comp$ %given in the Rule~\ref{alg:comp}
    }\;
    \lElseIf{$\TransferStart \le \Sweep < \Last$}{ $\Transfer$ %given in the
      % Rule~\ref{alg:spread}}
    }\;
    \lElseIf{$\Last \le \Sweep $}{$\Commute$ % given in the Rule~\ref{alg:comm}
    }
  }
\end{algorule}


\section{Sweep counter and direction}

The global sweeping movement of the head will be
controlled by the parametrized rule
\begin{align*}
\ruSwing(a,b,u,v).
\end{align*}
This rule makes the head swing between two extreme points $a,b$,
while the counter $\Sweep$ increases from value $u$ to value $v$.
The $\Sweep$ value is incremented at the ``turns'' $a,b$ (and is
also recorded on the track $\cSweep$).

%\subsection{Yarding}%\label{sec:yarding}
%
%    For reasons that we will explain later, at certain sweeps,
%    the head will step outside of the current colony for certain
%    number of cells.
%    This property of our machine will be called the \df{yarding} property.
%
%    If when the head steps outside it does not find a cell,
%    it will create one.
%    While the head is on the cells that are outside,
%    it will save the current $\Sweep$ value
%    in the $\cVisSw$ and the current $\Addr$ modulo $Q$ in
%    $\cVisAddr$.
%
%    The range of penetration of the head in the right (resp., the left)
%    neighbor colony for each sweep that is greater than 1
%    is the number of trailing zeroes in a
%    binary notation of the $\Sweep - 1$ (resp., $\Sweep$), multiplied
%    by $\Z-4\beta$.


%\subsection{Sweep direction}

    The sweep direction $\delta$ of the simulating head is derived from
    $\Sweep$, $\Addr$ and the current value $\Dir$ in the following way.
    On arrival of the head to an endpoint (that is
    when $\Dir \neq 0$ and $\Addr\in\{a,b\}$), the values
    $\Sweep$ and $\cSweep$ are incremented and $\Dir$ is set to 0.
    In all other cases, the sweep direction is determined
    by the formula
     \begin{align}\label{eq:sweep-dir}
       \dir(s)=(-1)^{s + 1}.
     \end{align}
    Let
    \begin{equation}\label{eq:Dir}
    \delta =
      \begin{cases}
         0 & \text{ if $\Addr\in\{a,b\}$ and $\Dir\neq 0$},  \\
           \dir(\Sweep) &\text{otherwise}.
         \end{cases}
    \end{equation}

\section{Examples of some rules}

As an example of rules, we present the zigging rule in
Rule~\ref{alg:Zigzag}, which itself uses the rule $\Move(d)$.
At each non-zigging step, $\Addr \gets \Addr+\delta$.

\begin{algorule}[!ht]\caption{$\Move(d)$}\label{alg:Move}

  $\Dir\gets d$\Comment*[f]{$d\in\{-1,0,1\}$.}\;

  \lIf{$\Mode=\Normal$}{$\Addr\gets\cAddr\gets\Addr+d$}\;
  \lElseIf{$\Mode=\Recovering$}{$\Rec.\Addr\gets\Rec.\Addr+d$}\;
  \lElse{$\Arb.\Addr\gets\Arb.\Addr+d$}\;
  Move in direction $d$.
\end{algorule}


\begin{algorule}[!ht]\caption{$\Zigzag(d)$}\label{alg:Zigzag}
  \Comment{$d\in\{-1,1\}$ is the direction of progress.}
  \If{$\ZigDir=-1$ \algAnd (($\ZigDepth=0$ \algAnd $(\Z-\Z_b)|\Addr$)
    \\ \algOr $0<\ZigDepth<\Z$)}{
    $\increment{\ZigDepth}$\;
    \lIf{$\ZigDepth = \Z-1$ %\algOr $\cAddr\in\{-Q+1,2Q-2\}$
    }{$\ZigDir=1$}\;
    $\Move(-d)$
  }
  \ElseIf{$\ZigDir=1$ \algOr ($\ZigDepth=0$ \algAnd $(\Z-\Z_b)\not|\Addr$)}{
    \lIf{$\ZigDepth>0$}{$\decrement{\ZigDepth}$}
    \lElse{$\ZigDir\gets -1$}\;
    $\Move(d)$
  }
\end{algorule}



\section{Computation Phase}\label{sec:computation-phase}


The primary aim of this phase is to obtain new values for
$\cState$, $\cDrift$ and
$\cInfo$.
During this rule, the head sweeps the base colony.


Computation rule essentially repeats five times the following \df{stages}:
\df{decoding}, \df{applying the transition}, \df{encoding}.
Later, we will specify rules $\UsefulComp$, and $\getOrders$.
In the first reading, the reader can ignore their presence below.



In more detail:
\begin{enumerate}
     \item   In the first sweep of the work period, we set
      $\cAddr \gets \cAddr\bmod{Q}$ and $\cKind \gets \Member$.


      \item For every $j=1,\dots,3$, if $\Addr \in \set{0, \dots, Q-1}$ do


       \begin{enumerate}

          \item Calling by $g$ the  string found on the $\cState$ track of
            the base colony between addresses $\PenetrationLen$
            and $Q-\PenetrationLen$, decode it into string $\hat g=\upsilon^{*}(g)$
            (this should be the current state of the simulated machine), and
            store it on some auxiliary track in the base colony.
            Do this by simulating the universal machine on the $\Prog$ track,
            with the program
            $p_{\decode}$:
                          $\hat g = \Un(\ang{p_{\decode}}g)$.

            Proceed similarly with the string $a$ found on the $\cInfo$
            track of the base colony, between
            addresses $\PenetrationLen$
            and $Q-\PenetrationLen$, to get $\hat a = \upsilon^{*}(a)$
            (this should be the observed tape symbol of the simulated machine).

          \item \label{i:comp.trans}
           Compute the value
      \begin{align*}
           (a',g',d)=\delta(\hat a, \hat g)
      \end{align*}
            similarly, simulating the universal machine $\Un$ with program $p$.
            Program $p$ is essentially the program that we are writing.
            More precisely, before performing the computation of
            $\Un(\ang{p}\ang{\hat a,\hat q})$ of Definition~\ref{def:univ-TM},
            machine $M$ writes the program $p$ onto $\Prog$ track.
            (For further details how this can be done, see Section~\ref{sec:self-simulation}.)

         %  \item\label{i:comp.sidesim} Call the rule $\SideSim$ that we will specify later.


            \item\label{i:comp.write}
              Write the encoded new state $\upsilon_{*}(g')$ onto the
              $\cHold[j].\State$ track of the base colony between positions
              $\PenetrationLen\B$ and $Q-\PenetrationLen\B$.

              Similarly, write the encoded new observed cell
              content $\upsilon_{*}(a')$ onto the
              $\cHold[j].\Info$ track of the base colony between positions
              $\PenetrationLen\B$ and $Q-\PenetrationLen\B$.

              Write $d$ into the $\cHold[j].\Drift$
              field of \emph{each cell} of
              the base colony.

        \end{enumerate}


      \item


        Once the hold tracks are populated,
        sweeping through the base colony,
        repeat the following two times.
        \begin{quote}
            Sweep the base colony and at
             each cell compute the majority of
            $\cHold[j].\Info$, $j=1,\dots,3$,
            and write into the field $\cInfo$.
            Proceed similarly, and simultaneously,
            with the $\Drift$ and $\State$ fields.
         \end{quote}

        As least one of these two repetitions will be
        burst-free.

       \item  Call the rule $\getOrders$ that we will specify later.

       \item Call the rule $\UsefulSimComp$ that we will specify later.
  \end{enumerate}

    It can be arranged---and we assume so---that the
    total number of sweeps of this
    phase, and thus the starting sweep number of the next phase,is
     \begin{align}\label{eq:TransferStart}
        \TransferStart=O(Q),
     \end{align}
    depends only on $Q$.

\subsection{Interval plurality}\label{sec:majority}

We give an algorithm that computes the \df{plurality} of some field
$\fld{c.F}$ over some
interval, that is, the value that appears the most, but at least
$1/3$ of the times.
Rule~\ref{alg:MAJ} is a version of an algorithm from \cite{misra}.
Running in a single sweep, the rule maintains a
data structure of $2$ pairs of $(v_i,c_i)$ that store
some candidate majority values and their current weight.

\begin{algorule}[htb!]\caption{$\MAJ(\fld{F},\fld{G}, n)$}\label{alg:MAJ}
\Comment{Interval ``majority''
of the field $\fld{F}$, computed and then
stored in the field $\fld{G}$ of the machine's state.
Initially $(v_i, c_i)=(\emptyset, 0)$, $i=1,2$.
}
\If{the end of the interval of length $n$ is reached}{
  $i \gets \arg \max_{j=1,2}(c_j)$\;
  $\fld{G} \gets v_i$
}
\Else{
  \If{$v_j=\fld{c.F}$ \algOr $c_{j}=0$ for some $j\in\{1,2\}$}{
    $v_j \gets \fld{c.F}$, $\increment{c_j}$
  }
  \lElse{$\decrement{c_1}$, $\decrement{c_2}$}\;
  (move right) \;
\Comment{Actually, the swing rule will move the head (with zigging).}
}
\end{algorule}

\subsection{Rule $\getOrders$}\label{sec:rugetOrders}

  If the simulated machine is turning a cell to vacant, then
  the cells of $M$ simulating it will turn to stem cells.

  During the computation phase, machine $M$ will
  ``get orders'' from the machine that it is simulating.
  Namely, not only it is updating fields like $\cDrift$, but also a local
  field like $\cAf \in \{\true, \false\}$.
  This flag is true on a cell $x$, if it belongs to a colony
  that represents a cell that is switching its kind to vacant (\ie is ``dying'').

  This %and similar
  operation will be
  done by a rule called $\getOrders$ that
  is incorporated
  in the computation phase.

  It decodes the value of $\cKind$ field from $\Info$.
  If its value is $\Vacant$, it sets $\Af$ field of
  appropriate hold track to $\true$.
  Otherwise, it sets it to $\false$.
  Then it updates $\cAf$ of each cell by computing the majority of the
  candidate values stored in the cell's hold fields.
The details of the rule are given in Rule~\ref{alg:getOrders}.

   \begin{algorule}[h!] \caption{{\bf Destroy}\label{alg:getOrders}}
    \For{j=1,\dots,3}{
         Decode $\cKind$ field from $\cInfo$\;
        \If{the value decoded is $\Vacant$}
            {$\cHold[j].\Af \gets \true$}
     }
     \For{j=1,\dots, 2}{
         $\cAf \gets \maj(\cHold[1].\Af, \dots,
                          \cHold[3].\Af)$
     }

  \end{algorule}

%\subsection{Updating machine parameters}
%\TODO{Put the call in the computation rule after clarifying this
%point with Peter}
%
%    Recall that the state of a generalized Turing machine
%    has a field $\Dir$ storing the direction of the previous
%    step.
%    Also, each cell has a field $\cDir$ pointing to the head.
%
%    Our goal is to define a program that will
%    be able to simulate any other generalized Turing machine, with
%    possibly the same program.
%    In~\eqref{eq:Dir} we see that transitions do depend on the $\Dir$
%    field of the state.
%    For this reason, we need to set this distinguished
%    parameter of the state of the simulated machine.
%
%    This means that in the $\Info$ track of the base
%    colony we must update $\cDir$ to $\Drift$.
%    Also, if $\Drift = 0$ then
%    we need to update the
%    $\Dir$ field encoded in the $\State$ track of
%    the base colony.
%    Otherwise, before the end of the work period, we
%    need to update the $\Dir$ field encoded in the $\State$
%    track of the neighbor colony where $\Drift$ is pointing to.
%
%    We perform these tasks by adding the
%    Rule~\ref{alg:MachineParam1}
%    in task~\eqref{i:comp.write} of the computation phase.
%
%
%
%\begin{algorule}[h!]\caption{Updating machine parameters \label{alg:MachineParam1}}
%%\Comment{ }
%
%Update $\cDir$ bits in $a'$ to $\Drift$\;
%
%\If{$\Drift = 0$}{
%Update $\Dir$ bits in $g'$ by setting them to $\Drift$\;
%}
%
%\end{algorule}







\section{Transferring phase}

The aim of this phase, present only if $\Drift \ne 0$,
is to transfer the new $\State$ of the simulated machine
 into the neighbor
colony in the direction of $\delta = \Drift$
(which was computed in the previous phase),
and to move there.
During this phase, the range of the head
includes the base colony and the neighbor colony
determined by the drift,
including the eventual bridge between them.
Only in the colony determined by the $\Drift$,
we will write the $\Drift$  value onto $\cDrift$ track of the
colony determined by $\Drift$.

The sweep numbered with $\TransferSw(\Drift)$
is the \df{transfer sweep} is the
sweep in which we start
transferring in direction $1$ or $-1$:
\begin{equation}\label{eq:TransferSw}
                  \TransferSw(1) =\TransferStart,
\quad             \TransferSw(-1) =\TransferStart+1.
\end{equation}

%The head will swing between the
%positions $\LEnd(\delta, s)$ and $\REnd(\delta, s)$,
%where $\LEnd(\delta, s)$ is the number of



We will make use of some extra rules that we will
specify in more detail later, but whose role is
spelled out here.
The phase consists of the following actions.
\begin{enumerate}[1.]
\item If all the cells of the neighbor colony are vacant,
it creates cells.

\item If $\Sweep = \TransferSw(\delta)$, we
  spread the value $\delta$ found in the cells of the $\cDrift$ track
  (they should all be the same)
  onto the $\cDrift$ track of neighbor colony in direction $\delta$.

    If $\Sweep = \TransferSw(-\delta)$, we spread
    the value $\delta$ found in the cells of the
    $\cDrift$ track of the base colony onto
    the $\cDrift$ track of the neighbor colony
    in direction $-\delta$.


\item\label{item:transfer-state} For $j=1,\dots,3$ do
\begin{quote}
       Call $\StateTransf$ that transfers the state of
       the simulated machine from the base colony to the $j^\tth$
       hold  track of the neighbor colony determined by $\delta$.
\end{quote}

\item Repeat the following two times
\begin{quote}
    Assign the field majority:
    $\cState\gets \maj(\cHold[1 \dots  3].\State)$
    in all cells of the neighbor colony.
\end{quote}

This part ends at the left end,
with a sweep value $\TfLast$
depending only on the program of the
simulated machine.

%\item In the colony $-\delta$, for $j=1,2,3$, do
%\begin{bullets}
%  \item Decode from $\cInfo$ and $\cState$;
%  \item Encode the values onto corresponding $\cHold[j]$ tracks;
%  \item Compute the majority of $\cDrift$ and store it onto
%  the corresponding $\cHold[j]$ track.
%\end{bullets}
%
%Then, repeat the following twice:
%          \begin{quote}
%            Sweeping through the neighbor colony $-\delta$,
%            at each cell compute the majority of
%            $\cHold[j].\Info$, $j=1,2,3$,
%            and write into the field $\cInfo$.
%            Proceed similarly, and simultaneously,
%            with the $\Drift$ and $\State$ fields.
%          \end{quote}



\item Call $\Euthan$.
This does some auxiliary computation that we will specify later.

\item If $\Drift = 1$, then relocate to the
future base colony: move right to cell $Q$.
Otherwise, we are already at the start of the
future base colony.
\end{enumerate}

%Note that the last sweep number of the work period is
%\begin{align}\label{eq:Last}
%  \Last(\delta) = \TfLast + \AuxSw +  \max(0,\delta).
%\end{align}

We need to address some important issues created by
larger bursts, and spell out certain additional rules
used in the simulation.
We do this in the following sections.

\section{Dealing with non-adjacency and other problems caused
by large bursts}\label{sec:adjacency}

       Since between two neighbor colonies a gap may exist,
       a special treatment is needed for the
       \df{transferring sweep} --
       when the head visits the neighbor colony for the first time
       in the current work period.

       \begin{definition}[Adjacency of cells]\label{def:adjacent}
        Cells $a$ and $b$ are \df{adjacent} if $|a-b|=\B$.
        Otherwise, if $\B < | a- b| < 2\B$, then
        $a$ and $b$ are two \df{non-adjacent neighbor cells}.


        The space between two colonies (resp., bodies of two cells)
         that is
        $<\B$ is called a \df{small gap}.

        The space between two colonies that is $>\B$ is called
        a \df{large gap}.



       \end{definition}

       Recall that the field $\G$ of the state of a generalized
       Turing machine is set to $\true$ if the current cell
       is not adjacent with the cell visited previously.

       By their definition of a colony,
       no two consecutive cells of the same colony are
       allowed to be non-adjacent.


      % As cells can be of many kinds, we can introduce
%       the following ordering among them.
%
%       \begin{definition}[Cell potency] \label{def:potency}
%           Field $\cKind$ classifies cells
%           according to their  \df{potency}:
%           stem cells are stronger than vacant cells, bridge
%           cells are stronger than stem cells, %and equal to $\SideExt$ cells,
%           neighbor and base cells are stronger than
%           the bridge cells.
%       \end{definition}

       Usually, when the head steps outside of the base colony,
       it should find a cell
       of the neighbor colony with appropriate values in
       address, sweep, $\cKind$,
       and drift fields.
       Then, it updates its $\cCore$ and $\cKind$ fields,
       and moves further until the end of the colony is reached.

       However, due to large bursts, we need to consider
       colonies that can have
       a ``gap'' in between, that is filled
       with cells whose $\cKind$ field is equal to $\Bridge$.
       To distinguish the cells of a neighbor colony
       and the base colony, the $\cKind$ of the cells of
       the neighbor colony will be set $\Neighbor$,
       and the $\cKind$ of the cells
       inside the base colony is set $\Member$.
       The field $\Kind$ of the state will carry the value
       of the $\cKind$ field of the previous step.



    \begin{figure}[h!]
    \centering
%    \includegraphics[width=3.0in]{hpics/gap-between-colonies.pdf}
    \includegraphics[width=4.0in]{hpics/gap-interruptions.pdf}
    \caption[Gaps]{Machine during the transferring sweep over a gap (Note zigging)
    \label{fig:gap}}
    \end{figure}


   % Recall that $\G$ field of the state indicates if the current cell
%    is non-adjacent with the active cell of the previous step.
    %If the head steps from one cell to a weaker one (see Definition~\ref{def:potency})
%    that is not adjacent,
%    then we will erase that cell, and create a new
%    cell that is adjacent to the stronger one.

    We explain the rule specific for the transferring sweep
    and some new changes to the entire program of the work
    period below.



\subsection{Rule $\ruTransferSw$}\label{sec:transfer-rule}

    Usually, during the transferring sweep,
    the head only spreads its ``workspace'' to the neighbor colony
    and updates the $\cCore$ fields.
    Now, due to adjacency problems, we need  some special
    considerations.
    Let $\delta = \dir(\Sweep)$, as determined by~\eqref{eq:Dir}.

    Suppose that on its first step outside of the base colony,
    the head steps on a cell whose $\cKind = \Bridge$.
    If this cell is adjacent to the base colony, then the head
    will just update the $\cCore$ values on the bridge cells.
    Otherwise, we kill it and
    create a new that is adjacent to the previous cell.
    We will do this for the entire bridge, in a process that we
    call \df{realignment}.

    Similarly, when the head steps off the
    base colony and encounters a vacant or stem cell,
    then we will build a bridge.
    However, the head does not know \emph{a priori}
    if it is creating a bridge between two colonies
    that are not adjacent, or it is just spreading the
    tape and building a new neighbor colony.
    Here, we assume that the machine starts building a
    bridge by setting $\cKind = \Bridge$ on each cell it creates.
    Once we complete the creation, if it appears that we
    have created $Q$ cells of size $\B$, then on the next
    sweep we will transform this
    into a neighbor colony by setting their $\cKind$ to $\Neighbor$.
%    Otherwise, on the next sweep, we will remove the prime sign all
%    over the bridge.


    Here are the details.

    \begin{flushdescription}
%
%    \item [The first cell outside of the base colony]
%    We now consider the case when the head is on
%    the first cell outside of the base colony in
%    direction $\delta$.

    \item [The structure of cells that are outside of the base colony]
    \hfill

        Suppose that $\delta = 1$ (resp. $\delta = - 1$)
         and $\Addr\geq Q$ (resp., $\Addr< 0$).

         Whenever we say that we meet a cell of a neighbor colony
         or a cell of an old bridge, we assume that
         their $\cSweep = \Last(-\delta)$ and $\cDrift \gets -\delta$.
         Otherwise, we call $\Alarm$.



%              and $\cDrift = -\Drift$.

%              If $\G = \false$,
%              then,
%              $\cKind, \Kind \gets \Bridge$,
%              update its $\cCore$, and move
%              in direction $\Drift$.
%
%              Otherwise, this cell is suspected, so we
%              set $\cKind, \Kind \gets \Bridge_S$, and
%              move to $\Drift$.



     \item [Realigning the (old) bridge]
     \hfill

              Let us now give the rules on how a bridge
              is realigned so it becomes
              adjacent to the base colony.

        \begin{enumerate}

        \item Suppose that $\delta = 1$ (resp., $\delta = - 1$)
        and  $\Addr > Q$ (resp., $\Addr<-1$),
        and
            suppose that
              $\cKind = \Bridge$,
              and $\Kind  \in \set{\Member, \Bridge}$.

              If $\G = \false$,
              then,
              $\cKind, \Kind \gets \Bridge$,
              update its $\cCore$, and move
              in direction $\Drift$.

              Otherwise, kill this cell (\ie set $\cKind \gets \Vacant$),
              set $\Kind \gets \Vacant$ and move in direction
              $-\Drift$.

    \item Suppose that $\delta = 1$ (resp., $\delta = - 1$)
        and  $\Addr = Q -1$ (resp., $\Addr=0$),
             $\cKind = \Member$,
             and $\Kind  = \Vacant$
             (\ie the head had returned from the cell
             it just killed).

             Then, we move in direction $\Drift$ and
             keep $\Kind$ the same.


     \item Suppose that $\delta = 1$ (resp., $\delta = - 1$)
        and  $\Addr > Q -1$ (resp., $\Addr < 0$),
             $\cKind = \Vacant$,
             and $\Kind  = \Vacant$
             (\ie the head had returned from the cell
             that we want to be adjacent with).

             Create a new cell %adjacent to the previous
             %cell,
             set $\cKind \gets\Bridge$, and
             write $\cCore$ in it.

        \item
            Suppose that $\delta = 1$ (resp., $\delta = - 1$)
            and  $\Addr > Q$ (resp., $\Addr<-1$),
            and
             $\cKind = \Bridge$,
             and $\Kind  \in \set{\Bridge,\Vacant}$.

        \item
            Consider the case when the first cell of the neighbor
            colony is reached, that is,
            suppose that $\Kind = \Bridge$, $\cKind = \Member$, and
            $\cAddr = 0$ (resp., $\cAddr =  Q-1$)
            if $\delta = 1$ (resp., $\delta = - 1$).

            Then, set $\cKind, \Kind \gets \Neighbor$,
            $\Addr \gets \cAddr$, and
            set other $\cCore$ fields appropriately.


  \end{enumerate}

  \item [In a neighbor colony]
    \hfill

            Suppose that $\delta = 1$ (resp. $\delta = - 1$)
            and $\Addr >0 $ (resp., $\Addr < -1$),
              $\cKind = \Member$,
              and $\Kind  =\Neighbor$.

              Then, set $\Kind, \cKind \gets \Neighbor$.
              and other $\cCore$ fields appropriately.

    \item [Building a new bridge]
    \hfill

        Suppose that the first cell outside of the base colony
        in direction $\delta$ is vacant or stem.

         Then, we create a new cell adjacent to the previous one,
         write the core values on it and set
         $\cKind, \Kind \gets \Bridge$.
         Then, we move in direction $\delta$.



    \begin{bullets}
    \item
        Suppose that
        $\Kind = \Bridge$ and $\Addr \leq 2Q-1$ (resp., $\Addr \geq -Q$).

        If the current position is vacant or stem, then
        create a new cell,
           write the core values on it and set
           $\cKind, \Kind \gets \Bridge$.

        Otherwise, suppose that the cell
        has $\cKind = \Member$ and $\cAddr = 0$ (resp. $\cAddr = Q -1$).
        This means that we have reached the neighbor cell.
        Then, we set $\cKind \gets \Neighbor$,
        $\Addr \gets \cAddr$, and set other $\cCore$ fields
        appropriately.

    \item Suppose that $\Addr = 2Q - 1$ (resp., $\Addr = -Q$)
        and the cell is vacant.
        Then, $\cKind, \Kind \gets \Neighbor$, that is, we
        have completed the new bridge.
    \end{bullets}


   \item [Alarm]
   \hfill

   If none of the previous cases apply, then call $\Alarm$.

    \end{flushdescription}




   % \begin{figure}[h!]
%    \centering
%%%    \includegraphics[width=3.0in]{hpics/gap-between-colonies.pdf}
%    \includegraphics[width=4.0in]{hpics/gap-between-colonies.pdf}
%    \caption{
%    A gap of size $\geq B_i$ between two colonies will be bridged
%    by $M_i$.
%    Gaps that are smaller than a cell size $B_i$ are  bridged by the
%    machine $M_{i-1}$.
%    \label{fig:smallgap}}
%    \end{figure}

\subsection{Finalizing the creation of
a colony or a bridge}\label{sec:extending-a-colony}

We have seen that during the transferring sweep, if the head
wants to transfer to a vacant area, it starts building a bridge there.
However, if this bridge has a size of a colony,
then on the sweep following the transfer sweep,
we switch the value of $\cKind$ from $\Bridge$ to $\Neighbor$,
of each cell.
The details are given in Rule~\ref{alg:Differentiation}.

%In more detail, if $\delta = 1$ (resp., $\delta = -1$),
%whenever $\Sweep = \TransferSw(\delta) + 1$
%do the following
%\begin{quote}
%If $\Addr \geq Q$ (resp., $\Addr<0$),
%      $\Kind = \Neighbor$,  and $\cKind = \Bridge$,
%\\     then set
%     $$\cKind, \Kind \gets \Neighbor.$$
%\end{quote}

\begin{algorule}[h!]\caption{Finalizing the creation of a colony
or a bridge \label{alg:Differentiation}}
%\Comment{ }
\If{$\Kind = \Neighbor$ \algAnd   $\cKind = \Bridge$}
{
\If{($\Addr \geq Q$ \algAnd $\Drift = 1$ \algAnd $\Sweep = \TransferSw(1) + 1$) \\
    $\quad$ \algOr
    ($\Addr < 0$ \algAnd $\Drift = - 1$ \algAnd $\Sweep = \TransferSw(-1) + 1$) \\
     }
{
    $\cKind, \Kind \gets \Neighbor$\;
}

}
\end{algorule}




%\begin{bullets}
%\item If $\Addr \geq Q$ (resp., $\Addr<0$)
%      $\Kind = \Neighbor$ and $\cKind = \Bridge$,
%     set $\cKind, \Kind \gets \Neighbor$.

%\item  If $\Addr = 0$ (resp., $\Addr = Q -1$)
%    and $\cKind = \Neighbor$,
%    $\Kind \gets \Bridge$.

%\item If $Q-1 \leq \Addr < 2Q-1$, $\Kind = \Bridge$ and
%    $\cKind = \Bridge'$,
%    set $\cKind \gets \Bridge$.
%\end{bullets}

\subsection{Address jump}\label{sec:ruAddrJmp}

    \begin{definition}[Address jump]\label{def:cut}
        Consider a configuration of the machine
        after the bridge is built or realigned.
        Suppose that the drift of the configuration
        is 1 (resp., -1).

        Then, the rightmost (resp., the leftmost)
        cell of the bridge  and the leftmost
        (resp., the rightmost) cell of the neighbor
        colony form an \df{address jump}.

%        If these cells are nonadjacent also, then this pair
%        defines an  \df{address cut}.
   \end{definition}

    Whenever the head steps
    from a bridge cell to the first cell
    of the neighbor colony, or back,
    the rule
    $\ruAddrJmp$
    sets $\Addr \gets \cAddr$.





  \subsection{Setting the parameters of the simulated machine}\label{sec:G-bit}

   Recall that $\G$ field of the state of a generalized Turing machine,
   $\G\in\set{\true, \false}$,  determines
   if the current cell is not adjacent to the cell
   where the head came from,
  % Also, the direction where the head came from is stored
%   in the $\Dir \in\set{0,\pm 1}$ field of the state.

   Clearly, before the machine completes the work period,
   we must update the $\G$ field % and $\Dir$ fields
   encoded in the
   $\State$ track of the neighbor colony.

   The first task is done
   after the $\State$ has been transferred from
   the base colony to the neighbor colony.

  We do this by using
  the rule $\rulConvHigh$ that checks if the base
  colony and the neighbor colony have a gap in between and modifies
  the $\G$ bit of the state stored in the neighbor colony in
  the $\State$ track.
  To prevent bursts from interfering
  in this process, we do it using multiple sweeps and
  by storing candidate values into $\cHold$ tracks, and
  updating $\State$ bits by taking their majorities.
  Then, during the next work period, this information is
  part of the current state of the simulated machine, and the
  simulated machine performs the transition accordingly.






\subsection{The last sweep of the work period}
  During the last sweep  of the transfer phase
  the rule $\Euthan$ is called.
  In the case that $\cAf$ track of the base colony %and the bridge
  is set to true,
  then during the last sweep of the work period,
  it sets the $\cKind$ of these cells to $\Stem$.




\begin{algorule}[h!]\caption{$\Euthan$ \label{alg:euthan}}

\Comment{This rule sets the cells of the base colony during the
last sweep of a period if the $\cAf = \true$, that is, it simulates
a death of a cell of the simulated machine}

   \If{$\Sweep$ is the last sweep of the work period \algAnd $\cAf = \true$
   \algAnd $\cKind = \Member$}{
           $\cKind \gets \Stem$\;
    }

\end{algorule}



\subsection{Relocating the head to the new base colony}
 At the last sweep of a work period, the head moves to the
 first cell of the
 future base colony.


 If $\Drift = 1$, we proceed as follows.
 If when $\Addr = Q$, a cell with $\cKind=\Neighbor$ is encountered,
 then, we just switch the work period: set $\Sweep \gets 1$ and
 $\Addr \gets 0$.
 Otherwise, keep moving to the right until the cell
 with $\cAddr = 0$ and $\cKind = \Neighbor$ is encountered.
 Once this cell is found, switch the work period.
 For $\Drift = -1$, the head just needs to relocate to the
 leftmost cell of its extended base colony.










 \section{Zigging}\label{sec:zigging}

    As the state of the machine after a burst is arbitrary,
    specially crafted bursts may cause the machine to skip some part of the
    simulation, causing the need to repair the structure on
    large areas of the tape (see Figure~\ref{fig:need-to-zig}).
    We would like that the repairs of the structure be local,
    \ie on tape intervals of constant size.

    \begin{figure}[h]
    \centering
    \includegraphics[width=4.0in]{hpics/no-zigging.pdf}
    \caption[The need of zigging]{A burst that just increments
    the value of the $\Sweep$ field, would cause large
    portions of the tape to have inconsistencies in
    the simulation structure
    \label{fig:need-to-zig}}
    \end{figure}

    We can achieve this with the use of zigging.
    In this way, inconsistencies in the structure
    are localized in space and time.

    As explained earlier, the role of zigging is to check for some
    consistency locally in space and time.
    The zigging runs throughout the simulation, and we will use
    it in other rules as well, therefore
    ``consistencies''  that zigging is checking, and the zigging
    parameters are different
    for each rule.

    What is common for all of them is the way how the head moves.
    Say, in simulation,
    after every $\Z - \Z_b$ steps of the simulation, the machine
    switches the direction and moves for $\Z$ steps backwards.
    During these steps it checks if $\cSweep = \Sweep$ and
    $\cAddr = \Addr + \Dir$.
    During the transferring sweep, we also check if $\cDrift = \Drift$,
    which ensures that the drift is spread correctly.
    When the head steps outside of the extended base colony and
    does not find a cell, then it creates a stem cell whose
    $\cDrift$ is set to $-\Dir$, where $\Dir$ is the field
    of the state storing the direction of the last step (see~\ref{sec:fields}).
    While zigging outside the extended base colony in normal mode,
    we allow only one small gap that must be positioned
    next to the extended base colony.
    If the head encounters some other pairs of cells
    that are not adjacent, alarm is called.



Later, in our analysis,
we will need to estimate the number of steps needed
to sweep a certain interval of cells where zigging is used.
For this purpose we introduce  the
function
\begin{align}\label{eq:Zg}
   \Zg(a,\Z, \Z_b),
\end{align}
where $a$ is the length of the interval, that is divisible by $\Z-\Z_b$.
For example, $\Zg(Q,\Z, \Z_b)$ bounds the number of steps
needed to sweep a colony with a zigging that
occurs every $\Z - \Z_b$ steps.
A simple bound on the values is
\begin{align}\label{eq:Zg-bound}
   \Zg(a,\Z, \Z_b) \leq \frac{a}{\Z - \Z_b}(3\Z - \Z_b).
\end{align}



\section{Self-simulation}\label{sec:self-simulation}

While spelling out the rule of the computation phase,
in the step~\ref{i:comp.trans}
we only said that machine $M$ writes the code of the machine that
it wants to simulation onto the $\Prog$ track.

In order to build our tower,
all machines $M_i$, $(i>1)$,  must have essentially the
same program as the machine
$M$ that we described
above.
%Let $M_1$ be the same machine as $M$.

%In~\ref{sec:UTM} we have seen that
%we can substitute a value for an input in a program.
%That is,
%if we have a program $p$
%taking some input, we can (for every input $x$)
%algorithmically construct a program $p'(p,x)$
%that will act as $p$ except that it takes $x$ as input.


%
%\begin{theorem}[Kleene's fixed-point]
%  For every transformation of programs $\pi$,
%  there is a program $p_0$ such that for any input $s$
%  $u(p_0s) = u(\pi(p_0)s)$, where $u$ is a universal function.
%\end{theorem}
%
%This theorem essentially states that if $\pi$ is a
%transformation of a program that adds to it some
%extra features (e.g., error-correction, recovery, etc.), then
%there is a program $p_0$ that acts as $\pi(p_0)$ on
%any input $s$.

Recall from Section~\ref{sec:language} that the program
of our machine is essentially a list of
``{\bf if }{\em condition} {\bf then} {\em statement}''
statements, represented as a constant size binary string.

We need to ensure that all machines have the same program.
The program $p$ of the simulation
that we wrote is hardcoded in the hardware, that is, in
the machine $M_1$.
Now, we need to find a way that $M_2$ has the same program as
$M_1$, $M_3$ has the same program as $M_2$, and so on.

We use the construction from the proof of
the Kleene's fixed-point
theorem and we also need to
discuss some other features of
our rule language and the interpreter $\Un$.
(A nice treatment of the subject is given in~\cite{ShenVer}.)

%We assume that using
%the language specified in Section~\ref{sec:language}
%we have defined the universal interpreter $\Un$ for it.

Our language has an extra feature that
it has a function $\getTxt(k)$ that
writes the $k^\tth$ bit of the program
on the $\Prog$ field of the current
cell.

Using the argument in the Remark~\ref{rem:interpreter}
we can prove the following

\begin{lemma}
  For some constant string $I$, with the property that
  for all positive integers $k$, strings $p$, $a, q$, where $p$
  is  a sequence of rules, and $a,q$ are strings of length $\geq k$
  representing the symbol of the current cell and the state of the
  generalized Turing machine $M_k$ with transition function
  defined by the rules in $p$,
  within at most $O(|p| + |a| + |q|)$ left-right turns we have
 \begin{align*}
      \Un(\ang{I}\ang{p,a,q})=\delta_{M_k}(a,q).
 \end{align*}

\end{lemma}

The constant string $I$ is essentially the program
of $\Un$ written in our language, and it is a part of
the program $p$ that we are writing, and that is --- as
we stated before --- hardcoded in $M_1$.

%As a part of the program for $M_1$, besides $p_{\decode}$ and
%$p_{\encode}$ we must write
%the program for for $U$ as well.
%Though this may be a tedious job to do,
%we assume that is done already.

\begin{remark}[Implementation of $\Un$]\label{rem:programOfU}
    It should not be strange that an interpreter
    can be implemented in the language it interprets.
    This is common in practice: say, the Java compiler is written
    in Java.
\end{remark}

Let us see how we can achieve all these in our program.

Computation of  $\getTxt(i)$ is easy: during the computation
phase over a base colony $C_1$ that corresponds
to the $i^\tth$ cell of the base colony $C_2$ of machine $M_2$,
machine $M_1$ writes the $i\tth$ bit of the program in the $\Prog$
field of the $\cInfo$ track.
In other words, machine $M_1$ writes its own code on the
$\Prog$ track $M_2$, while simulating the computation
phase of $M_2$.
Then, $M_2$ will do the same for $M_3$, and so on.

The $\getTxt(i)$ primitive is a part of the program $p$
that we are writing, and $\Un$ has explicit access to $p$
as its argument.
Therefore, there is no circularity in our definitions.




%
%Now, if $p_\pi$ is the implementation of the
%transformation
%$\pi$ using our language,
%then  program
%\begin{align*} r = \Un(p_\pi(\getTxt())x)\end{align*}
%is a fixed point.

%Now, $M_1$ essentially simulates a modified version
%of its own program that is stored in its head.
%In return, the simulated machine $M_2$ does the same, and
%consequently, in this way we build a ``tower'' of
%simulations
%\begin{align*}M_1 \leftarrow M_2 \leftarrow M_3 \leftarrow \dots,  \end{align*}
%where $M_1$ is a Turing machine, and $M_i$,for each $i>1$
%is a generalized Turing machine.








\section{Feathering property of the program and yarding rule}\label{sec:yarding}

    Later in Example~\ref{ex:aligned} we will see
    how bursts can ruin the structure of a neighbor
    colony, if during the simulation,  the head does not
    visit that colony for a long a time.

    For this reason, we introduce the following property of
    simulated programs.

    \begin{definition}[Feathering]\label{def:feathering}
        The transition function has the \df{feathering property}
        if the following holds.
        Suppose that the head leaves a cell at some time $t$ in the
        same direction $d$ from which it entered,
        and leaves it live (\ie the state of the cell did not turn to $\Vacant$).
        Then after entering this
        cell at some next time $t'$ (necessarily in direction $-d$),
        it will leave in direction $-d$.
    \end{definition}




    In connection with the self-simulation, we know that the colonies
    of $M$
    corresponding to cells that are inside a colony of a simulated
    machine $M^*$ will be visited frequently.
    However, neighbor colonies of the
    colonies that represent cells of $M^*$ that are the boundaries
    of colonies of $M^*$,  may not be visited for a long time, and hence,
    they can be targeted by a buildup of the regions with bad structure.

    To achieve this property, we need to modify the program of our simulation
    in the following way.


\subsection{Yarding rule}

    Suppose that $\Sweep = s$, and suppose that
    the head is on an endpoint
    of the extended base colony.
    Now, the decision is made
    if the head is stepping outside of the extended base colony.
    The decision for this, and the range of this removal
    from the extended base colony is determined by the number
    of trailing zeroes
    in the binary expansion of $s$.

    For a binary number $s$, let
    \begin{align}\label{eq:trail}
        \trail(s)
      \end{align}
    denote the number of trailing zeroes.

    If this number of the trailing zeroes is $n$,
    then, the head will go $n \E$ cells apart from the
    colony boundary,
    where
       \begin{equation}\label{eq:Expansion}
       \begin{aligned}
          \E = &c_E (\Z-\Z_b),     %30 (\Z - 4\beta).
          %t_z(\max_{d\in\set{\pm 1}\Last(d)}    %
       \end{aligned}
       \end{equation}
   for some constant $c_\E$, $c_\E>0$ that we will define later.


        Let
        \begin{align}\label{eq:yard-size}
         \iota(s) = \max_{i=1, \dots s} \trail((i)_2),
        \end{align}
        where $(i)_2$ is the binary representation of
        the nonnegative integer $i$, and
        $\trail$ is defined in~\eqref{eq:trail}.


    Hence, we can define the \df{yard depth} as
    the $\iota(\Last(d))$, for $d\in \set{\pm 1}$,
    where $\Last(d)$ denotes
    the largest value of $\Sweep$ in a work period (see \eqref{eq:Last}).

    Hence, we can set
    \begin{align}\label{eq:yard-depth}
       \YardDepth \leq  c\lceil \log Q \rceil,
    \end{align}
    for some $c>0$.
%    and require that
%    \begin{align}{eq:E-divides-Q+Yard}
%      \E \; | \; Q + \YardDepth,
%    \end{align}



\begin{figure}[h]
\centering
\includegraphics[width=4.0in]{hpics/yarding.pdf}
\caption[Yard]{Yarding for a sweep $s$ is determined by
the number of trailing zeroes of the binary
representation of $s$
\label{fig:yarding}}
\end{figure}


\begin{flushdescription}



\item [Visitor's structure]
    When the head is outside of the extended base colony,
    it will still maintain $\Addr$ and $\Sweep$ values of
    the state, but now, instead of writing
    their value in $\cAddr$ and $\cSweep$, it will
    write them in a set of designated fields
    $\cVisSw$,  $\cVisDrift$, and $\cVisAddr$ that we
    call the \df{visitor's (simulation) structure} in the following way.


    Suppose that $\Sweep$ is not the last sweep
    of the work period.
    Whenever we say that the head ``expects'' certain
    value on a cell, we assume that if this expectation is
    not satisfied, alarm is called.
    For example, if we say that the head expects to see
    a cell with $\cAddr = 0$ for a specific state,
    alarm will be called if this is
    not the case.


    \begin{enumerate}
      \item Suppose that the $\Drift = -1$.

      If the head is coming
      from the neighbor colony that is included in the extended base colony,
      whose $\cAddr$ run
      in $\set{0,\dots, Q-1}$ (\ie there is a bridge between it and
      the base colony),
      then, on the first cell of the yard, we set
      $\cVisAddr \gets -1$, on the second $\cVisAddr \gets -2$, and
      so on.

      If the head is coming from the neighbor colony (of the extended
      base colony),  whose $\cAddr$
      run in $\set{-Q,\dots, -1}$, then on the first cell
      of the yard $\cVisAddr \gets Q-1$, on the second
      cell $\cVisAddr \gets Q-2$,
      and so on.

      \item Suppose that the $\Drift = 1$.

      If the head is coming
      from the neighbor colony of the extended base colony,
      whose $\cAddr$ run
      in $\set{0,\dots, Q-1}$ (\ie there is a bridge between it and
      the base colony),
      then, on the first cell of the yard,
      $\cVisAddr \gets Q$, on the second $\cVisAddr \gets Q+1$, and
      so on.

      If the head is coming from the neighbor colony (of the extended base
      colony) whose $\cAddr$
      run in $\set{Q-1,\dots, 2Q-1}$, then on the first cell
      of the yard $\cVisAddr\gets 0$, on the second cell $\cVisAddr \gets 1$,
      and so on.

      \item Similarly, we define the rules when the head is stepping off
      the base colony.

      \item When the head completes the sweep, it turns and moves
            towards the base colony.
            At each step, it empties the visitor's structure on each cell.

    \end{enumerate}


\item [Vacant cells in a yard]

   What to do when the head steps off the extended base colony
   and is about to transfer on a vacant cell,
   or the first cell is non-adjacent to the extended base
   colony?

   \begin{quote}

   If there is no cell, then we will create a stem cell,
   set its $\cDrift$ to point to the base colony (\ie set it to $-\Dir$),
   and then move further, expecting eventually to hit appropriate endpoint
   of the neighbor colony: if any other live
   cell with nonempty $\cCore$ is encountered with, alarm is called.

   Otherwise, if the cell is not adjacent, then we move further, but
   as we progress inside the yard, no other pair of non-adjacent
   cells is allowed.
   \end{quote}


\end{flushdescription}



%\include{sec-noise}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%% CHAPTER Integrity..
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Integrity of the Structure,
            Health and Replacement Information}
            \label{sec:integrity}
The central simulation uses an error-correcting
code to ``protect'' information stored in $\Info$ and
$\State$ fields.
%Lemma~\ref{lem:errfreesim} suggests
%that as long as the simulation is being carried out
%by $M_1$, information and computation are ``safe'', i.e.
%due to the error-correcting mechanism built-in in the
%simulation itself, the information decoded from
%$\Info$ and $\State$ fields
%always correspond to the tape content and the
%current state of machine $M_2$, with respect
%to some code $(\varphi^*, \varphi_*)$ that
%generated the simulation
%function from Lemma~\ref{lem:errfreesim}.
%This is true even if at certain cells of the colony,
%information in these two fields is damaged or lost.
However, faults can ruin the simulation structure
and disrupt the simulation itself.
The error-correcting capabilities of the code
used to store the information on the $\Info$ and
$\State$ tracks, will preserve the content
of these tracks as long as coding-decoding
process implemented in the simulation is carried out.
Now, we will focus on the structural integrity of
a configuration, \ie the ``healthiness'' of the
simulation structure.


%In this chapter, we are introducing the tools
%to analyze the operation of our machines.
%We have introduced the notion of the configuration, and here
%we will define what does it mean for a configuration
%to be healthy.
%We need to specify the kind of structural integrity
%we expect a configuration to have.

\section{Healthy configuration}

We first define the cells where the simulation has finished.

\begin{definition}[Outer cells]\label{def:outer-cells}
    Recall the definition of the sweep value
    $ \Last(\delta) $ from~\eqref{eq:Last}.
    For $\delta \in \{ -1,1 \}$, if a cell is stem or
    has $0 \le \cAddr < Q$,
    $\cDrift = \delta$,
    $\cSweep = \Last(\delta)$
    then it will be called a \df{right outer cell} if
    $\delta = -1$.
    It is a \df{left outer cell} if $\delta = 1$.
\end{definition}

All our definitions below are very ``local'' \ie they
ask for certain regularities of a configuration
in a small interval.

\begin{definition}[Local configuration, replacement]
\label{def:local-config}
  A \df{local configuration on} a (finite or infinite)
  interval $I$ is given by values assigned to the cells
  of $I$, along with the following information: whether
  the head is to the left of, to the right of or inside
  $I$, and if it is inside, on which cell, and what is
  the state.

  If $I'$ is a subinterval of $I$, then a local configuration
  $\xi$ on $I$ clearly gives rise to a local configuration
  $\xi(I')$ on $I'$ as well, called its
  \df{subconfiguration}: If the head of $\xi$ was in $I$
  and it was for example to the left of $I'$, then now
  $\xi(I')$ just says that it is to the left, without
  specifying position and state.

  Let $\xi$ be a configuration and $\zeta(I)$ a local
  configuration that contains the head if and only if
  $\xi(I)$ contains the head.
  Then the configuration $\xi|\zeta(I)$ is obtained by
  replacing $\xi$ with $\zeta$ over the interval $I$,
  further if $\xi$ contains the head then also replacing
  $\xi.\pos$ with $\zeta.\pos$ and $\xi.\state$ with
  $\zeta.\state$.
\end{definition}

\begin{definition}\label{def:live}
    A cell is \df{live} if it is not
    vacant.
\end{definition}



\subsection{Healthy configuration}

Larger bursts introduce new anomalies of the state and the tape.
We will ``legalize'' only those that are encodings
of any configuration of the machine we simulate.
In the next definition, we spell out the kind of
local configurations that are created
in the normal course of simulation.
These are also the kind of configuration expected to be seen,
and alarm will be called if this
expectation is not met in a simple way
(the state and the cell state cannot be part of the same
healthy configuration).

Informally, cells of a healthy configuration on an interval $A$
are grouped into colonies of $Q$ cells, and no gaps exists between
these cells.
Further, no cell in $A$ should have marks of a recovery or
rebuild procedure, and no cell should have the distinguished
symbol $\dot{1}$ on it.
Addresses should grow from the left to the right, and except in two colonies
and in eventual space between them, $\cSweep$ is different
from $\Last(\pm 1)$.
Cells to the left of these two colonies have $\cDrift = 1$,
and cells to the right of these two colonies have $\cDrift = -1$, and so on.

That is, a configuration of level
$i \geq 1$ is healthy if it encodes (using $\phi_*$
from Subsection~\ref{sec:coding})
\emph{any} configuration of the $(i+1)$-th level.
For the purpose of our analysis, we outline the sufficient
conditions in the following definition.

\begin{definition}[Healthy configuration]
\label{def:healthy1}

    A configuration $\xi$ of a generalized Turing machine $M$,
    is \df{healthy on an interval $I$} of size
    at least $Q\B$
    that contains the head,
    if the  mode is normal,
    and the following conditions hold.

    Let $\delta = \Drift$.
    Recall the definition of the \df{transfer sweep}
    $\TransferSw(\delta)$ in~\eqref{eq:TransferStart},
    if $\delta \ne 0$.
    (There is no transfer sweep if $\delta = 0$.)

\begin{flushdescription}


\item[Colonies]
        Live cells of $I$ can
        be grouped into \df{colonies}
        of $Q$ cells.
        Except for at most one colony,
        all cells of the other colonies
        have $\cAddr \in \{0, \dots, Q-1\}$
        that grow continuously from left to right.
        All cells of a colony, except possibly the first
        or the last, are adjacent to both its
        neighbor cells.
        The border cells of a colony are adjacent
        to at least one neighbor cell.

        Except for eventually two consecutive colonies,
        the space between two non-adjacent
        consecutive colonies
        is filled to the maximum possible extent
         (at most $Q-1$) by a \df{bridge}
         that
         is a union of the following two
         kinds of intervals.
         One interval consists of cells whose
         addresses run continuously from its left
         colony, and the addresses of the other one,
         if not containing only stem cells,
         run continuously from the right colony.
         %All cells in the non-vacant intervals
%         have $\cKind = \Bridge$.

%        \item [Simulation content]
%         Content of the $\Info$ and $\State$ tracks
%        are valid codewords as defined in Sec.\ref{sec:coding}.



       \item[The base]
        The \df{base} is defined by counting back from $\Addr$
        such that, if the head
        passes from a cell with
        $\cKind = \Neighbor$
        to
        $\cKind = \Bridge$,
        we set $\Addr$ to $\cAddr$.
        The cell closer to the base
        where the $\Addr$ is adjusted during
        this count-back is called the
        \df{address jump}.

       \item [Base colony]
         The colony starting at the base is called the
         \df{base colony}.






    \item [Extended base colony]
        If $\Sweep \ge \TransferStart$
        (defined in~\eqref{eq:TransferStart}),
        then there is also an \df{extended base colony} $X$:
        this is obtained by extending the base colony,
        if $\delta \ne 0$, by a neighbor colony on the
        left or right (depending on $\delta$) together
        with a possible bridge in between.



    \item [The front]

% \begin{definition}[The front]\label{def:front}
    The farthest position to which the head has
    advanced before starting a new backwards zig
    while during the simulation
    is called the
    \df{front}.%, and is defined by
%     \begin{align*}
%         \front(\xi) = \xi.\pos + \ZigDepth\cdot d,
%     \end{align*}
%    where
%    $d$ denotes the direction of sweep (as determined
%    by~\eqref{eq:Dir}), and $\xi.\pos$ is the head position.
%\end{definition}








    \item[Workspace]

          Suppose that $\front(\xi)$ is inside the extended base colony.

            The \df{workspace} is a single
            interval that consists of
            non-outer cells, such that:

        \begin{bullets}
            \item For $\Sweep < \TransferStart$,
                  the workspace is equal to the base colony.
            \item In case of $\Sweep = \TransferSw(1)$,
                  the workspace is the smallest interval including
                  the base colony and the cell neighboring to
                  $\front(\xi)$ on the side of the base colony.

            \item In case of $\Sweep = \TransferSw(-1)$,
                  the workspace is the smallest interval including
                  the base colony, the right neighbor colony,
                  and the cell neighboring to
                  $\front(\xi)$ on the side of the base colony.

            \item If $\TransferSw(-1) < \Sweep < \Last(\delta)$,
                  then it is equal to the extended base colony.
            \item When $\Sweep = \Last(\delta)$, it is
                  the smallest interval including the future
                  base colony and $\front(\xi)$.
        \end{bullets}


      \item [Healthy sweep]

        Suppose that $\front(\xi)$ is inside the extended base colony $X$.

        All cells of $I$ except those belonging to $X$,
        have $\cSweep = \Last(\cDrift)$ on
        each cell.

        For $1 \le \cSweep \le \Last(\delta)$,
            we have $\cSweep(x) = \Sweep$
            in all cells $x$ behind $\front(\xi)$ in the workspace.
            For $\cSweep \notin \{1,\TransferSw(\pm 1)\}$,
            we have $\cSweep(x) = \Sweep - 1$
            in all cells $x$ ahead of $\front(\xi)$ (inclusive)
            in the workspace.

          For $\cSweep = \TransferSw(1)$
          (resp., $\cSweep = \TransferSw(-1)$),  either
          $\cSweep(x) = \Last(-1)$ (resp., $\cSweep(x) = \Last(1)$)
          or the cell is vacant or stem.

          Interval $[a,b]$ consisting of $\xi.\pos$  while
          $\xi.\Sweep = s$ is the \df{range of sweep $s$}.

          Sweep $s>1$,
          whose range is larger than the
          range of the sweep $s-1$ is a \df{growing sweep}.


       \item [Healthy addresses]
          Consider addresses $\cAddr$ in the workspace.
          The \df{address jump}
          splits the workspace in two partitions, one containing
          the base colony and the bridge, and the other one
          intersecting the neighbor colony.

          Addresses increase continuously
          in both partitions.


      \item [Cell kind] \hfill

         \begin{bullets}
          \item      Suppose that $\xi.\Sweep = 1$.
                Then, while
                  $\front(\xi)$ is inside the extended base colony,
                the $\cKind$ track
                on the segment
                   $\lint{0}{\front(\xi)}$ is
                 $\Member$.


                The $\cKind$
                track of
                $[\front(\xi), Q)$
                is all $\Neighbor$ (resp., $\Stem$)
                if $\cSweep >0$ (resp., $\cSweep = 0$).

               \item
                Suppose that $\xi.\Sweep = \TransferSw(\delta)+1$.
                Then, if $\delta = 1$ (resp., $\delta = -1$)
                whenever $ Q \leq \xi.\Addr\leq 2Q-1$
                (resp., $ -Q \leq \xi.\Addr\leq -1$)
                $\cKind$ track of the cells not in the base
                colony behind the front
                is $\Neighbor$.
                Cells that are not in a base colony
                and are ahead of the front
                have $\cKind = \Bridge$.
          \end{bullets}

        \item[Healthy drift]
         If
            $\Sweep \ge \TransferStart$
         or
            $\Sweep = 1$
         then
            $\cDrift$
         is constant on the workspace.

         The field $\cDrift$ of outer cells of $I$
         points toward the base colony.


    %\item [Non-live cells]
%         %Non live cells exists only at the ends of $I$.
%         Vacant positions exist only towards the ends of $I$, and
%         possibly in
%         only one interval of length less than $2\B$
%         surrounded by a cell $a$ with
%         $\cKind \in\set{\Member_M, \Bridge_M}$ in
%         one side, and a cell $b$ with
%         $\cKind =\Bridge_S$ in the other
%         side, while the position of the head
%         is between $a$ and $b$, $\Sweep = \TransferSw(\delta)$,
%         and the head is over the bridge in the direction
%         $\delta$.


    \item [Colony yard]

        Assume that $\Sweep = s >\TransferSw(\delta)$.

        Then, the \df{colony yard} consists of the
        cells that are removed
        $<(1 + \iota(s))\B$ from the workspace, where $\iota(\cdot)$
        is defined in~\eqref{eq:yard-size}.

        The front is in the union of the workspace and the
        colony yard which we call the \df{extended workspace}.

%        A \df{yard of a colony} consists of the cells whose
%        distance from the colony does not exceed $\YardDepth\B$
%        (see~\eqref{eq:yard-depth}).



        \begin{bullets}
        \item
            Suppose that $\delta = 1$, and suppose that the head
            is inside the colony yard
            to the right of the extended base colony
            that does not contain a bridge inside (resp.,
            does contain a bridge inside).
            The $\cVisAddr$ values on the cells
            of the extended workspace
            have continuous addresses starting from $0$,
            (resp., $Q$).

        \item
            Similarly, suppose that  $\delta = -1$, and
            suppose that the head is inside the colony yard
            to the left of the extended base colony
            that does not contain a bridge inside (resp.,
            does contain a bridge inside).
            The $\cVisAddr$ values on the cells
            of the extended workspace
            have continuous addresses ending with $Q-1$,
            (resp., $-1$).

         \item
            Whenever the head is inside a colony yard,
            the values of $\cVisDrift$ extend the $\cDrift$ values
            in the extended base colony if
            $\Sweep\geq\TransferStart$.

        \item
            Whenever the head is moving farther from
            the workspace while extending it over a yard,
            all cells behind the front (including it) have
            $\cVisSw = \Sweep$, and all cells
            to the front of it have empty $\cVisAddr$,
            $\cVisDrift$, and $\cVisSw$.

            Whenever the head is moving towards the base colony
            and is inside a colony yard,
            the cells in front of the front must have
            $\cVisSw = \Sweep - 1$.
            Further, all cells behind the front have
            empty $\cVisAddr$,
            $\cVisDrift$, and $\cVisSw$.

%            Suppose that the
%            head is inside the extended base colony.
%            Then,
%            the $\E \cdot \trail((s-1)_2) $ cells
%            next to it %the extended base colony
%            in direction $-\dir(s)$
%            have $\cVisSw = s$;
%            cells in a range from $\E\cdot\trail((s-1)_2)-\dir(s)$ to
%            $\E\cdot\trail((s-3)_2)  -\dir(s)$ from
%            the extended base colony
%            in direction $-\dir(s)$
%            have $s-2$, and so on.

        %\item
%            Suppose that $\front(\xi)$ is
%            in the colony yard to the right (resp., left) of the
%            extended base colony $X$.
%
%            Let $\dir(s) = 1$.
%            Then, all the cells within a distance of
%            $\E\cdot\trail((s-1)_2)$ from $X$
%            that are behind the front have $\cVisSw = s$, and
%            those that are to the right (resp., left) of the front
%            have $\cVisSw = s-1$.
%
%            When $\dir(s)=-1$, cells
%            within a distance of $\E\cdot\trail((s-1)_2)$
%            from the extended base colony that are behind the front
%            have $\cVisSw = s$,  and
%            cells in front of it have $\cVisSw = s-1$.


        \end{bullets}




%      \item[Simulated content]%\label{i:healthy.Info}
%          The $\Info$ and $\State$ tracks contain valid codewords as
%          defined in Section~\ref{sec:coding}.

     \item[Normality]
           No cell in $I$ is marked with the
           marks of the recovery
           procedure or rebuild procedure, and
           no cell has the distinguished $\dot{1}$ symbol.
           That is, for every $x \in I$,
           $\cRec.\Core = 0$ and
           $\cArb.\Core = 0$
          (see the definition of marking after~\eqref{eq:cRecCore}
           and after~\eqref{eq:cArbCore}, respectively).



  \end{flushdescription}

  %A configuration $\xi$ is \df{healthy}, if it is
%  healthy on an interval of size at least $Q\B$  containing the head.

\end{definition}

%
%\begin{definition}[Healthy interval]\label{def:healthy-interval}
%    An interval $I$ consisting of at least $Q$ cells of
%    machine $M$
%    is \df{healthy} if some configuration is healthy on it.
%\end{definition}



Now we can define what does it mean for the head to be
coordinated with the current cell.

\begin{definition}[Coordination] \label{def:coordinated}
   The state of the machine is \df{coordinated} with the current cell
   %if it is not marked with the marks of the rebuild procedure, and
   if it possible for them to be in a healthy configuration.
\end{definition}

%\Inote{I needed this because I'm using the $\Calc$ algorithm
%in the rebuild, so in the healthiness I do allow these marks and
%then $\Calc$ and patching lemma make sense.}

In the following lemma, we show that
for every value of $\Core$ of the state of the machine,
coordination defines uniquely the values of
$\cCore$ for a cell that is coordinated with the state of
the machine.
However, the content of a cell does not
determine uniquely the values of $\Core$
in order for the head and the cell to
be coordinated.


\begin{lemma}[Coordination]\label{lem:coord}
    While the head is inside the workspace,
    each $\Core$ value
    determines uniquely the
    $\cCore$ value of the cell it is coordinated with, except
    during the transferring sweep, when the machine is
    realigning or creating a bridge between the base colony
    and the neighbor colony, and during the address jumps,
    that is, when the head is crossing from the bridge to
    the neighbor colony and vice versa.


    In the reverse direction, the relation is less strict:
    A sextuple
    $$(\cAddr, \cSweep, \cKind, \cVisSw, \cVisAddr, \cVisDrift)$$
    of a cell of machine $M$,
    determines uniquely the $\Addr$ field of the machine's head
    that can be coordinated
    with it, and requires  $\Sweep \in \{\cSweep,\cSweep+1\}$
    if the head is inside the extended base colony,
    or $\Sweep \in \set{\cVisSw, \cVisSw +1}$ otherwise,
    with the exception of the transferring sweep
    and when the head is farther than $\iota(\Sweep)$ from
    the extended base colony's boundary,
    or the head is
    zigging at most $\Z_b\B$ outside of the yard.
\end{lemma}
\begin{proof}
    For the forward direction, the proof follows immediately from
    the design of the simulation procedure.

    Let us focus now on the reverse direction.
    Without loss of generality, assume that the drift is positive.
    The requirement that $\Sweep \in\set{\cSweep, \cSweep + 1}$
    comes from the fact that the head in normal can be over
    a cell for two reasons: when the head is over the front,
    then $\Sweep = \cSweep + 1$, but when the head is in zigging
    verifying the consistency, $\Sweep = \cSweep$.
    Similarly for $\cVisSw$.

    Consider the case when the head is on the first cell of
    the neighbor colony.
    The value of its $\cAddr$ field is $0$.
    If the base colony and the neighbor colony do not have
    a bridge in between, then $\Addr = Q$.
    Otherwise, $\Addr = 0$.
    Further, consider the case when
    the head is over the first bridge cell during the transferring sweep.
    Then, if $\Kind = \Member$, then $\Addr = Q$.

    Finally, whenever we are in a yard, then
    the way how $\cVisAddr$ are defined in Section~\ref{sec:yarding}
    imply that $\Addr$ is determined uniquely from
    $\cVisSw$, $\cVisAddr$, and $\cVisDrift$.

\end{proof}




%\section{Effects of a burst}
%
%
%After a burst occurs, the state of a machine $M$ is
%arbitrary.
%This means that if the machine before the burst
%was performing the simulation, then a specifically
%crafted burst may put the head on a cell that is
%coordinated with the head.
%But zigging  brings the head back at the island
%that was created during the burst, hence detecting
%it.
%Alas, there is a condition when the previous
%does not hold.
%Namely, if the burst occurs while the head was zigging, and
%the head was at least $\Z_b\B$ from the front, provided
%that the machine continues with the simulation seamlessly
%after the burst, the island will not be reached during the current
%sweep.
%This is a way how islands can be left unrepaired on the tape,
%when bursts occur during the last sweep of a work period.
%
%\subsection{The escaping head}
%
%Above, we showed how the head after a burst may continue
%in any mode for at most $\Z - \Z_b$ steps during which,
%it may alter the structure on the tape further.
%
%Consider a tower of simulations $(\sS, \sM)$, and
%suppose that the configuration $\xi$ of machine $M_k$
%is  healthy on a large enough interval $I$, for some $k>1$.
%Suppose that a $\Noise^{(k)}$ burst occurs.
%Then, the state of $M_i$, $i\leq k$ is arbitrary.
%This means that the head of $M_k$ can move away from the
%island for at most $(\Z - \Z_b)\B_k$ from the island.
%How far from the island can the damage spread in this case?
%The damage on $M_k$ can be caused by a ruined cell
%structure on the levels
%By adding the distances that the heads of all machines
%below $M_k$ can move, and using~\eqref{eq:B_2-B_1-Q} and
%the fact that $\B_1 = 1$,
% we obtain
%\begin{align*}
%  & (\Z - \Z_b)(\B_1 + \cdots + \B_{k-1}) = \\
%  & (\Z - \Z_b)(1 + Q_1 + Q_1Q_2 + \cdots + Q_1\cdots Q_{k-2}).
%\end{align*}
%
%Later, we will define the lengths of $Q_i$, $i>0$,
%such that for every $k>1$,
%\begin{align}\label{eq:requirement-on-Q_k-B_k}
%    1 + Q_1 + Q_1Q_2 + \cdots + Q_1\cdot \cdots \cdot Q_{k-2} < \B_k.
%\end{align}
%This means that after a $\Noise^{(k)}$-burst,
%the damage cannot spread for more than
%\begin{align}\label{eq:damage-spillover}
%    (\Z - \Z_b)\B_k
%\end{align}
%from the island it created.
%
%It is easy to see that the damage cannot spread out
%off the islands when bursts occur during
%zigging while the head was at least $\Z_b\B$
%from the front.
%Indeed,
%
%In the following section, we will codify these, in
%the notion of an annotated configuration.



\section{Annotated configuration}


Recall the parameter $\E$ defined in~\eqref{eq:Expansion}, an d
the parameter $\PenetrationLen$ given~\eqref{eq:penLen}.

\begin{definition}[Annotated configuration]\label{def:annotated-config}
    An \df{annotated configuration} of machine $M$
    whose cell body size is $\B$,
    on
    interval $A$, of length at least $2\E\B$ that contains the head,
    is a quintuple
         \begin{align*}
             \cA=(\xi,\chi, \cI,\cS, \D),
         \end{align*}
    with the following meaning.
    $\xi$ is a configuration,
    $\chi$ is locally healthy configuration on $A$,
    $\cI$ is a set of intervals of cells called \df{islands},
    $\cS$ is a set of intervals of cells called \df{stains}, and
    $\D$ is an interval containing
    the head called the \df{distress area}.

    The distress area contains any island of size $\leq \beta\B$
    containing the head.
    (The distress area is where the structure
    is currently being restored.)
    The distress area has size $<5\E\B$.

    Islands may contain damage.

    We can obtain $\chi$ from $\xi$ by
    making the islands% and a stretch of at most
         %$\Z\B$ next to them
         damage-free, and filling
               them with cells, and then by
    \begin{bullets}
         \item changing the $\cCore$, $\cKind$, and $\cRec.\Core$ tracks
               in the islands and possibly
               additional $\le \Z$ cells within $\D$, where
               $\cRec.\Core$ is a set of fields used in the recovery
               procedure;
        % \item changing the $\cInfo$ and $\cState$ track in the stains;
         \item changing the state, the $\cRec.\Core$ track,  $\cKind$,
               in $\D$,
               and the head position inside $\D$.
    \end{bullets}
%    or by
%    erasing at most $\E$ cells from $\D$.


    Suppose that
     $|A|\geq Q\B$ and that $\xi.\pos \in A$.
    The \df{current colony} of $\cA$ is
    the base colony of $\chi$.

    We say that an interval $W$
    is the (extended) \df{workspace} of the annotated
    configuration $\cA$ if it is the
    (extended) workspace of $\chi$.




    The following additional properties are required:
    \begin{enumerate}[(a)]
        \item \label{i:annotated-config.islands}

           % There are at most 2 islands in each colony that do not
%            intersect the workspace.
%            If there is more than one, the

            At most two islands intersect the workspace.

            There are at most 2 islands in each colony or bridge
            that do not intersect the workspace and the extended
            workspace.
            If there is more than one, then one of them is within
            a distance
            $\PenetrationLen\B$   %$\Z + \E$
            from the boundary of the neighbor colony
            towards the current colony.

        \item
            If $\D$ is  then the mode is normal.
%
%        \item \label{i:annotated-config.ptr}
%            The $\cDir$ field of each cell
%              of $A$ that is not damaged, points towards the head.

        %\item
%              What I meant is that if the head is in the
%              annotated configuration then the annotated configuration must
%              contain the current colony
%              (base colony is OK, just make sure it is clear that it
%              corresponds to the current cell of M^*).


    \end{enumerate}

    We say that a cell is \df{free} in an annotated configuration
    when it is not in any island or $\D$.
    The head is \df{free} when $\D$ is empty.

    An  annotated configuration on $A$ is \df{centrally consistent}
    if the workspace is free.
\end{definition}

Configurations that have an annotated configuration deserve
a special name.

\begin{definition}[Admissible configuration]
\label{def:admissible-config}
    A configuration $\xi$ is \df{admissible} on $A$
    if there is an annotated configuration
      $(\xi,\chi, \cI, \cS, \D)$
      on $A$.
    In this case, we say that $\chi$ is a healthy
    configuration on $A$ \df{satisfying} $\xi$.
    Any change to an admissible configuration on $A$ is called
    \df{admissible}, if the resulting configuration
    is also admissible on $A$.
\end{definition}

Intuitively, the definition says that a configuration is
admissible on an interval, if there are not ``too many'' islands
in that interval, and that by local changes, we can obtain
a corresponding healthy configuration on the same interval.
In Section~\ref{sec:patching}, we will see in more detail how
such a configuration can be obtained.





\section{Patching lemma}\label{sec:patching}

In this section we give a lemma that tells
how an admissible configuration of machine $M$,
can be locally corrected.

Recall the definition of outer cells in
Definition~\ref{def:outer-cells},
and the notion of the address jump in Definition~\ref{def:cut}.






Before  spelling out the main lemma of this section,
we need to introduce some notation, that will be used throughout this work.
Since cells between any two positions $a$ and $b$ can be nonadjacent,
the notation $b-a$ or $a + 3\beta\B$ is not adequate anymore.

\begin{Notation}\label{not:oplus-rho-ominus}

Let $a\in\bbZ$ denote a cell position, and let
$b$ be a positive multiple of $\B$.
%For any $a, b \in \bbQ$, $b\geq 0$

\begin{align}
  a \Plus b := c, \txt{ such that }  a\leq c \txt{ and }
  b \leq |c-a| < b + \B,
\end{align}
and
\begin{align}
  a \Minus b :=c, \txt{ such that } c \leq a \txt{ and } b \leq |c - a| < b + \B.
\end{align}

We will use this notation only when between
$a$ and $c$ at most one small gap exists.
%Further, we will usually omit the index $i$, when we are
%focusing on the cell size $\B$.

\end{Notation}





%Recall %the definition of the strong arm given in Definition~\ref{def:strong-arm}
%the definition of outer cells given in Definition~\ref{def:outer-cells}.
%
%\begin{definition}[Outer arms]\label{def:outer-arms}
% An interval of $[a,b]$ of length $l\geq \E \B$
% consisting of right (resp., left) outer cells
% such that $\cAddr(a) = 0$ (resp., $\cAddr(b) = Q - 1$)
%  is called a \df{right (resp., left) outer arm of size $l$}.
%\end{definition}

As we have seen in Chapter~\ref{sec:blueprint},
not all the sweeps of a work period or even its phase
have equal range.
For example, the transition sweep is larger than all
of its previous sweeps.
In Definition~\ref{def:healthy1}
we called such sweeps the growing ones.
%
%
%There are other sweeps with this property, so we characterize them
%in the following definition.
%
%
%\begin{definition}[Growing sweep]\label{def:growing-sweep}
%
%    Sweeps during which the workspace or the extended
%    workspace grow are called \df{growing}.
%
%%    Later, we will be able to give
%%    an alternative definition based on the notion of a
%%    range of a sweep that we will define later.
%   %  $s$ whose range is larger than the
%   % range of the sweep $s-1$ is a growing sweep.
%\end{definition}


In the main lemma of this section, we want to show how
to obtain a healthy configuration from an admissible one.
Its proof is constructive, since we give a procedure how
to achieve this.
Since we want to use this procedure in various settings,
we do not want to restrict it to admissible configurations
only.
Hence, we introduce the following.

\begin{definition}[Pre-annotated configuration]\label{def:permissible}
     A quintuple
     $\cA=(\xi,\chi, \cI, \cS, \D)$
     is \df{pre-annotated} on interval $A$,
     if by just erasing the rebuild marks (\ie setting
     $\cArb.\Core$ to $0$, see~\eqref{eq:cArbCore}) on each cell of $A$,
     $\cA$ satisfies
     all requirements of the Definition~\ref{def:annotated-config} on
     $A$.
\end{definition}




Recall the constant $\E$ defined in~\eqref{eq:Expansion}.
Let $c_\E$ be such that
           \begin{align}\label{eq:Z<<0.1E}
               72\Z \leq 0.1\E.
            \end{align}


\begin{lemma}[Patching]\label{lem:patching}

    Let
    $\R=\clint{a}{b}$ be a damage-free interval consisting of $2\E$
    cells of size $\B$ such that at most one pair of
    consecutive  cells determined by $\g=(g_{-1}, g_1)$
    can be non-adjacent or have an address jump.


    Let
    \begin{align*}
        \R_{j}^{k}=
        \lint{a \Plus 0.1 j\E\B}{b \Minus 0.1k\E\B}, \txt{ for } j, k = 0,2,4.
    \end{align*}

    Consider pre-annotated  configuration
     \begin{align*}
             (\xi, \chi, \cI, \cS, \D),
     \end{align*}
    on $\R$.



    %Assume that $\R$ contains no vacant positions, and
%    either in the left half or the right half of $\R$,
%    at least $\E - 6\beta$ cells of $\xi(\R)$ are not empty.
    %\Inote{I need $0.8\E$ as opposed to $\E$
%     for the disturbed recovery: a burst can send us $\loc$ cells
%     to the right of the recovery interval where only empty cells may
%     exist. }

   Then it is possible to compute from $\xi.\cCore(\R)$
   an interval
       $\hat \R \in \set{\R, \R_{0}^{2}, \R_{2}^{0},
            \R_{0}^{4}, \R_{4}^{0},
            \R_{4}^{2}, \R_2^4}$,
    and
    a local configuration
        $\zeta = \zeta(\hat \R)$
    such that
        $\chi|\zeta(\hat \R)$
    is healthy on $\hat \R$, %for some $\chi$
    and the following holds:

    \begin{enumerate}[\upshape (a)]
     \item\label{i:patching.inside}
          Assume that at least one half of $\R$ contains
          at least $\E - 3\Z$ cells that are not stem.

         Suppose that $a \Plus 0.25\E\B \leq \chi.\pos \leq b \Minus 0.25\E\B$.
         Then,
         if $g_1 > b \Minus 0.15\E\B$  (resp., $g_{-1} < a \Plus 0.15\E\B$)
         then
           $\hat \R = \R_0^2$ (resp., $\hat \R = \R_2^0$).
         Otherwise,
           $\hat \R = \R$.
          Further,  $\zeta.\pos \in \R$,
        and
           $\zeta.\ZigDepth = 0$.



        Suppose that  $\chi.\pos < a \Plus 0.25 \E\B$.
        If
        $g_1 > b \Minus 0.15\E\B$
        then
          $\hat \R = \R_{4}^{2}$.
        Otherwise,
         $\hat \R = \R_{4}^{0}$.
         Further,
           $\zeta.\pos$
         is  to the left of $\hat \R$.

        Similarly, suppose that
        $\chi.\pos> b \Minus 0.25\E\B$.
        If $g_{-1} < a \Plus 0.15\E\B$
        then
         $\hat \R = \R_{2}^{4}$.
        Otherwise,
         $\hat \R =\R_{0}^{4}$.
         Further,
           $\zeta.\pos$
         is  to the right of $\hat \R$.

     \item\label{i:patching.empty}
          Assume that at least $1.7\E$ cells of $\R$ are
          left (resp., right) outer.

          Suppose that
           at most $0.15\E$ leftmost (resp., rightmost)
          cells of $\R$ are not stem.
          If $\chi.\pos> b \Minus 0.25\E\B$,
          then $\hat\R = \R_2^4$.
          Otherwise, $\hat\R = \R_2^0$.

          Suppose that at least
          $0.15\E$ leftmost (resp., rightmost)
          cells of $\R$ are not stem.
          If $\chi.\pos > b \Minus 0.25\E\B$,
          then $\hat\R = \R_0^4$.
          Otherwise, $\hat\R = \R$.

     \item
        The states of non-stem cells of
        $\xi$ can differ from the corresponding cells
        of $\zeta$ only in the islands, and in
        an subinterval of $\D$ containing at
        most
        $(\Z - \Z_b + \beta)$ and
        the $\chi.\front$.

     \item
        The computation of $\zeta$ can be carried
        out
        (relying only on $\xi$ and $\R$), using
    \begin{align}\label{eq:scalc}
        \SCalc \leq 20
    \end{align}
        number (independent of $\beta$, $Q$)
        of passes over $\R$, and a constant number
        of fields of size $\le Q$.
    \end{enumerate}

\end{lemma}

Though long, this lemma states something pretty simple.
Namely, for a given pre-annotated configuration,
in a constant number of sweeps over a constant size
interval, we can compute a healthy one.
In other words, whenever the simulation structure of
the machine is slightly ruined, we will restore
the state of the machine to the ``closest'' state
before a ``distress event'' (stepping on an island
or a burst) occurred.
Indeed, if, say a distress event occurred while
zigging, we will not restore the exact position
of the head and the exact content of all fields
of the state, but rather the most important ones
that we call the \df{core fields}.


\begin{Proof}

    We now outline a procedure that finds $\hat \R$ and $\zeta$.
    Even if the reasoning below refers to a
    healthy configuration $\chi$ occasionally, the computation
    only relies  on the configuration $\xi$.

    We can safely assume that the configuration $\xi$ is annotated
    on $\R$, that is, we ignore the $\cArb.\Core$ markings.


    Let   $I=[a,b]$ denote an interval
    whose positions of cells are
    \begin{align*}\pi(I)= (x_1, x_2, \dots, x_n),\end{align*}
    with a property that for
    only one pair $(x_i, x_{i+1})$ of elements of this sequence,
    $\B<|x_i - x_{i+1}| <2\B$.
    By $\alpha(I)$, we
    denote the majority value of
    $\xi.\cAddr(x_1),\xi.\cAddr(x_2) - 1, \xi.\cAddr(x_3) - 2, \dots,
    \xi.\cAddr(x_n)-(n-1)$.
    Further
     $\sigma(I)$ and $\delta(I)$ the majority value
     of $\xi.\cSweep(x)$ and $\xi.\cDrift(x)$ for $x\in\pi(I)$.
     Let $m_{\alpha}(I)$, and so on, denote the multiplicity of
     $\alpha(I)$, and so
     on, over interval $I$.
    Whenever we write \df{plurality}, we mean a value with
    multiplicity larger than $1/3$ of the total.
    Empty cells
    are not counted in the total,
    and do not contribute to the counts.

%    We assume that we are given the cut defined by $\g$.




  \begin{step+}{step:correction:almost.outside}
    Assume that at least $1.7\E$ of cells
    in $\R$ are left outer (resp. right outer).
  \end{step+}
  \begin{prooofi}
     \begin{step+}{step:correction:almost.outside.non-empty}
        Without loss of generality, assume that
        at least $1.7\E$ cells are
        left outer cells that are not stem.
      \end{step+}
      \begin{prooofi}

         The value $\sigma\lint{a}{b \Minus\E/2\B}$
         is necessarily $\Last(1)$.

            If $\g$ is defined, then the address value $\alpha$
            of a cell at position $b$ is
            $\alpha = \alpha\lint{g_1}{b}$.
            Otherwise, we set
               $\alpha = \alpha\lint{a }{b\Minus\E/2\B}$.

            Then,
            if $\g$ is defined (resp., not defined),
            then we
            set
            $\zeta.\cAddr(x_i) \gets \alpha - (i-1)$
            $\zeta.\cSweep(x_i) \gets \Last(1)$,
            $\zeta.\cDrift(x_i) \gets 1$, and
            $\zeta.\cKind(x_i) \gets \Bridge$
            (resp., $\zeta.\cKind(x_i) \gets \Member$),
            for $x_i\in\pi(\hat\R)$.



            By computing $\alpha_v = \alpha(I)$
                and
            $\sigma_v=\sigma(I)$,
            where $I$ consists of all outer cells of
            $\lint{a}{b}$,
            determine if the interval intersects a colony yard.
            Since the length of a colony yard does not exceed
            $\E\B$, the length of this intersection is bounded
            by $\E\B$.
            Since $\R$ contains mostly left outer cells,
            $I$ cannot be beyond $0.3\E\B$ to
            the left from the center of $\R$.
            Let $[a',b']:=I$.
            (Similarly, if $\R$ contains mostly right outer cells,
            $I$ cannot be beyond $0.3\E\B$ to the right of $\R$.)

            Once we know $\zeta.\Sweep$, then we can
            know the values of $\cVisSw$ for the entire
            $\hat\R$, once we know the front.
            We compute the majorities of the values
            in $\cVisSw$ and $\cVisDrift$
            fields in $I$.
            Then, we locate the front, and based on the
            values of $\zeta.\cVisAddr$, $\zeta.\Sweep$,
            $\zeta.\cDrift$
            we determine the value of $\zeta.\Addr$ as guaranteed
            by Lemma~\ref{lem:coord}, and the values of
            the visitor's structure.

            Suppose that $\R$ does not intersect a yard for
            more than $0.25\E\B$ on the right side.
            Then, set $\hat\R \gets \R_{0}^{4}$.
            Otherwise, we set $\hat \R \gets \R$.
        \end{prooofi}

      \begin{step+}{step:correction:almost.outside.empty}
        Assume that
        the previous condition does not hold.
      \end{step+}
      \begin{prooofi}
        Compute the majority of $\cVisSw$ and $\cVisAddr$.

        1) Suppose that these majorities are not defined.

        If the number $n$ of non-stem cells on the leftmost
        end of $\R$ is $<0.15\E$, then we set $\hat\R \gets \R_2^4$.

        Otherwise,
        these  cells must have $\cSweep = \Last(1)$,
        $\cDrift = 1$, and the last of these cells must have
        $\cAddr = Q - 1$.
        We compute the majority  $\alpha = \alpha([a, a + n\B)$.
        All cells in  $\hat\R$, where $\hat \R =\R_0^4$,
         have $\cDrift \gets 1$.
        The stem cells to the right of the rightmost cell of the
        left neighbor colony have $\cKind \gets \Stem$.


        2) Suppose that these majorities are defined.
        If the front is within $0.25\E\B$ inside, then we compute
        $\zeta.\Sweep$ and $\zeta.\Addr$ as in
        the case~\ref{step:correction:almost.outside.non-empty}.
        If the number of non-stem cells on the left end of $\R$
        is less than $0.15\E$, then $\hat\R \gets \R_2^0$.
        Otherwise,
        the values of $\zeta.\cSweep(x)$, $\zeta.\cDrift(x)$,
        $\zeta.\cAddr(x)$, for nonempty values $x$ on the left
        end of $\R$ are computed as in the part 1) above.
     \end{prooofi}




\end{prooofi}

Assume that the above test fails: then given that
$\R$ intersects  at most
3 islands, we can assume that at least
%$0.3\E - 6\beta$ cells of $\R$ belong to
$0.3\E - 3\Z$ cells of $\R$ belong to
the workspace of the healthy configuration $\chi$.

\begin{step+}{step:correction.inside}
  Suppose that $\xi$ has at most $3\Z$ %$6 \beta$
  outer cells in $\R$.
\end{step+}

\begin{prooofi}
       Let $a^{+} = a \Plus 3\Z\B$ and %6\beta\B$ and
       $b^{-} = a \Minus 3\Z\B$. %6\beta\B$.

       Then the non-yard cells of
        \begin{align*}
            \R^{-} = \lint{a^+}{b^-}
        \end{align*}
       are all island cells, since the non-island and non-workspace
       cells of $\R$ must all  be at the ends.

       Compute $\sigma(R^{-})$, and assume without loss of generality
       $\dir(\sigma) = 1$ (the right sweep).


       We claim
             \begin{align*}
                   \chi.\front \Minus \Z\B
                      \leq
                         a^{+} \Plus m_{\sigma}\B
                      \leq
                        \chi.\front \Plus \Z\B.
             \end{align*}

    Indeed, in the healthy configuration $\chi$,
    the right-sweeping cells inside $\R^{-}$ form
    an interval on the left of $\chi.\front$.
    By the definition of annotation, $m_{\sigma}$
    could differ from the size of this interval
    only due to island cells, and possibly on
    an interval of size $\le (\Z - \Z_b + \beta)\B$
    containing $\chi.\front$.

\begin{step+}{step:correction.inside.addr}
    Compute the addresses and sweep values.
\end{step+}
\begin{prooofi}
  Recall that we assumed $\dir(\sigma) = 1$.
  First we compute the candidate
  sweep values in  $\lint{a}{a^{+} \Plus m_{\sigma}}$.

  For cells $x$ in $\lint{a}{a^{+}\Plus m_{\sigma}}$, let
  $\zeta.\cSweep(x) \gets \sigma$.
  This can change only island cells or
  shift the front to the left by a number of
  cells equal to the number of island cells
  encountered in this interval.

  For the addresses, we make use of the given
  pair $\g$.

  Suppose that $\g$ is defined, and assume
  that the drift is 1 (resp., -1).
  If $g_{1}$ (resp., $g_{-1}$) is not inside the
  workspace, then $g_{-1}$ (resp., $g_1$) is the front.
  Otherwise, $g_{1}$ (resp., $g_{-1}$) is the first cell
  of the right (resp., left) neighbor colony.


  Without loss of generality, we can assume that the drift is 1.

  If $a^{+} \Plus m_{\sigma} \ge b \Minus 0.3\E\B$
  then
  set $\hat \R \gets \R_{0}^{4}$.

  Similarly, if $g_1 > b \Minus 0.15\E\B$ then
  $\hat \R \gets \R_{0}^{2}$, and
  if $g_1 < a \Plus 0.15\E\B$ then
  $\hat \R \gets \R_{2}^{0}$.
  If the latter case is true and on top of it,
  $a^{+} \Plus m_{\sigma} \ge b \Minus 0.3\E\B$
  then
  set $\hat \R \gets \R_{2}^{4}$.

  If none of the previous holds, we set
  $\hat\R \gets \R$.
  In this case, we proceed as follows.

Computation of the sweep values does not depend
on the fact if the recovery interval covers a bridge.
We have assumed that the addresses run continuously in both
partitions of $\R^-$.

  We compute the candidate
  sweep in
  $\lint{a^{+} \Plus m_{\sigma}}{b^{-}}$.
  Let $\sigma'$ be the majority value of
  $\xi.\cSweep$ in $\lint{a^{+} \Plus m_{\sigma}\B}{b^{-}}$,
  where $b^{-} = b \Minus 3\Z\B$ %6\beta\B$
  (the majority exists, due to admissibility).

  Values of
  $\xi.\cAddr(x_i) - (i - 1)$ should be constant as $x_i$
  runs on the position sets of
  non-island workspace cells in all three partitions
  of $\R^{-}$.
  If $\g$ is defined,
  we set $\zeta.\cAddr$ starting
  from the right half of $\R$ and counting down to the front (that
  we will determine below).
  The addresses of the left partition are set starting
  from the left end, counting forward from $\alpha$ up to
  the front.

  If $\g$ is not defined, then
  let $\alpha'= \alpha(\lint{a^{+} \Plus m_{\sigma}\B}{b^{-}})$.

  For $x$ in $\lint{a^{+} \Plus m_{\sigma}\B}{b}$,
  set $\zeta.\cSweep(x) \gets \sigma'$.% and
%  $\zeta.\cAddr(x) \gets \alpha'+x-a$.
%  For  $x$ in $\lint{H}{b}$,
%  $\zeta.\cAddr(x) \gets \alpha'+x-a$
%  and $\zeta.\cKind(x) \gets \Neighbor$
  These again can only change island
  cells or possibly some cells due to
  the left shift of the front.

  In this way, the total number of cells changed
  is at most $3\Z$: %$6\beta + \Z$: at most $6\beta$
  in the islands and $3\Z + (\Z-\Z_b + \beta)$ due
  to the shift of the front.
\end{prooofi} %step:correction.inside.addr

    \begin{step+}{step:correction.inside.rest}
      Compute the remainder of $\zeta$.
    \end{step+}
    \begin{prooofi}
 Assume first $|\sigma'-\sigma| = 1$.%, that is
% two consecutive sweep values within a work period.

    \begin{step+}{step:correction.inside.rest.sweep}
      If $\sigma' < \sigma$, then set
      $\zeta.\front \gets a^{+} \Plus m_{1}\B$,
      $\zeta.\Sweep\gets \sigma$;
      otherwise
      $\zeta.\front \gets a^{+} \Plus (m_{1}-1)\B$,
      $\zeta.\Sweep \gets \sigma'$.
    \end{step+}


    \begin{step+}{step:correction.inside.rest.2}
      Suppose that $\min(\sigma,\sigma') \ge \TransferStart$.
    \end{step+}
    \begin{prooofi}


        Then all over $\hat \R$, set
        the $\zeta.\cDrift$ values to the majority
        of the $\xi.\cDrift$ values over $\R$.


        Consider the case when $\sigma$ is $\TransferSw(1)+1$.
        Suppose that the majority of $\cKind$ values to the
        right of the front is $\Neighbor$ (resp., $\Bridge$), and
        the addresses are $\geq Q$.
        If the front is not farther than $\Z\B$ from the
        base colony,
        then, we set $\cKind$ values of all
        the cells with $\zeta.\cAddr\geq Q$ and
        the value of $\zeta.\Kind$ to $\Neighbor$ (resp., $\Bridge$),
        and we set $\cKind$ values to $\Member$
        for all cells of the base colony.
        Otherwise, if the front is farther than $\Z\B$ from the front,
        $\cKind\gets \Bridge'$ for all
        cells whose $\zeta.\cAddr$ is at least $Q$ and
        is to the left of the front.


%      Further, all cells to the right of
%      the front up to $g_{-1}$ have
%      $\cKind = \Bridge$.
%      Finally, cells starting from $g_1$
%      and to its right, have $\cKind = \Neighbor$.
%      If $\g$ is not defined, then
%      all cells with $\cAddr < Q$ and all cells
%      to the right of the front have
%      $\cKind = \Member$.
%      Other cells, have $\cKind = \Neighbor$.


%  If $\zeta.\Sweep = \TransferSw(1)+1$, and
%  $\g$ is not defined,
%  then
%  we set $\zeta.\cKind$ to $\Neighbor$ to all
%  cells of $\hat\R$ not in the base colony.
  %to the right of the front, and
%  to $\Bridge$ to all other cells not belonging
%  to the base colony, if the majority of such cells
%  is $>3\beta_i$.
%  Otherwise, we set them to $\Neighbor$ all over.
%
  \end{prooofi}

%  Otherwise,
%  if $\min(\sigma,\sigma') \ge \TransferSw(1)$,
%  and $\g$ is at least $0.15\E$ cells inside
%  $\R$, then all cells to its right
%  must have $\zeta.\cKind = \Neighbor$, and
%  all cells not in the base colony must
%  have $\zeta.\cKind = \Bridge$.
%  The cells of the base colony will have
%  $\zeta.\cKind = \Member$.

%  Suppose that $\sigma = \Last(1)$, $\sigma' = \Last(1)-1$.
%  All the cells of the bridge
%  that are to the left of the front
%  will get $\cKind = \Stem$.
%  If $\hat\R$ contains $4\beta_i$ cells of
%  $\Bridge$ cells in a distance
%  of at most $4\beta_i$ cells from the
%  future base colony, we will
%  set $\cKind \gets \SideExt$ on all of them.


  Assume now that $\sigma,\sigma'$
  are the two values corresponding
  to the transition to a new work period.

  By assumption $\sigma = 1$; we set
  $\zeta.\front \gets a^{+} \Plus m_{\sigma}$.
  All cells to the left of the front must
  have $\zeta.\cKind = \Member $.
  All other cells get $\zeta.\cKind \gets \Neighbor$.

  The value $\chi.\cDrift$ has a constant value $\delta$ on $\R$.
  We can determine it using majority of
  $\xi.\cDrift$ over $\R^{-}$, and replace it all over $\hat\R$.


 \end{prooofi} % step:correction.inside.rest

\end{prooofi} % step:correction.inside


    Assume that the test~\ref{step:correction.inside} also fails:
    then $\R$ intersects the workspace without being
    essentially contained
    in it, or essentially disjoint from it.
    %From the four possibilities of
%    part~\ref{step:correction.cases} above,
%    now only these remained: one half of $R$ is
%    essentially covered by workspace cells
%    and the other one is not, or one half of $R$
%    is essentially covered by outer
%    cells and the other one is not.
%    We can therefore make, without loss of generality,
%    the following assumption:

    \begin{step+}{step:correction.fixed}
      Assume that the right half of $\R$ is not
      covered essentially (that is to within
      $3\Z$) by left outer cells %cells that are not $\Stem$.
      and that the left half is
      essentially covered by workspace cells. %, or the
%      right half is covered essentially by right
%      outer live cells.% that are not $\Stem$.
    \end{step+}
    \begin{prooofi}
      Let $m$ be the number of workspace cells of $\xi$ in $\R$.
      Then the intersection of the workspace with
      $\R$ must agree within $7\Z$ cells with
      $\lint{a}{a \Plus m\B}$,
      just as above in
      part~\ref{step:correction.inside.addr}.
      If $\g$ is defined, then it can be anywhere
      in $[a \Plus 3\Z\B, b \Minus 3\Z\B)$.
      If $\g$ is less than $0.15\E\B$ apart from $b$ (resp., $a$),
      then $\hat\R \gets \R_0^2$ (resp., $\hat\R \gets \R_0^2$).
      Otherwise, $\hat \R \gets \R$.

      Now we can carry out the computations of
      part~\ref{step:correction.inside}
      in the interval $\lint{a}{a \Plus m\B}$ in place of $R^{-}$.
      Since $m \ge 0.3\E - \Z$, there will be still
      sufficient cells left in this interval for the correct
      computation of the majorities.

      Once we have computed the correction of the
      non-outer part, we need to do the same for the
      outer part.

    We do this as follows.
    Suppose that $\dir(\zeta.\Sweep) = 1$.


    \begin{step+}{step:correction.fixed.growing}
        Suppose that $\zeta.\Sweep$ is a
        growing sweep.
    \end{step+}
    \begin{prooofi}
        Suppose first that the recovery interval intersects
        the yard.

        Then, we will set $\cVisSw$ to $\zeta.\Sweep$
        in all the cells behind
        the front, and set it to empty in all the cells
        of $\hat\R$ in its front.
        Similarly, we compute
        $\cVisAddr$ and $\cVisDrift$,
        as described in~\ref{sec:yarding}.

        If the right half contains at least
        $0.1\E\B$ non-stem cells towards its end.
        Then we compute the majority of $\cCore$ and
        set the values in these cells: they must
        be $\Last(-1)$, $\cDrift = -1$, and the addresses
        starting from $0$.
        The cells in between remain stem with their drift
        pointing to the base.
        Otherwise,
        when the right half does not end with at least
        $0.1\E\B$ non-stem cells,
        we set $\hat \R \gets \R_0^2$.


    \end{prooofi}

    \begin{step+}{step:correction.fixed.shrinking}
        Suppose that $\zeta.\Sweep$ corresponds to the
        transition to the new work period.
    \end{step+}
    \begin{prooofi}

        Suppose that the recovery interval
        intersects the colony yard on the left.
        Depending on the position of the front,
        we set $\cVisAddr$, $\cVisDrift$, and
        $\cVisSw$ in the cells of the yard that
        are behind the front to empty values.
%        The values for the front are computed according to
%        Lemma~\ref{lem:coord}.
        Then, we check if the left end of the left
        half of $\R$ has $0.1\E$ cells that are not stem.
        If yes, we compute the majorities of $\cAddr$,
        $\cSweep$, and $\cDrift$ in this stretch, and
        set $\cAddr$ of this stretch such that the rightmost
        ends with $Q-1$.
        Then,
        $\cSweep$ is set to $\Last(1)$, and $\cDrift$ to 1,
        in all cells of this stretch.
        If the size of this stretch of cells that are
        not stem is less than
        $0.1\E\B$, then we set $\hat\R \gets \R_2^0$.

        If the recovery interval does not intersect the
        yard, then we set the $\cCore$ values of the cells
        to the left of the front
        by computing their majorities in the usual way: all
        these cells are outer.

    \end{prooofi}
   \end{prooofi} % step:correction.grow-shrink

    \begin{step+}{step:correction.leaving-the-head}
      Where to leave the head once the recovery completes?
    \end{step+}
    \begin{prooofi}
        In case that
        $\hat\R \in \set{\R, \R_0^2, \R_2^0}$, the head will be left
        at the position of the front.

        If $\hat\R \in \set{\R_2^4, \R_0^4}$,
        then the head will be left at the right end of
        $\R$.
        If $\hat\R \in \set{\R_4^0, \R_4^2}$,
        then the head will be left at the left end of
        $\R$.
    \end{prooofi}

    It is straightforward to check that the conditions
    of the lemma guarantee that the construction of $\zeta$
    and the rule itself
    have the properties claimed in the lemma.
\end{Proof}




Later we will see that the procedures that use
the algorithm from Patching Lemma~\ref{lem:patching}
will have their own structures in terms of
certain designated fields of the state.
Similarly to $\Addr$ and $\cAddr$ fields of the state
and tape, respectively,
recovery procedure and the rebuild procedure that
we will introduce later will have their own
addressing.
Hence, we can always express a position of a cell
of interest relative to these addresses.


We can aggregate all information
that define $\zeta$ in the following
tuple.

\begin{definition}[Correction data]\label{def:correction-data}
  The following information
    \begin{align*}\Delta = (s,\alpha,\alpha',\sigma,\sigma',
      \delta,\f, \ga)\end{align*}
  incorporates all the data defining the corrected healthy
  local configuration $\zeta(\hat \R)$, provided that
  $\R$ and an addressing on it is given:
  \begin{bullets}
    \item
      $s\in\{-4, -2, -1,0,1, 2, 4\}$ says which of the seven
      alternative values of $\R_0^4$,$\R_2^4$, $\R_2^0$, $\R$, $\R_0^2$, ,
       $\R_4^0$, $\R_4^2$ does $\hat \R$ have.
    \item
      $\alpha,\alpha',\sigma,\sigma'$ help computing
      the address and sweep values as seen in the proof
      of the Patching Lemma~\ref{lem:patching}.
    \item
      $\delta$ is the $\cDrift$ value shared by all
      elements of the workspace inside $\hat \R$
      in case $\sigma\ge\TransferStart$ or $\sigma = 1$.
    \item
      $\f = \front(\zeta) - a$ in case $\hat\R \in \set{\R, \R_0^2, \R_2^0}$.
    \item $\ga$ is a pair of two address values of some fixed
    addressing established in $\R$, that
    correspond to
       the pair of cells that are non-adjacent or
        have an address jump.
  \end{bullets}
\end{definition}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% Chapter RECOVERY mechanisms
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\include{sec-recovery}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Resisting Isolated Bursts of Faults}
\label{sec:1-level-noise}


In this chapter, we
show that as long as the head remains
inside $A$,
within a certain distance from its borders,
from an admissible configuration our machine
transitions to admissible configuration, provided
that no large bursts occur.

We first need to extended the notion of
annotations to histories by
defining the notion of an annotated history, and
then we show how a trajectory $\eta$ of machine $M$,
can be annotated.

This is a more general treatment
of the results presented in~\cite{Bursts}, as herewith,
we do not require that the recovery interval
satisfies a certain property.







\section{Annotated history}

%Let us analyze the kind of histories that
%are possible when the operation of a machine
%$M$ is subjected to $(\beta, V)$- bi- bursts.

Recall the definition of history in
Definition~\ref{def:history} and
trajectory in Definition~\ref{def:traj}.

In our analysis, we will focus
on only small fragments of histories.

\begin{definition}[History and trajectory snippets]\label{def:snippets}
	For a given $t, k \in \bbZ_{+}$,
	a subsequence $\eta(t), \eta(t+1),$ \dots $\eta(t + k)$
	of a history $(\eta, \Noise)$
	is called a \df{history snippet of size $k$ that starts at $t$}.
	Further, if $(\eta, \Noise)$ is a trajectory, then
	it is called a \df{trajectory snippet of size $k$ that starts at $t$}.
\end{definition}


Recall the definition of (possibly centrally consistent)
annotated configuration on an interval $A$ given
in Definition~\ref{def:annotated-config}.
In such a configuration, a cell is free when it does not
belong to an island or to the distress area.
We also said that the head is free if the distress area is empty.


\begin{definition}[Annotated history]\label{def:annotated-hist}
Let $\tau = [t, t+k)$, for $t, k\in\bbZ_{\geq 0}$, $k>0$,
and let $A$ be a space interval.

    An \df{annotated history} of
     \begin{align*}
        M=\left(\Gamma,\Sigma,\delta,q_{\start},F,B,\Tu{}\right),
     \end{align*}%\; i\in \bbN$$
     on a space-time rectangle
     $A\times \tau$,
    is a sequence of $k$ annotated configurations on a nonempty space
    interval
    $A$,
    if its sequence of underlying configurations is a
    trajectory snippet of size $k$ starting from $t$ of
    $\eta$, % \Noise)$, where $\Noise$ consists of $(\beta, V)$-bursts,
    and it satisfies some additional requirements given below.

    Let
    \begin{align}\label{eq:cB}
      \cB  %= \frac{6\E}{Q}
    \end{align}
    denote a constant value that we will
    define later that we call the \df{damage attraction range}.

    We require that for each $t$, the head never
    comes closer than $\cB$ to the endpoints of $A$.

    If the head is in a free cell, in normal mode, then
    the time (and the configuration) will be called
    \df{distress-free}.
    If the annotated configuration at a certain time
    is centrally consistent, then we call
    that time \df{centrally consistent}.
    A time that is not distress-free and was preceded by
    a distress-free time
    will be called a \df{distress event}.

    Consider a time interval $\lint{t_1}{t_1+u}$ starting
    with a distress event and ending with the head
    becoming free again.
    It is called a \df{relief event} of \df{duration} $u$
    if the only possible islands that remains from the distress area
    are due to some burst
    that occurred at a time intersecting $\lint{t_1}{t_1 + u}$.
    Moreover, if such islands
    exist, then the sweep direction from before the
    distress event is preserved, except when the island is
    outside the extended base colony---then it will be reversed.

    The \df{extent} of a relief event is the maximum size
    interval covering the distress area during the distress.

    Recall the definition of the parameter
    $\K_\R$ in~\eqref{eq:K_R}.
    The additional requirements for annotated history are:

    \begin{enumerate}[(a)]

        \item \label{i:annotated-hist.progress}
            Islands (whose size do not exceed $\beta\B$)
            are only created
            by bursts.
            Distress area starts out as islands.

       \item \label{i:annotated-hist.damage-progress}
            Islands  have
            a \df{progress indicator} that is increased
            each time the head steps in it and dwells in it,
            until it becomes damage-free.
            In the latter event, we say that the indicator is
            \df{expired}.

            Islands of size $\leq \beta$,
            may increase in one side
            for at most $\loc\B$ in one side only.


        \item\label{i:annotated-hist.distress}
            Each distress event
            %due to stepping onto an existing island, or due to a burst,
            within at most $2\Z$ steps is followed by a relief event,
            of duration of $\le  5(\beta\Zg(\loc,\Z, \Z_b)+\K_\R)\Tu{}$
            and extent $<4\E\B$.



        \item\label{i:annotated-hist.stain}
            If a distress-free configuration has
            $\Sweep \ge \TransferStart$,
            then the base colony contains no stains
            from earlier work periods.
        \end{enumerate}
\end{definition}


%In this section, we will only consider how machine $M_1$
%copes with $(\beta, V)$-bursts.
%Once we establish that the simulated history is
%a trajectory, then we will consider the case
%on how $M_i$ recovers from $(\beta_i, V_i)$-bursts.


%\begin{definition}[The range of a sweep]\label{def:sweep-range}
%  Consider an annotated history $\eta$ on some space-time rectangle
%  $A \time \tau$.
%  A \df{range of a sweep} $s$ in $\eta$ on $A\time \tau$
%  is the interval
%  $[a,b]\subseteq A$ that contains the position of the head
%  of satisfying healthy  configurations of $\eta(t)$, ($t>0$)
%  whose $\Sweep = s$%,
%  %the distress area is empty,
%  and $t \notin \Noise$.
%\end{definition}
%
%\begin{remark}[On the range of a sweep]
%   With some abuse of the previous definition, we will
%   usually use only the term ``a range of a sweep $s$''
%   instead of a ``range of a sweep $s$ in $\eta$ on a space-time
%   rectangle''.
%
%   However, there will always be
%   an underlying history that we are considering, and we
%   assume that we are referring to that one.
%   Otherwise, we will specify the underlying annotated
%   history  explicitly.
%\end{remark}





\subsection{The outline of the chapter}

 In this chapter, we will show how
 any trajectory
 $(\eta, \Noise)$ %}, \Damage^{(i)})$ of
 of a generalized Turing machine $M$ %_i$, for $i\geq 1$,
 that is annotated on a large interval $I$, remains annotated
 as long as no larger bursts than $\beta\B$ occur and the
 head does not leave $I$.

 The main part of the proof is about obtaining a relief
 after a distress event.
 Unlike in~\cite{Bursts}, in this work, islands here
 may have their cell structure damaged.
 Hence, when the head is in an island for a certain
 time, we cannot talk immediately about the cells in it
 and their structure.
 However, since $\eta$ is a trajectory,
 many passes over an island and a certain amount of time
 that the head spends in it, will guarantee that
 soon, we will be able to talk in terms of cells of $M$.
 This means that the relief consists of two stages: (1)
 damage-removal, and (2) correcting their structure.


% To show how a relief is obtained, we will first show that whenever
% alarm is called in a distress area that does not contain
% any damage and is isolated from it, it will shrink, provided
% that no bursts occur.

 Recall that in Definition~\ref{rem:noise-and-noise*} we
 agreed that following the spirit stemming from the notation of
 coding and decoding, we will denote
 by $M^*$ the simulated machine, $(\eta^*, \Noise^*)$ will
 be its trajectory.
 Similarly, in case the want to refer to the machine that simulates
 machine $M$, we would use $M_*$ notation.




\section{Damage-free recovery}\label{sec:undisturbed}


The idea of the proof of relief is the following.
If alarm is called and the recovery process is allowed to complete,
that is, no damage is encountered or no bursts occur throughout,
then it carries out the needed correction, as guaranteed by the
Lemma~\ref{lem:patching}.
%Most complications are due to the fact that the
%state becomes arbitrary whenever a burst occurs,
%or whenever the head steps in damage.

In an annotated history,
when the mode is normal then zigging will make sure that
the effect of a burst is limited to near the island where the burst
happened: for example, the direction of a sweep
cannot be changed in the middle of the workspace,
since then zigging would notice this and call alarm.



Recall the definitions of the constants $\K_\R$
in~\eqref{eq:K_R} and $\Z$ in~\eqref{eq:Z}, and
the notation of $\Plus$ and $\Minus$ introduced
in~\ref{not:oplus-rho-ominus}.

From now on, suppose that $A$ and $\tau$ are two
sufficiently large space and time intervals, respectively.


\begin{lemma}[One-way alarm]\label{lem:alarm1}
    Suppose that in an annotated history on $A\times \tau$,
    where $A$ contains no damage,
    alarm sounds at a time $t_0$,  when
    the head is not farther than $(0.75 + k)\E\B$,
    for $k\in\set{0,1,2}$ in direction
    of $\dir(\chi.\Sweep)$
    from the front
    of a healthy configuration $\chi$.
    Suppose further that no distress areas exist within a distance
    of $(\E + \Rec.\Z_b)\B$ from the head in the direction of
    $\dir(\chi.\Sweep)$, and that
    no distress area stretches for more than $\Rec.\Z_b\B$
    in the direction
    $-\dir(\chi.\Sweep)$ from the $\chi.\front$.
    %, and
%    that at least the first $0.8\E$ cells from the head
%    towards the front are non-vacant.

    Suppose also that no bursts occur
    in the next $(k+1)\K_{\R}$ steps.
    Then the annotation of
    the history on $A \times \tau$
    can be extended so that relief comes in fewer than
    $(k+1)\K_{\R}$ steps, while the size of the distress
    area does not grow more than $(k+2)\E\B$ before it disappears.
\end{lemma}

\begin{Proof}
    Assume that the conditions of the lemma hold.
    Let $x_k$, for $k=0,1,2$
    denote the position of the head at
    moment $t_0$ when alarm is called.
    In what follows, we will sometimes refer to
    $\chi.\front$ of this moment as just the \df{front}.

    Without loss of generality, assume that the
    direction of the sweep of a satisfying healthy
    configuration is 1.

    Let us follow the
    recovery procedure, to show how the relief is
    achieved.

    \begin{step+}{step:alarm1.k=0}
       Suppose that $k=0$.
    \end{step+}
    \begin{prooofi}
       Since there are no further bursts, and $A$ is damage-free,
       the recovery procedure proceeds without interruptions
       and opens
       recovery interval
       $\R = [x_0 \Minus \E\B , x_0 \Plus \E\B)$ that contains
       the front fully (that is, within $0.25\E\B$) inside.

       Then,  Patching Lemma~\ref{lem:patching}
       implies $\hat{\R} \in \set{\R, \R_0^2, \R_2^0}$.
       This means that the mopping stage of the
       recovery will be done from both sides.
       Since there are no leftover distress areas
       in a $\Rec.\Z_b\B$-ring (for a definition of a ring
       see~\ref{sec:notational-conventions}) around
       $\R$, both mopping stages will be completed, which
       brings the desired relief.
    \end{prooofi}

    \begin{step+}{step:alarm1.k=1}
       Suppose that $k=1$.
    \end{step+}
    \begin{prooofi}
        Let $x_1$ be the position where alarm is called.
        If $x_1 - \chi.\front\leq 0.75\E\B$, then
        part~\ref{step:alarm1.k=0} is applicable.

        Suppose that $0.75\E\B < x_1 - \chi.\front \leq 1.75\E\B$.
        Then the distance of $x_1 \Minus \E\B$ from the
        front is $<0.25\E\B$.
        Hence, the recovery interval
        $\R'= [x_1 \Minus \E\B, x \Plus\E\B)$
        does not contain the front
        fully inside.


        %Suppose that the left half of $\R'$ has at least
%        $\E - 6\beta$ nonempty cells.

        Then, Lemma~\ref{lem:patching} implies
        that $\widehat{R'} \in \set{(\R')_4^0, (\R')_4^2}$.
        This means that mopping is always done from
        the right to the left, during which process,
        the head will zig
        outside to the right of $\R'$.
        We have assumed that there are no distress areas
        on this $\Rec.\Z_b\B$- stripe next to $\R'$.
        Once all marks from $\widehat{R'}$ are removed,
        the head is left at $x_1 \Minus\E\B$, where alarm is called.
        This brings us to the case $k=0$, so
        we apply part~\ref{step:alarm1.k=0}.



        %Suppose now that the $\Calc$ rule fails on $\R'$
%        since it contains mostly empty cells.
%        Then, $\GiveUp$ is called at $x_1$.
%        The rebuild cover centered at $x_1$ with radius
%        $4.3\E\B_i$ is opened.
%        Since the cover contains
%        completely distress area and the front, and since
%        the history was
%        annotated before the alarm was called at $x_1$,
%        the rebuild procedure will fill the islands
%        on the left side
%        of the cover (which must be nonempty as guaranteed by
%        anotatedness)
%        with the
%        $\cCore$ values computed by $\Calc$ during the rebuild procedure.
%        Finally, once the marks are removed,
%        the mode is switched to normal.

    \end{prooofi}

    \begin{step+}{step:alarm1.k=2}
       Suppose that $k=2$.
    \end{step+}
    \begin{prooofi}
        Suppose that alarm is called at $x_2$.
        If $x_2 - \chi.\front\leq 1.75\E\B$, then
        part~\ref{step:alarm1.k=1} is applicable.

        Suppose now that
        $1.75\E\B < x_1 - \chi.\front \leq 2.75\E\B$,
        then
        $\R'' = [x_2 \Minus \E\B, x_2 \Plus \E\B)$ does not
        contain the front.

        Patching Lemma~\ref{lem:patching}
        implies that
        $\widehat{\R''}\in \set{(\R'')_4^0, (\R'')_4^2}$.
        Since we assume that to the right of $\R''$ there
        is no further damage, the mopping --- which starts
        at the right end --- removes all the marks from
        $\widehat{\R''}$, and leaves the head on the
        left end of $\R''$ where alarm is called.
        Now, case~\ref{step:alarm1.k=1} is applicable.

%        Suppose that the conditions of the Patching Lemma~\ref{lem:patching}
%        are not satisfied.
%        Then, rule $\Calc$ will fail, which means that
%        $\GiveUp$ is called at $x_2$.
%        Since
%        $|x_2 - \chi.\front|\leq 2.75\E\B_i$,
%        the rebuild cover will contain properly
%        the front and the distress area to its left.
%        Now, the rest of the argument is identical
%        to the one in the last paragraph
%        of part~\ref{step:alarm1.k=1}.
    \end{prooofi}

     % The analysis of case $k=3$ is done similarly.
\end{Proof}


Now, we apply the previous lemma to prove a more general version of
it, when alarm can be called further inside
distress area.


\begin{lemma}[Alarm]\label{lem:alarm}
    Suppose that in an annotated history on $A\times \tau$,
    alarm sounds at a time when
    the head is not farther than $(k\E + 2\Rec.\Z_b)\B$,
    for $k\in\set{1,2}$
    from the front
    of the healthy configuration $\chi$.%, in direction
%    of $\dir(\chi.\Sweep)$.

    Suppose further that %$A$ contains no damage and
    damage-free distress area does not stretch for more
    than $2\E\B$ from the head in the direction of
    $\dir(\chi.\Sweep)$, and
    more than $2.1\E\B$
    in the direction
    $-\dir(\chi.\Sweep)$ from the the front.
    %, and
%    that at least the first $0.8\E$ cells from the head
%    towards the front are non-vacant.

    Suppose also that no bursts occur
    in the next $4\K_{\R}$ steps.
    Then the annotation of
    the history on $A \times \tau$
    can be extended so that relief comes in fewer than
    $5\K_{\R}$ steps,  while the size of the distress
    area does not grow more than $3\E\B$ before it disappears.
\end{lemma}

\begin{Proof}
    Assume that the conditions of the lemma hold.
    Without loss of generality, assume that the
    direction of the sweep of a satisfying healthy
    configuration is 1.

    Let $l, r\in\set{0,1}$ denote
    the presence of the distress area
    to the left of $x\Minus \E\B$
    and to the right of $x \Plus \E\B$, respectively,
    where $x$ is the position where alarm is called.

    \begin{step+}{step:alarm.k=0}
       Suppose that the head is within a
       distance of $0.75\E\B$ from the front.
    \end{step+}
    \begin{prooofi}
        \begin{step+}{step:alarm.k=0.l=0.r=0}
           Suppose that $l,r=0$.
        \end{step+}
        \begin{prooofi}
            Then, Lemma~\ref{lem:alarm1} implies
            our claim.
        \end{prooofi}

        \begin{step+}{step:alarm.k=0.l=0.r>0}
           Suppose that $l=0$, $r>0$.
        \end{step+}
        \begin{prooofi}
            As the recovery interval $\R$ contains
            the front fully inside, mopping is done
            in both sides.
            However, as $l=0$, and $r>0$,
            while performing the mopping sweep
            from the right side,
            alarm is called at a point
            \begin{align*}x_0 \in
            \chi.\front \Plus (0.25\E\B, 1.75\E\B].\end{align*}

            Then, as the recovery procedure in the absence of
            bursts, and
            in the absence of damage runs
            without interruptions over the new
            recovery interval $\R'$ centered
            at $x_0$, the mopping stage is reached.

            If $x_0 \Minus [\E\B, (\E + \Rec.\Z_b)\B)$ is free,
            then all the marks of $\widehat{\R'}$
            are removed and a new alarm is called at
            $x_0$.
            Now, Lemma~\ref{lem:alarm1} applies.

            If $x_0 \Plus [\E\B, (\E + \Rec.\Z_b)\B)$ is not distress-free,
            alarm is called
            at \begin{align*}x_1 \in x_0 \Plus [\E\B, (\E + \Rec.\Z_b)\B).\end{align*}
            As to the right of $x_1 + \E\B$ there are no
            other parts of the distress area,
            the recovery succeeds and the mopping is done
            from right to the left, as the front is
            not fully in this recovery interval.
            Then, alarm is called at $x_0$.
            Now the case from the previous paragraph applies.
       \end{prooofi}


        \begin{step+}{step:alarm.k=0.l>0.r=0}
           Suppose that $l>0$, $r=0$.
        \end{step+}
        \begin{prooofi}
            This case is handled symmetrically as
            the case~\ref{step:alarm.k=0.l=0.r>0}
        \end{prooofi}

        \begin{step+}{step:alarm.k=0.l>0.r>0}
           Suppose that $l>0$, $r>0$.
        \end{step+}
        \begin{prooofi}
            Without loss of generality assume that
            the front is on the left half of the
            recovery interval.
            Then, the mopping starts from the right end.
            As to the right of $\R$ distress area exists,
            alarm is called while zigging there.
            Now, using the same argument as in the
            case~\ref{step:alarm.k=0.l=0.r>0}
            we obtain that a new alarm is called close to $x$.
            Recovery interval opened now does not have
            any marked cell to its right, but as $l>0$, it does
            to its left, and
            hence, we apply case~\ref{step:alarm.k=0.l>0.r=0}.
        \end{prooofi}
    \end{prooofi}

    \begin{step+}{step:alarm.k>0}
       Suppose that $x$ is farther than $0.75\E\B$ from the front.
    \end{step+}
    \begin{prooofi}
        Observe that whenever $x$ is more than $0.75\E\B$
        to the right of the
        front, and some distress area exists
        to the right of the recovery interval,
        alarm is called there.
        This is because the front is not fully in $\R$, and
        the (only one) mopping sweep starts from the right side,
        in which case, zigging brings the head over the marked cells.
        This process of opening recoveries to the
        right, will continue further until a recovery
        interval that is clear of distress on its
        right is opened.

        Then, Patching Lemma~\ref{lem:patching} implies that
        $\hat\R \in \set{\R_4^0, \R_4^2}$.
        %For this interval,
%        suppose that the conditions of Patching Lemma~\ref{lem:patching}
%        are satisfied.
        Hence,  as mopping succeeds, all the marks from the right
        are removed, and then we hit marked cells on the left, which
        causes alarm.
        We repeat this again and again, so we get  closer and
        closer to the front, hence using the cases for
        smaller $k$.

        %Suppose that for this interval the conditions of
%        Patching Lemma~\ref{lem:patching} are not satisfied.
%        Then the rebuild procedure is initialized, and the rebuild
%        cover will contain entirely
%        the complete distress area and the front.
%        Indeed, we are removed for at most $(3\E + 8\beta)\B_i$
%        from the front and to the left of the front,
%        the distress area cannot stretch for more than $1.1\E\B_i$.
%        Since the radius of the cover is $4.3\E$, the front is contained
%        in it.


        The case when $x$ is more than $0.75\E\B$ to the left
        of the front is analyzed similarly.

    \end{prooofi}



 \end{Proof}



%
%\begin{Proof}
%    Assume that the conditions of the lemma hold.
%    Without loss of generality, assume that the
%    direction of the sweep of a satisfying healthy
%    configuration is 1.
%
%
%    \begin{step+}{step:island.k=1}
%       Suppose that $k=1$.
%    \end{step+}
%    \begin{prooofi}
%       Since there are no further bursts,
%       the recovery procedure proceeds without interruptions
%       and opens
%       recovery interval
%       $\R = [x_1-\E\B_i , x_1 + \E\B_i)$.
%
%        \begin{step+}{step:island.k=1.0.75}
%           Suppose that $x_1$ is within $0.75\E\B_i$ from
%           the front, on its right side.
%        \end{step+}
%        \begin{prooofi}
%           Then, $\R$ contains
%           the front fully (that is within $0.25\E\B_i$) inside.
%           Then,  Patching Lemma~\ref{lem:patching}
%           implies $\hat{\R} \in \set{\R, \R_0^2, \R_2^0}$.
%           We have assumed that the direction of the sweep
%           of $\chi$ is 1, therefore
%           mopping will start from the right end.
%           The first mopping stage therefore will remove all
%           the marks up to the front.
%           Then, the second mopping stage begins, and while zigging,
%           the head steps to the left of $x_1 - \E\B_i$.
%           If no marked cells exist in this stretch of
%           $4\beta$ cells, then all the marks get removed,
%           the distress area cleaned, and hence relief is obtained.
%           Otherwise, if a marked cell is found here,
%           then alarm is called at $x_0$, where
%           $(0.25\E + 4\beta)\B_i <    |\chi.\front - x_0|
%                                 \leq  (1.75\E + 4\beta)\B_i$.
%
%           There is no island or distress area to the left of the
%           new recovery interval $\R' = [x_0 - \E\B_i, x_0 + \E\B_i)$.
%           If this interval contains the front fully,
%           then no distress areas exist to its right as well.
%           Hence, Lemma~\ref{lem:alarm1} implies the desired relief.
%
%           Otherwise, as Patching Lemma~\ref{lem:patching} implies
%           that $\widehat{\R'} \in \set{(\R')_0^4, (\R')_2^4}$,
%           alarm is called on the right side of $\R'$ as
%           the head is surrounded by marked cells.
%           Now, the case from the previous paragraph applies.
%
%       \end{prooofi}
%
%       \begin{step+}{step:island.k=1.0.75-left}
%           Suppose that $x_1$ is within $0.75\E\B_i$ from
%           the front, on its left side.
%        \end{step+}
%        \begin{prooofi}
%            Suppose that
%              $x_1 - \E\B_i < \chi.\front - 1.1\B_i$.
%
%            Then, there is no distress area to the left
%            of the recovery interval centered at $x_1$.
%            Hence, since the front is on the right side,
%            no alarm is called to the left of $x_1 - \E\B_i$
%            when zigging outside of the recovery interval
%            occurs in the first mopping stage.
%            If no distress area exist to the right of
%            $x_1 + \E\B_i$, then relief is obtained.
%            Otherwise, alarm is called on a cell
%            $x_0$ that is at most $(\E + 4\beta)\B_i$ from
%            the front.
%            If the new recovery interval $\R' = [x_0-\E\B_i, x_0\E\B_i)$
%            contains the front fully inside, then relief is achieved
%            since to the left of the front no marked cells
%            exist.
%            Otherwise, as Patching Lemma~\ref{lem:patching}
%            implies that
%            $\widehat{\R'}\in\set{(\R')_4^0, (\R')_4^2}$,
%            once all the marks are removed from
%            $\widehat{\R'}$,
%            alarm is called in a $\beta_i$ neighborhood
%            of $x_0'-\E\B_i$.
%            Now, Lemma~\ref{lem:alarm1} applies.
%
%            Suppose that
%              $x_1 - \E\B_i$ is to the right of $\chi.\front - 1.1\B_i$.
%            Then, as the recovery interval $\R$ centered
%            at $x_1$ contains the front fully,
%            by Patching Lemma~\ref{lem:patching}we have
%            $\hat{\R}\in\set{\R, \R_0^2, \R_2^0}$.
%            Since the front is on the right side,
%            the mopping begins from the left endpoint of $\R$.
%            If while zigging to the left of $\R$ no alarm
%            is called, then the previous case is applicable.
%            Otherwise, alarm is called there on a cell
%            $x_1'$ that is at most $(\E + 4\beta)\B_i$
%            to the left of $x_1$.
%            Recovery interval $\R'$ centered at $x_1'$ does not
%            contain the front.
%            Therefore, by Patching Lemma~\ref{lem:patching}
%            $\widehat{\R'}\in\set{(\R')_0^4, (\R')_2^4}$.
%            Once the recovery begins and all the marks from
%            $\widehat{\R'}$ are removed, alarm is called
%            as the head is left among the marked cells.
%            Now, as the damage to the left of the front
%            is cleared,
%            we apply the case from the first paragraph.
%        \end{prooofi}
%
%
%       \begin{step+}{step:island.k=1.>0.75}
%           Suppose that $x_1$ is not within $0.75\E\B_1$ from
%           the front.
%       \end{step+}
%       \begin{prooofi}
%           If the conditions of Lemma~\ref{lem:patching}
%           are not satisfied (and hence $\Calc$ fails)
%           since $\R$ does not have at least $\E - 3\beta$
%           nonempty cells on the left half,
%           then healing is initiated at
%           $x_1$.
%           The healing cover, centered at $x_1$ will cover
%           entirely the distress area.
%           Then, the healing procedure will apply $\Calc$ over
%           the left side of the cover, where the conditions
%           of the Lemma~\ref{lem:patching} are satisfied
%           since the history is annotated.
%           Then the same lemma implies that all the
%           changes on the tape are admissible.
%
%           Suppose that the conditions of Patching Lemma~\ref{lem:patching}
%           are satisfied on $\R$.
%
%           \begin{step+}{step:island.k=1.>0.75.right}
%             Suppose that $x_1$ is to the right of the front.
%           \end{step+}
%           \begin{prooofi}
%               Since $\R$ does not contain the front fully,
%               then during the mopping stage, marks
%               will be removed from the right end
%               until $0.25\E\B_i$ from the left endpoint,
%               and then the mode is switched to normal.
%               Since the head is surrounded by
%               marked cells, alarm is called at a cell
%               $x_1'$, and now
%               case~\ref{step:island.k=1.0.75} is applicable.
%           \end{prooofi}
%
%           \begin{step+}{step:island.k=1.>0.75.left}
%             Suppose that $x_1$ is to the left of the front.
%           \end{step+}
%           \begin{prooofi}
%               Then, $\hat\R \in \set{\R_0^4, \R_2^4}$.
%               Since $\chi.\front - 1.1\E\B_i$ belongs
%               to $\R$, then while mopping outside, to the left
%               of $\R$ no marked cells exist.
%               Alarm is called only, once the recovery
%               finished to the right of $\R$.
%               Now, part~\ref{step:island.k=1.0.75} is applicable.
%           \end{prooofi}
%       \end{prooofi}
%   \end{prooofi}
%
%
%    \begin{step+}{step:island.k=2}
%       Suppose that $k=2$.
%    \end{step+}
%    \begin{prooofi}
%        Once alarm is called at $x_2$,
%        recovery interval $\R = [x_2-\E\B_1, x_2+\E\B_1)$
%        is opened.
%        If the distance of $x_2$ and the front is
%        less than $(\E + 8\beta)\B_i$,
%        then case $k=1$ applies.
%
%        Suppose that for this interval the conditions of
%        Patching Lemma~\ref{lem:patching} are not satisfied,
%        then the healing is initialized, and the healing
%        cover centered at $x_2$ will cover entirely
%        the complete distress area and the front.
%        Indeed, we are removed for at most $(2\E + 8\beta)\B_i$
%        from the front and to the left of the front,
%        the distress area cannot stretch for more than $1.1\E\B_i$.
%        Since the radius of the cover is $3.3\E$, the claim follows.
%
%        Suppose that the conditions of Patching Lemma~\ref{lem:patching}
%        are satisfied.
%
%        Consider the case when $x_2$ is to the right of the front.
%        Then, it implies that $\hat{\R} \in \set{\R_4^0, \R_4^2}$.
%        No further distress areas exist to the right of $\R$, hence
%        since the mopping starts from the right to the left,
%        all the marks of $\hat\R$ are removed,
%        and alarm is called at a cell
%        $x_1'$ which brings us to the case $k=1$.
%
%        Consider the case when the head is to the left of the front.
%        Then, as $x_2<\chi.\front - 1.1\E$,
%        no distress area exist to the left of the recovery
%        interval.
%        Hence, since $\hat\R \in \set{\R_0^4, \R_2^4}$,
%        alarm is called at a cell $x_1'$ which
%        brings us to the case for $k=1$.
%    \end{prooofi}
%
%\end{Proof}




\section{Dealing with islands of damage}

Our definition of trajectory in Definition~\ref{def:traj}
admits non-deterministic behavior
even when the head of a generalized Turing machine
is close to damage.
Namely, when the head of a generalized Turing machine $M$,
is on a cell within a distance $0.5\B$ from damage,
then even if by the program it was not supposed to step
on it, the head may do so. \footnote{Clearly, this happens only
due to a fault of the simulating environment.}
Furthermore, unlike a classical Turing machine (see Definition~\ref{def:TM}),
whose head when it steps inside an island
changes the state according to the program,
the head of a generalized Turing machine
changes the state to an arbitrary one.
Let us call this the \df{seizure} effect.

%Let us specify the minimal distance of the head
%of a generalized Turing machine from the damage, such that
%the head does not step in the damage ``involuntarily''.


%\begin{definition}[Damage attraction range]\label{def:damage-attraction}
%%Consider an annotated configuration $\xi$ on an interval $A$,
%%and assume that $\xi.\D = \emptyset$.
%
%, that is
%the number such that $\cB\B$ represents
%the smallest distance between the head
%and a damaged interval $I$
%such that no $(\beta_*, V_*)$-bi-burst,
%can cause the head of $M$ to step on $I$
%in a time
%period where no $(\beta, V)$-bi-bursts occur.
%
%%Since $\cB(i)$ goes hand in hand with $\B_i$, even though it is not
%%technically correct,
%%we will
%%omit writing the argument $i$ from $\cB(i)$ whenever possible.
%%For example, we will write $\cB\B_i$ instead of $\cB(i)\B_i$.
%\end{definition}


What happens when the head of $M$ steps in an island?
As $\eta$ is a trajectory, Definition~\ref{def:traj} guarantees
that as long as the head stays
for a certain amount of time (not necessarily in a continuous interval)
in small fragments of the island, these fragments become damage-free.
%As the state of the machine changes non-deterministically while
%the head is in an island of damage, the head may leave the island.
If we sweep the island many times, then we can be sure
that all the damage from it is removed, as the damage is attacked each
time from the parts that are not damaged.
What guarantees that the head does not stay inside an island forever?
The answer is in the program of machine $p$, in particular, because it
satisfies the feathering property (see Definition~\ref{def:feathering}).
%Further, whenever a damage of size $>\B$ is removed and a cell is created,
%according to Definition~\ref{def:generic},
%alarm will be called.

Finally, how to guarantee that the head indeed
sweeps the island many times?
Besides the assumption that alarm will be called on
a cell that is relieved from damage,
we enforce this by setting
of the parameters $\Z$, $\Z_b$, $\Rec.\Z$,
and $\Rec.\Z_b$ (see~\eqref{eq:Z} and~\eqref{eq:Rec.Z}),
defining the movement of the head
during zigging in a way that
the head visits the island needed amount of times.
We will determine appropriate values of $\Z$, $\Z_b$, $\Rec.\Z$,
and $\Rec.\Z_b$, later.
Further, admissibility guarantees that if recovery starts
already around the island, markings on the tape do not
allow the machine to proceed further without removing these marks.
But the marks can be removed only by the recovery procedure,
that first needs to open its recovery interval.
Hence, while trying to open the recovery interval, the
head will enter in the island sufficient number of times, and
dwell enough time in it so it becomes damage-free.



Let us first consider the case when
the head steps in an island during the simulation.
As we will see, the simulation may continue seamlessly and
the damaged island may remain there (with the indicator increased),
or the island will be removed.


\begin{lemma}[Island covering]\label{lem:damage-cover}
    Suppose that $\eta$ of $M$
    is annotated on a space-time rectangle $A\times \tau$, where
    $A$ is an interval of size greater
    than $2Q\B$.
    Suppose that at a distress-free time $t_0$, the head of $M$ steps
    inside an interval $I$ that contains damage,
    $|I|\leq 3(\loc+\beta+\cB)\B$.
%    Let  $|I|\leq \beta\B_i$, %($c\geq 1$),

    Assume that in a distance of
    $(\E +\Rec.\Z_b) \B$ from $I$,
    %a damage-free distress area $I_1$ of size  may exist,
    %but
    no other islands of damage exist in a distance
    of %$(\E + \Rec.\Z_b + \cB) \B$
    $(\loc + \cB)\B$
    from their union.

  Then, for an appropriate choice of constants $\Z$ and $\Z_b$,
  assuming that no further %$(\beta_j, V_j)$-bursts
  bursts occur within the next $2\beta\Zg(\loc,\Z, \Z_b)$ steps of $M$,
  at some time $t$, such that $t>t_0 + 2\beta\Zg(\loc,\Z, \Z_b)\Tu{}$,
  either $I$ is damage-free, or $\eta(t)$ is distress-free.

%  $\eta^i$ becomes annotated again on $A$.
\end{lemma}
\begin{Proof}

%    Then, cells of $A$ in a distance not exceeding
%    $\loc\B_{i}$ from $[a,b]$ are all damage free.
%    right and left outer respectively.

    Below, whenever we talk about a sweep,
    we refer to the $\chi.\Sweep$.
    Similarly for the front.

    Without loss of generality assume that
    $\dir(\chi.\Sweep) = 1$.

 %   When the head steps inside $I$, then
%    the state of the machine may change abruptly.
%    If no such changes occurred while the head
%    was inside $I$, then  that
%    part of $I$ is damage-free and the simulation
%    structure is not ruined in it, hence
%    we can remove it
%    from islands.
%

        Recall that each island in an annotated
        history has a numerical value denoting the progress
        in ``damage removal''.
        Recall also, that we called the indicator \emph{expired}
        if the island is damage-free.
        When leaving $I$, the head can be in any state, and it
        can leave $I$ in both sides.

        Let $$I=:[a,b).$$

%   \begin{step+}{lem:damage-cover.no-islands}
%        Suppose that within a distance of $(\loc + \cB)\B$ of $I$,
%        no other islands exist.
%    \end{step+}
%    \begin{prooofi}


        \begin{step+}{lem:damage-cover.no-islands.no-intersection}
            %Suppose that $I$ is not in the range of the sweep
%            $\chi.\Sweep$.
        Suppose that the front is $\Z\B$ apart of $I$ to its left.
        \end{step+}
        \begin{prooofi}
            Let $y$ be the first cell to the left of $I$, and
        %\begin{step+}{lem:damage-cover.no-islands.no-intersection.dragg}
            let $y'$, $y'<y$, be the current cell, such that
             $y$ is the future
            current cell after the state switch.
        %\end{step+}
        %\begin{prooofi}
            Due to our assumption,
            the head could only had stepped in $I$ before
            the switch occurred.

                The head cannot step off $I$ on the right side
                in any state without returning to $I$ again.

            \begin{pproof}

                Indeed, if the head is coordinated
                with the cell to the right of $I$, then
                zigging guarantees that it will return back
                to $I$, hence attacking
                the damage in it.
                Otherwise, alarm will be called, and the return is
                guaranteed by the way how the recovery interval is
                opened, guaranteeing
                that the damage in $I$ will be attacked again.
                Similarly, if the head steps off $I$ to the right, and
                the state is in some phase of the recovery procedure before
                the marking is completed, then the head will return to $I$
                due to zigging.
                If the head is to the right of $I$ in some later
                stage of the recovery, then alarm is called since cells
                are not marked, hence the damage in $I$ will be attacked from
                the right.
                Suppose that the head steps outside of $I$
                when the head is in
                the rebuild mode.
                If the state is in a part of the rebuild
                procedure when the rebuild cover is expanding,
                then, after $(\Z-\Z_b)\Tu{}$,  during which it
                has marked a part of the tape, the head returns to $I$.

                Clearly, if the part to the right of $I$ is marked,
                then the head cannot return there in normal without
                calling alarm.
                However, it can return in rebuild mode or recovery mode
                repeatedly, and each time, zigging brings the head
                back to $I$.

                In all these cases, the head is returning to $I$
                from the right which is damage-free,
                and hence, it is attacking
                the damage.
                According to property~\eqref{i:def.traj.attack-from-outside}
                of the trajectory,  interval $(b-\B, b + \B]$ is
                damage-free at the time when the head returns back
                to $b$ from $I$ on the first time.

                Now, the same property guarantees that,  by the time
                when the head returns to $b-\B$, $[b-2\B, b]$ is
                damage-free, after the second return of the head to $I$.
                If no alarm is called and the head returns again to the right,
                then there is some $b'\leq b - \B$,
                that is damaged and to the right is surrounded with damage-free
                cells.
                Indeed, we have assumed that no bursts occur, hence the only
                cause for a non-deterministic change of the state is  due
                to damage.

                Then, once that cell becomes damage-free, alarm must be called,
                as the machine is in arbitrary state, and the cell
                has the arbitrary symbol.
                Once alarm is called, the attacks continue further to the
                left until $I$ becomes damage-free entirely.

                Consider the worst case when each time the head returned
                to $I$ from the right, it continued in normal mode to the
                right again.
                Since at each return from $I$ an interval $\geq 2\B$
                turns damage-free, we need to make sure that we return
                to $I$ at least $\beta/2$ times.
                Hence, we can set
                \begin{equation}\label{eq:values-of-Z-and-Zb}
                \begin{aligned}
                    &\Z - \Z_b = O(\beta) \\
                    &\Z = O(\beta^2).
                \end{aligned}
                \end{equation}

                During these attacks, the head can step off $I$ to the left,
                and continue with the simulation seamlessly, hence
                leaving the island with some damage in it,
                and a distress area consisting of a
                stripe of at most $\loc\B$ cells
                to its right that are damage-free but are in distress.
                If the head does not return to the left of $I$ in normal,
                then the entire damage in $I$ will be removed.
                %From the moment when the indicator of $I$
%                expires and the last alarm is called,
%                we apply Lemma~\ref{lem:alarm}.

            \end{pproof}
        \end{prooofi}

    \begin{step+}{lem:damage-cover.no-islands.<ZB}
        Suppose that $I$ is not farther than $\Z\B$ from the front.
    \end{step+}
    \begin{prooofi}
        The analysis is similar to part~\ref{lem:damage-cover.no-islands.no-intersection},
        but we point certain differences.

        Namely, while in part~\ref{lem:damage-cover.no-islands.no-intersection}
        there was no guarantee that damage beyond $2\B$ will ever be
        removed, here that guarantee is there, provided
        that some cells in the island are bad, which
        will cause the cells to be restructured, and then
        alarm to be called as the state of the machine will
        be arbitrary and the simulation structure in the cells needs
        to be repaired.
    \end{prooofi}



%        \begin{step+}{lem:damage-cover.no-islands.no-intersection.transfer}
%            Suppose that $y$ is the current cell.
%        \end{step+}
%        \begin{prooofi}
%            Then, the property~\eqref{i:def.traj.attack-from-outside}
%            guarantees that by the time
%            when the head returns to $y$, $[y, y+2\B)$ is damage-free.
%            If this interval was not damage-free before, alarm
%            is called as its structure
%            needs to be repaired.
%            Then, attacks will continue to the right until
%            the entire damage from $I$ will be removed as
%            $[y, y+2\B)$ is marked for recovery and no bursts occur
%            (that would remove the marks).
%            Now, the same analysis as in the previous case
%            applies.
%
%            If this interval was damage-free, then case~\ref{lem:damage-cover.no-islands.no-intersection.dragg}
%            applies.
%        \end{prooofi}


          % We claim that if the head steps off $I$ to the right,
%            then it will be removed.


        %Similarly, after the head steps off $I$
%        whose indicator is still
%        not completed,
%        the state cannot be in any stage of recovery
%        passed marking,
%        as the recovery
%        procedure requires that the cells be marked.

%        On the other hand, the head can leave $I$ on the left
%        side and continue
%        with the simulation seamlessly.
%        The front did not move in this way, but a part of the
%        tape on the right, that is at most
%        $\beta (\Z-\Z_b)\B$ long, is in distress.
%        In this way, the island $I$ with its indicator increased,
%        and with possibly a $\beta(\Z-\Z_b)\B$ long interval
%        that is in distress is left on the tape.


        %Once the island's indicator expires,
%    \end{prooofi}

    \begin{step+}{lem:damage-cover.no-islands.transferredTo}
        Suppose that $I$ is at least $\Z\B$ inside the
        range of the sweep.
    \end{step+}
    \begin{prooofi}

        %As the head is transferring into $I$,
%        $y$ may become temporarily damaged.


        Clearly, in this case the head cannot leave $I$ to the left,
        and continue the simulation seamlessly since zigging will bring
        the head back to $I$ multiple times until the entire damage
        from it gets removed.

        Clearly, before the head reaches the end of the sweep,
        the damage in $I$ will be attacked from the right
        side as well, hence, it is not possible for the head
        to leave $I$ on the right side, and
        not remove the entire damage from it.

        Indeed,
        suppose that the head steps in $I$, and then steps off it to the
        right in normal mode, continuing the simulation seamlessly, pushing
        the front further to the right.
        Then, zigging brings the head back to $I$, hence attacking the damage
        from $b$.
        The property~\eqref{i:def.traj.attack-from-outside} of the trajectory
        guarantees that by the time the head returns back to $b$,
        interval $[b-\B, b+\B)$ is damage-free.
        If the head continues again seamlessly with the simulation
        to the right of $b$,
        then to the left of $b-\B$, damage exists.
        When the head returns back to $I$ in zigging,
        this damage is attacked again, and the head returns to $b-\B$,
        property~\eqref{i:def.traj.attack-from-outside} guarantees
        that $[b-2\B, b)$ is damage-free.
        But it was not damage-free before, hence at this point
        the machine is in an arbitrary state.
        Since no bursts occur, alarm is called.
        The recovery procedure will first mark $\loc$ cells to the right of
        $b-\B$, and then, attack the damage
        inside $I$ again, until it is removed completely.
    \end{prooofi}




  %  \end{prooofi}

%
%    \begin{step+}{lem:damage-cover.island-close}
%        Suppose that a damage-free island $I_1$ exists
%        within a distance
%        of $\leq \loc\B$ from $I$.
%    \end{step+}
%    \begin{prooofi}
%
%        \begin{step+}{lem:damage-cover.island-close1}
%            Let us consider first the case when
%            the range of $\chi.\Sweep$ does not contain
%            $b$.
%        \end{step+}
%        \begin{prooofi}
%            Suppose that the island $I_1$ is to its left.
%
%            As $I_1$ is damage-free, if the head steps off
%            $I$ to the left when the mode is normal and
%            the state coordinated with the current cell,
%            then the head encounters $I_1$.
%            If no alarm is thrown and the head passes over
%            it, then we can remove it, as this is the sign that
%            the simulation structure in needs no repair and is
%            not damaged.
%            Otherwise, if alarm is called, then the head
%            starts with the recovery again by moving to the right
%            and marking the first $\loc\B$ cells it passes.
%            In this way, the head returns back to $I$ again, by attacking
%            the damage, and it does not stop until all the damage from
%            it is removed, since cells to its left are marked.
%            Once that happens, Lemma~\ref{lem:alarm} is
%            applicable.
%
%
%            Suppose that the island $I_1$ is to its right.
%            Then, it will be reached only if the head steps outside
%            $I$.
%            Due to admissibility, the head cannot be in normal mode
%            while being to the right of $I$ for at least $2\Z$ steps.
%            If $I_1$ is encountered during this time, then alarm is called
%            there, and the head starts marking $\loc$ cells to the right of
%            this cell $y$.
%            As the head returns back to $I$ from some cell $y_1$ that is
%            not damaged, it is attacking the damage from
%            the left.
%            Now, part~\ref{lem:damage-cover.no-islands.no-intersection}
%            is applicable, with a difference that the
%            a $2\loc\B$-stripe to the right of $I$ may be left
%            on the tape, if the head steps off $I$ to the left
%            and continues with the simulation seamlessly.
%
%            Similarly, if the head returns to $I$ before the head has stepped
%            on $I_1$, then the case is identical to part~\ref{lem:damage-cover.no-islands.no-intersection},
%            since in this case even if the head steps on $I_1$ while marking,
%            the assumption that $I_1$ is damage-free and our assumption
%            that no bursts occur guarantee that
%            the marking of the first $\loc$ cells to the right
%            of $I$ continues without interruptions.
%        \end{prooofi}
%
%        \begin{step+}{lem:damage-cover.island-close.range}
%            Consider the case when
%            the range of $\chi.\Sweep$ contains
%            the body of $b$.
%        \end{step+}
%        \begin{prooofi}
%            Regardless of the side of $I$ where $I_1$ is located,
%            since $I$ intersects the range of the $\chi.\Sweep$,
%            the damage in $I$ will be attacked until all the damage
%            in it is removed.
%            After the last attack on $I$, Lemma~\ref{lem:alarm}
%            is applicable.
%
%%            Suppose that $I_1$ is to the left of $I$.
%%            Since no bursts  occur,
%%            the head cannot leave $I$
%%            to the right for more than $2\Z$ steps in zigging.
%%            This brings the head back inside $I$, which causes alarm.
%%            Now, analysis of part~\ref{lem:damage-cover.no-islands.transferredTo},
%%            applies.
%%
%%            Suppose that $I_1$ is to the right.
%%            Now, even if the head  leaves $I$, and keeps
%%            moving right, then
%%            alarm may be
%%            called once the head enters in $I_1$.
%%            If not, then case~\ref{lem:damage-cover.no-islands} applies,
%%            since in that case we can remove island $I_1$.
%%
%%            If alarm is called, then, as the recovery marks the cells that
%%            are to the right of $I$, the head cannot leave
%%            $I$ without making it damage-free.
%%            Now, part~\ref{lem:damage-cover.no-islands.transferredTo}
%%            applies.
%        \end{prooofi}
%    \end{prooofi}
%
%
%    \begin{step+}{lem:damage-cover.island-far}
%        Suppose that island $I_1$ is within
%        a distance from $I$ that is greater than $\loc\B$
%        and less than $(\E+\Rec.\Z_b)\B$.
%    \end{step+}
%    \begin{prooofi}
%        The use of zigging in marking guarantees that
%        the marking does not proceed if its initial stage
%        is not completed successfully.
%        Hence, the head can step into $I_1$ only after the damage
%        of $I$ is removed.
%        Now,
%        we just apply Lemma~\ref{lem:alarm}.
%        %This guarantees that at least cells of $I_1$
%%        that are included in the recovery interval
%%        will have their structure repaired.
%    \end{prooofi}
\end{Proof}





In the following lemma, we will establish that
islands that are at a certain distance from each
other will be erased together.


\begin{lemma}[Cluster of islands]\label{lem:clustering-islands}
    Suppose that trajectory $\eta$ of $M$
    is annotated on a space-time interval $A\time \tau$,
    where $A$ is of size greater
    than $Q\B$, and $\tau$ does not contain any burst.

    Then, a group of at most 3 islands $I_1$, \dots, $I_3$,
    with the property that every two consecutive ones are
    within a distance of $\leq(\loc + \cB)\B$ from each other,
%    the smallest interval that covers all of them
%    does not exceed $6(\loc + \beta)\B$ in length,
    are removed together, and
    can be considered
    as an island whose size does not
    exceed $3(\loc + \beta)\B$ in length,
    and whose
    progress indicator is
    \begin{align*}
       \min_{i\in\set{1, \dots, 3}}I_i.
    \end{align*}
\end{lemma}
\begin{Proof}
    Indeed, from~\eqref{eq:requirement2-for-Z}
    it follows that
          \begin{align*}
            3\loc + \beta \leq 0.1\E + \beta <0.2\E,
          \end{align*}
    hence all these intervals will fit into one
    recovery interval properly.

    Further, if the damage is attacked in one of them,
    then alarm is called, and the damage attacks continue
    further since there are no bursts that would recreate the damage
    and erase the marks of the recovery.
    No recovery interval will be created until all
    islands become damage-free.
    Once this happens a new recovery interval will be
    opened.

    If for any of the possible reasons the head
    leaves moves away from the islands, then once it
    returns, it can only return by covering this
    part of the distress area by a recovery interval.
    Even if this recovery interval does not contain
    all the islands, the distress area that covered
    them will cause alarm to be called during the mopping
    stage, hence all the islands will be cleared at the same
    time.


    %\begin{step+}{step:lem:clustering-islands.1}
%        Let $I$ be the smallest interval that covers all of them.
%        Recovery procedure cannot proceed until
%        all the islands become damage-free.
%    \end{step+}
%    \begin{prooofi}
%        Indeed, as the head sweeps over $I$ many times,
%        the front cannot move for more than $6(\Z + \beta)\B$
%        and no more than $6(\Z + \beta)$ cells can suffer changes
%        of $\cCore$.
%        According to~\eqref{eq:loc}
%                   $$12\Z \leq \loc,$$
%        which means that if an island becomes damage-free and is
%        $(\loc + \cB)\B$ apart from the others, its recovery
%        procedure proceeds by widening the recovery interval
%        towards the others first, as
%        the majority of $\cSweep$ and $\cDrift$ in the initially
%        marked interval of $2\loc$ cells is not affected by
%        the eventual changes between the islands.
%    \end{prooofi}

%    \begin{step+}{step:lem:clustering-islands.2}
%        Suppose that
%        while extending the markings in a recovery
%        centered at $x\in I$, new recovery starts
%        when the head is farther than
%        $(\loc+\cB)\B$ from $I$.
%    \end{step+}
%    \begin{prooofi}
%        Suppose first that the new recovery interval
%        is centered at $x'$ that is within $\E\B$ from
%        $x$.
%
%        This interval intersects $I$, therefore
%        islands in $I$ are
%        removed together with the remaining
%        marked part of $\R'$.
%        Indeed, without loss of generality, suppose that
%        $x<x'$ and that $\dir(\chi.\Sweep) = 1$.
%        Then, clearly, if the front is at least
%        $0.25\E\B$ inside $\R'$, zigging done from
%        the left endpoint of $\R'$ brings the head
%        in $I$, which will cause alarm.
%        Otherwise, when $\widehat{\R'} \in \set{(\R')_4^2,(\R')_4^0}$,
%        all the marks are first removed from the right end
%        until $0.4\E\B$ from the left endpoint of the interval
%        where alarm is called.
%    \end{prooofi}
%
%    \begin{step+}{step:lem:clustering-islands.3}
%        Finally, as the damage removal is completed only
%        when the slowest one becomes damage-free,
%        we set the progress indicator to
%        the smallest value of the indicators amongst islands.
%    \end{step+}
\end{Proof}

%\begin{remark}\label{rem:islands-behind}
%The previous lemma is given in a pretty general form.
%
%In our setting, admissibility guarantees much stronger
%property that only recent islands, that is, only islands created
%by bursts may exist in the distress area in the opposite
%direction to the direction $d$
%of the sweep  of the healthy configuration.
%
%     Indeed, once the initial phase
%    of the marking stage is completed,  the marking is always
%    continued in the opposite direction of
%     $d$.
%    Hence, in reality,  scenario from part~\ref{step:lem:clustering-islands.2} of
%    the proof of Lemma~\ref{lem:clustering-islands} occurs
%    only when alarm is called when the recovery over $I$ was
%    marking the cells
%    in the opposite direction of $d$.
%
%    How can we guarantee  this property?
%    As the head sweeps over $I$ many times,
%        the front cannot move for more than $6(\Z + \beta)\B$
%        and no more than $6(\Z + \beta)$ cells can suffer changes
%        of $\cCore$.
%        According to~\eqref{eq:loc}
%                   \begin{align*}12\Z \leq \loc,\end{align*}
%        which implies that if an island that is in
%        the range of the sweep becomes damage-free, its recovery
%        procedure proceeds by widening the recovery interval
%        in the direction $-d$ since
%        the majority of $\cSweep$ and $\cDrift$ in the initially
%        marked interval of $2\loc$ cells is not affected by
%        the eventual changes between the islands.
%        Similarly, if an island that is surrounded by $\loc\B$ outer
%        cells in both sides becomes damage-free first, then
%        the interval is going to spread in direction $-d$.
%\end{remark}


Lemma~\ref{lem:damage-cover} establishes that when an
island is encountered during the simulation,
its clearing is conditioned to a certain extent with its position.
Namely, in the proof, we have seen that islands that
are outside of the range of a sweep that was temporarily
interrupted when the head stepped in such an island, are not
guaranteed to become damage-free before the head leaves it, if
the head does not pass the island fully and if the head
does not dwell a lot in it.
%However, if the head steps in such islands after the recovery
%procedure has reached a certain stage (\ie passed initial marking),
%then such islands will become damage-free and will be removed
%once their simulation structure is repaired.
%We establish this fact in the next lemma.

In the next lemma, we will consider what happens when an island
is encountered during recovery.

\begin{lemma}[Hitting an island during recovery]\label{lem:recovery+damage}
    Suppose that $\eta$ of $M$
    is annotated on an interval $A$ of size greater
    than $Q\B$.
    Suppose that at time $t_0$, during a recovery centered on a cell $x$,
    that is in a
    $\B$-neighborhood of a damage-free island $I$,
    the head steps in
    an interval $I_1$ that contains damage,
    $|I_1|\leq 3(\loc+\beta+\cB)\B$.

    Suppose that in the next $2\K_\R$ steps of $M$, no
    bursts occur.

    Let $d=d(x,I_1)$.

    For an appropriate choice of $\Z$ and $\Z_b$,
    the following is true.

    \begin{enumerate}

    \item \label{i:lem.rec-island.A} If  $d<\E\B$ from
          $x$, then the island becomes damage-free.

    \item \label{i:lem.rec-island.B} Suppose that
       $\E\B\leq d<(\E+\Z_b)\B$.

       Suppose that one of the following is true.
       \begin{enumerate}[(i)]
            \item\label{i:lem.rec-island.1} Suppose that the recovery interval
            contains the front properly inside
            (\ie within $0.25\E\B$
            from its borders).
            Suppose also that the direction of $\chi.\Sweep$
            points away from the island and the
            $\Z_b\B$ stretch on the other side of the
            recovery interval is distress-free, or
            the direction of $\chi.\Sweep$ points to the
            island.
            \item \label{i:lem.rec-island.2}
            Suppose that the front is not more than
            $0.25\E\B$ inside the recovery interval.
       \end{enumerate}
       Then the island becomes damage-free.

    \item \label{i:lem.rec-island.C}
    Suppose that $(\E + \Z_b)\B \leq d \leq (\E + \Z_b + \cB)\B$, and
    suppose that either~\eqref{i:lem.rec-island.1} or~\eqref{i:lem.rec-island.2}
    is true.

        If the head enters in $I_1$ and %does not pass it and
        returns inside the recovery interval in the same state as the
        machine was before the head stepped in $I_1$ except that the
        sweep is towards $x$,
        then the recovery continues seamlessly.

        Otherwise, it will become damage-free.

    \end{enumerate}

\end{lemma}
\begin{Proof}
    Without loss of generality, let us assume that
    $\dir(\chi.\Sweep) = 1$.


    %Interval $I_1$ can be on both sides of $I$.
%    Until the indicator of  $I_1$ is not expired,
%    each time the head
%    steps in it, the damage is attacked.

    Using Lemma~\ref{lem:clustering-islands},
    we can assume that there are no other
    islands in a distance of $\loc\B$ from
    $I_1$.

    \begin{step+}{lem:recovery+damage-<E}
        If  $d<\E\B$ from
          $x$ the island becomes damage-free.
    \end{step+}
    \begin{prooofi}
        Indeed, this means that the damage is
        going to be attacked as it intersects the range
        of all the sweeps after marking.
        %This means that once the head steps in
%        the island, alarm will be called, and the
%        attacks will continue until the entire $I_1$
%        becomes damage-free.
    \end{prooofi}


    \begin{step+}{lem:recovery+damage-freeing}
       Let us consider case~\ref{i:lem.rec-island.B}.
    \end{step+}
    \begin{prooofi}
        %If the island is closer than $\E\B$, then
%        case~\ref{lem:recovery+damage-<E} applies.

        Suppose that the island is farther than $\E\B$ but not
        farther $(\E+\Z_b)\B$.
        If the first condition holds, then the damage
        will be attacked.
        Indeed, if the island is behind the front,
        then, according to the rules of mopping,
        the head will first remove the marks from the endpoint
        of the recovery interval that is behind the front.
        Then, zigging starts and the damage in the island
        gets attacked from a damage-free area.
        Further, if the island is in front of the front,
        and the $\Z_b\B$-stripe next to the recovery interval
        behind the front is damage-free and distress-free, then
        the first mopping sweep will not be interrupted here, and will
        succeed.
        Then, during the second, the damage is attacked.

        Suppose that the second condition holds.
        Then, regardless of the side of $\R$ that the island
        is on, alarm will be called.
        Indeed, without loss of generality suppose that
        the front is closer to the right side.
        Then, the head will be left at this endpoint and alarm
        will be called and if the island is in this side,
        alarm is called.
        If the island is on the other side, then
        it will be reached during the mopping sweep from
        the left.

        %Indeed, after the first pass over $I_1$,
%        the recovery may continue seamlessly.
%        However, as marking and mopping use zigging,
%        the recovery procedure can continue seamlessly
%        only if $I_1$ was damage-free initially.
%        Otherwise, when the head passes over $I_1$ and
%        the state changes, it cannot change to normal and
%        not call alarm as the island is surrounded by marked cells
%        in at least one side.
%
%        Further, in order for the rebuild procedure to  start properly
%        and make changes on the tape,  it needs to have the
%        recovery interval marked with failed marks, which
%        in this case is not possible due to admissibility, and
%        the way how the recovery procedure performs this marking
%        (in multiple repetitions that cannot be influenced by
%        abrupt changes of the state caused by the bursts or islands).
%        Hence, alarm will be called multiple times until
%        the island becomes damage-free.
    \end{prooofi}

    \begin{step+}{lem:recovery+damage+leaving}
       Consider the case~\ref{i:lem.rec-island.C}.
    \end{step+}
    \begin{prooofi}
        Suppose that the head steps in the island and
%        does not passes it, but rather
        returns back
        to the recovery interval.
        Then, the island gets its indicator increased,
        and a part of it an eventually a $\loc\B$-stripe
        to the right of the island is left on the tape.

%        Otherwise, if the damage is attacked once,
%        then it continues until it becomes damage-free.
    \end{prooofi}

\end{Proof}

Now let us use the previous lemmas to show how
the recovery proceeds when the head encounters more islands.



\begin{lemma}\label{lem:covering-2}
    Suppose that trajectory $\eta$ of $M$
    is annotated on an interval $A$ of size greater
    than $Q\B$.
    Suppose that at time $t_0$, the head of $M$ steps
    inside an island  $I$, $|I|\leq 3(\loc+\beta)\B$.

  Then, time $t$, $t \geq t_0 + 3(\beta\Zg(\loc,\Z, \Z_b)+\K_\R)\Tu{}$,
  is distress-free, provided that no
  bursts occur in $[t_0, t]$.
\end{lemma}
\begin{Proof}
    Without loss of generality, let us assume that
    $\dir(\chi.\Sweep)=1$.

    Lemma~\ref{lem:clustering-islands}
    implies that we can consider all the islands
    that can be covered by an interval of size  $3(\loc + \beta)\B$,
    as one.
    Let us denote this island by $\hat I$.

    If no other damaged islands exist in a
    $(\E + \Rec.\Z_b + \cB)\B$-neighborhood of $\hat I$,
    then Lemma~\ref{lem:damage-cover} applies.

    % \begin{step+}{step:lem:covering-2-1}
%        Suppose
%        that the head encounters $I_1$ only after
%        the damage from $\hat I$ has been removed.
%      \end{step+}
%      \begin{prooofi}
%
%
%     \begin{step+}{step:lem:covering-2-1-1}
        Suppose that the head steps in $I_1$ once the damage
        in $\hat I$ is removed.
      %\end{step+}
%      \begin{prooofi}

        Then, Lemma~\ref{lem:recovery+damage} implies that
        either the recovery will continue seamlessly or
        alarm will be called once the island becomes damage-free.

      %  \begin{enumerate}[1)]
      \begin{step+}{step:lem:covering-2-1-1}
        Suppose that no other islands
        exist in a radius of $(\E + \Rec.\Z_b+\cB)\B$ from
        the union of $I_1$ and $\hat I$.
      \end{step+}
      \begin{prooofi}
        If no islands that are not damage-free are left on
        the left side of $\hat I$,
        then Lemma~\ref{lem:alarm} is applicable.
        Otherwise, as we have seen in the proof of
        Lemma~\ref{lem:alarm},
        a series of recoveries and alarms start
        shrinking the distress area.
        But now, once this island is encountered,
        as it has marked cells to the right, it
        will be swept many times until it becomes
        damage-free.
        Then, we continue in the same fashion in a
        process during which we can encounter at most one more
        island, at least $2\E\B$ from the previous one,
        to the left.
      \end{prooofi}

      \begin{step+}{step:lem:covering-2-1-1.isl}
        Suppose that other islands exist on the right.
      \end{step+}
      \begin{prooofi}

        Then we may continue in the same fashion again,  and
        extend
        the distress area further.
        But this process is not limitless, as admissibility
        allows at most
        $3$ islands in a colony and at most two of which
        intersect the union of the workspace and the extended workspace.
        Once the last island becomes damage-free and the last alarm of this
        distress area expansion process is called, then case~\ref{step:lem:covering-2-1-1} applies.
     \end{prooofi}

%
%     \begin{step+}{step:lem:covering-2-1-1-1}
%        Suppose that the $I_1$ and $\hat I$ are within
%        $(\E + \Rec.\Z_b+\cB)\B$ from each other.
%     \end{step+}
%     \begin{prooofi}
%        If the islands are within $\E\B$ from each other, then
%        case~\ref{step:lem:covering-2-1-1} applies.
%
%        Suppose that the islands are
%        within $(\E + \Rec.\Z_b)\B$ from each other.
%        In this case, the head will step on this island only during the
%        mopping stage.
%        Depending on the position of $I$ relative to the front,
%        and the position of
%        $I_1$ relative to $I$,
%        we have the following possibilities.
%
%        \begin{enumerate}
%          \item Suppose that the front is inside the recovery
%          interval (within $0.25\E\B$ from its boundaries),
%          or to the left of $I$.
%          Then, mopping will be done first on the right side.
%
%
%          Hence,
%          if $I_1$ is to the right of $I$,
%          then case~\ref{step:lem:covering-2-1-1} applies.
%
%          Otherwise, if $I_1$ is to the left of $I$, this means
%          that by this moment, no other islands and distress
%          area exist from the point that is $0.25\E\B$ from the right
%          end of the recovery interval.
%          Then, part 1) of case~\ref{step:lem:covering-2-1-1} applies.
%
%          \item Suppose that the front is to the right of $I$, in a
%          distance of at least $0.75\E\B$ from it.
%          Then, mopping is done first on the left side.
%
%          Hence, if the island is on the right side,
%          we apply part 1) of case~\ref{step:lem:covering-2-1-1}, since
%          all the islands are cleared from the left side.
%
%          Otherwise, if the island is on the left side, then once the
%          island becomes damage-free, the recovery interval is opened.
%          As we assumed that no bursts occur, there could not be
%          other islands here neither, hence the recovery succeeds,
%          and as the Patching Lemma~\ref{lem:patching} implies
%          that $\hat \R \in \set{\R_2^4, \R_0^4}$, alarm is
%          called in a $0.25\E\B$ neighborhood of $I$.
%          Then, for the rest of the islands that may exist on the right
%          side of $I$, we apply case~\ref{step:lem:covering-2-1-1}.
%        \end{enumerate}
%
%        Finally, if the island is farther than $(\E + \Rec.\Z_b)\B$
%        but in a distance that does not exceed
%        $(\E + \Rec.\Z_b + \cB)\B$,
%        then the head may enter in this island only once and leave it
%        such that the recovery continues seamlessly.
%        Otherwise,  if alarm is called, then the head will enter
%        in this island until it becomes damage-free, in which case
%        we apply the same analysis as in the previous case.
%     \end{prooofi}
%
%    \end{prooofi}
%
%
%    \begin{step+}{step:lem:covering-2-0}
%        Suppose
%        that the head encounters $I_1$ before
%        the damage from $\hat I$ has been removed.
%      \end{step+}
%      \begin{prooofi}
%        As we have seen in Remark~\ref{rem:islands-behind},
%        this can only happen when the island is in the opposite
%        direction of the sweep from $\hat I$, that is to the left of it.
%
%
%        Clearly, the islands are within $\E\B$ from each other,
%        as otherwise, $\hat I$ would have been already damage-free.
%        According to Lemma~\ref{lem:recovery+damage}
%        either the recovery will continue seamlessly or
%        alarm will be called once the island becomes damage-free.
%
%        In the first case, then $\hat I$ will become damage-free first,
%        as the head returns to it and completes the damage removal in $\hat I$.
%        Now, case~\ref{step:lem:covering-2-0} applies.
%
%
%        In the second case, if $I_1$ becomes damage-free and then
%        the head will step in $\hat I$, if not earlier,
%        then it will step in during the mopping stage.
%        From here an on, analysis in 2) of case~\ref{step:lem:covering-2-0}
%        applies.
%      \end{prooofi}

\end{Proof}


\subsection{Bursts}

Let us now consider the case when the simulation is
interrupted by a single burst.


\begin{lemma}[Burst]\label{lem:burst}
 Let $\tau = [t, t_0)$, for $t, t_0\in\bbN$,  and
 consider a history that is $A \times \tau$ annotated.

    Assume that at a distress-free time $t_0$
    a burst, creating an island $J_{0}$, occurs.

    Then, for $t_1 = t_0 + \beta\Tu{}$,
    time $t'$, $t'\geq t_1 + 12(\beta\Zg(\loc,\Z, \Z_b)+\K_\R)\Tu{}$,
    is distress-free, provided that no
    bursts occur in $[t_1, t']$.
\end{lemma}
\begin{Proof}
    We consider various situations after the burst.

    Let $\chi$ denote a corresponding healthy configuration
    of machine $M$
    on $A$ that is part of the annotation at the time of the
    burst.
    Since the burst occurs at a distress-free time,
    between the front
    of the healthy configuration $\chi$ and the head,
    no more than $\Z \ll \loc$ cells exist.
    In what follows, we will sometimes refer to $\chi.\front$ of
    this moment as just the \df{front}.

    Without loss of generality, suppose that $\dir(\chi.\Sweep)=1$.

	At $t_1$, the head of the machine $M$ is over
	some cell $x$.


    \begin{step+}{step:burst.normal}
        Assume first that the mode at time $t_1$
        is normal.
    \end{step+}
    \begin{prooofi}

        We start from  $x$ that is either
        in island $J_{0}$ or next to it.

        If the burst created the island
        $J_0$ that is $\Z_b\B$ from the front,
        then, the machine can continue seamlessly
        with the simulation if the head leaves
        the island in the direction of the front,
        in the state that is coordinated with the
        current cell.
        Indeed, in this case, the island may not
        be reached in the next zigging
        sweep.

        Otherwise, zigging brings the head back to $J_0$
        or to some possible island $J_1$ in a distance of $\Z\B$
        from each other, while the state is
        normal.
        Then,
        Lemma~\ref{lem:covering-2} is applicable.

    \end{prooofi}% step:burst.normal

    \begin{step+}{step:burst.normal.alarm}
        Suppose that alarm is called
        at $x$.
    \end{step+}
    \begin{prooofi}
        Then, as the recovery starts the damage in
        the island is attacked.
        Then we can
        apply the same analysis similar to the one
        in the proof of Lemma~\ref{lem:damage-cover}
        to show how the island becomes damage-free.
        From there on, the analysis of the proof of
        Lemma~\ref{lem:covering-2} is applicable,
        showing how the distress area will expand until
        all islands are covered, and then shrink until
        the relief is obtained.
    \end{prooofi}

    \begin{step+}{step:burst.arbitrate}
        Suppose that the mode after the
        burst is $\Healing$.
    \end{step+}
    \begin{prooofi}
        By its design, the rebuild procedure
        uses zigging which triggers $\Alarm$
        every time some inconsistency of the
        structure of the rule is found.
        Therefore, if the  machine
        at time $t_1$ is in the $\Healing$ mode,
        alarm will be called within the next
        $2\Z$ steps.

        Indeed, by its design, the rebuild procedure
        must be properly initialized by the recovery
        that fails.
        Since we have started from a distress-free configuration,
        no such interval exists, therefore alarm is called.
        Even if the the machine at time $t_1$, is
        at some stage after the bootstrap stage,
        the rebuilding procedure
        requires its structure, which will cause alarm, since
        it does not exist on an interval larger than $(\Z-\Z_b)\B$.

        Once alarm is called, then
        part~\ref{step:burst.normal.alarm} is applicable.
    \end{prooofi}%{step:burst.arbitrate}



    \begin{step+}{step:burst.recovering}
        Suppose that the mode after the
        burst is $\Recovering$.
    \end{step+}
    \begin{prooofi}
        In the recovery rule, as defined in
        Section~\ref{sec:recovery},
        the head moves inside an interval of
        $2\E$ cells.
        This interval grows in stage $\Marking$, and shrinks in
        stages $\Mopping_{i}$.
        If the stage after the burst
        is $\Planning_{i}$, then $\Alarm$ is called almost immediately
        (possibly passing through some island cells first),
        since we assumed a start from a distress-free configuration,
        in which by definition no non-island cells are marked.

        \begin{step+}{step:burst.recovering.marking}
            Suppose that the stage after the burst is $\Marking$.
        \end{step+}
        \begin{prooofi}
            By its design, the marking rule marks new cells
            while also using a rule similar to $\Zigzag(d)$,
            but moving (and marking)
            at most $\Rec.\Z-\Rec.\Z_b$ cells while moving in one direction.
            Therefore, if the marking was not initialized properly
            to its very initial stage, then alarm will be called, and
            analysis of
            part~\ref{step:burst.normal.alarm} applies.
        \end{prooofi}


        \begin{step+}{step:burst.recovering.mopping}
           Assume that after the burst,  the mopping stage is entered.
        \end{step+}
        \begin{prooofi}
            The mopping stages only erase marks, and apply
            $\cCore\gets\cRec.\Core$.
            Since we started in a distress-free configuration, we had
            $\cRec.\Core=0$ everywhere except possibly in the islands.
            Marking will not change the $\cCore$ value anywhere else.
            It follows that within at most as many cells as the total
            length of islands that are possibly encountered,
            there is either an
            alarm due to not seeing marks, or return to normal mode.
            From there on, the analysis of part~\ref{step:burst.normal}
            applies.
        \end{prooofi} % step:burst.recovering.mopping
    \end{prooofi} % step:burst.recovering
\end{Proof}


In Lemma~\ref{lem:recovery+damage}, we showed how recovery
proceeds when it hits an island.
In this section, we consider the case when recovery is
disturbed by a burst.


\begin{lemma}[Burst in recovery]\label{lem:burst-in-recovery}
  Whenever a burst occurs during
  recovery in a history $\eta$ that is annotated
  on $A\times \tau$, when the head
  was in position $x$,
  %such that
%  $[x-\E\B, x+\E\B)$ contains at least
%  $\E -6\beta$ nonempty cells and none of these
%  cells are marked with the rebuilding marks,
%  then,
  assuming that no other
  bursts occur,
  either the old recovery continues seamlessly and
  possibly, an island of size $\leq \beta\B$ and a $\loc\B$-stripe
  of distress area next to it in the side
  that is farther from the front is left on the tape
  %containing $x$ is left
  outside of the recovery
  interval,
  or alarm is called within a distance of
  $\loc\B$ from $x$.
\end{lemma}
\begin{Proof}

        Let $x_0$ be the center of the recovery interval
        of the recovery process running before the burst
        occurred, and let $J_0$ be the island
        created by the burst.

        \begin{step+}{step:lem:burst-in-recovery.island}
            As the burst can occur at any time during the
            recovery, $J_0$ can be either inside the recovery
            interval (including the $\Rec.\Z_b\B$-ring around it),
            or outside of it.
            This means that the recovery procedure may continue
            seamlessly until the end, may continue seamlessly
            until mopping, or may be interrupted soon after the burst
            which will induce alarm.
        \end{step+}
        \begin{prooofi}

            If $J_0$ is created during the mopping stage,
            %farther than $(\E + \Rec.\Z_b)\B$ from the center
            %of the recovery interval,
            it may remain undetected if it is
            farther away from the front.
            Similar to how a burst can avoid the sweep of a zig
            in normal mode (shown in case~\ref{step:burst.normal}
            of Lemma~\ref{lem:burst}),
            a burst that occurs in the first mopping stage (from the end
            determined by the direction of the $\chi.\Sweep$)
            can create an island and leave it undetected,
            if it is at least $\Rec.\Z_b\B$ from the point where
            the zigging started, and the recovery continues seamlessly.

            Also, if $J_0$ is created before the initial stage
            of the recovery has completed,
            then by Lemma~\ref{lem:clustering-islands} we can
            ``tie the fate''
            of $J_0$ to the islands that were being swept before the burst.
            If such islands are outside of the range of the sweep $\chi.\Sweep$
            and $J_0$ is the closest to the front,
%            or are the within $\Z_b\B$ from the front (as considered in the previous paragraph)
            they are all left without removing
            their damage completely.
            It is important to point out that this is possible only
            when the total size of the distress area does not exceed
            $3(\loc + \beta)\B$,
            since otherwise, the front would have been already covered,
            and then zigging would step back inside this area, invoking
            alarm.

            Finally, islands created by bursts that occurred
            during other stages of the recovery will be removed,
            as the head will step on them before the recovery ends.
        \end{prooofi}

        \begin{step+}{step:lem:burst-in-recovery.3}
              If the burst occurs during $\Planning$,
              and the previous recovery
              continues seamlessly,
              provided that no damage or changes
              in the recovery structure is introduced,
              this will have no effect on the
              resulting correction values since the recovery
              procedure uses
              the majority computations and multiple repetitions,
              and alarm would be called if any mismatch is
              identified.
        \end{step+}

       % \begin{step+}{step:lem:burst-in-recovery.2}
%            Since the state of the machine after the burst is arbitrary,
%            can the head leave the distress area without cleaning it?
%        \end{step+}
%        \begin{prooofi}
%            Suppose that
%            the state after the burst is in the rebuild mode.
%            Then the head can continue for at most $2\Z$ steps in
%            both sides of the island, but afterwards
%            the head returns back to the created island, hence attacking it,
%            which will cause alarm to be called.
%%            It can continue in rebuild, but multiple ziggs will
%%            bring back the head in the island, causing it to
%%            become damage-free and then alarm to be called.
%%            Otherwise, the head can continue with the previous
%%            recovery seamlessly.
%
%            Suppose that the state after the burst is in normal mode.
%            Then, clearly the head cannot walk in this mode
%            over the distress area as this will cause alarm.
%            However, the head can walk away in this mode outside
%            of the distress area if the island is on its boundary.
%            Can it happen that in this case the head leaves the
%            distress area and continues with the simulation without
%            removing this island?
%            The answer is positive only if the burst occurred before
%            the initial stage of recovery has completed damage-removal
%            of an island that is outside of the range of the sweep, or
%            it is within $\Z_b\B$ from the front, as shown in case~\ref{step:burst.normal}
%            of Lemma~\ref{lem:burst}.
%        \end{prooofi}
\end{Proof}












\section{Recovery lemma}\label{sec:recovery-lemma}

In the previous sections, we have seen how
our recovery mechanism succeeds in removal of
the islands.

However, in the following example, we show
a way how, under certain conditions,
an adversarial choice of bursts
can ruin the neighbor colony.

\begin{example}
    [Ruining the neighbor]\label{ex:aligned}
    Denote $C(b)$ a colony with starting point $b$.
    Consider the following scenario.
    During the rightward transferring sweep to colony
    $C(b)$,  while within distance $\Rec.\Z_b\B$
    of the right colony boundary $(b+Q)\B$,
    the head hits an island, calling alarm.
    The recovery procedure opens a recovery
    interval and proceeds to work on
    it.
    Now, while the head is on the right boundary of this interval,
    a burst occurs.
    As a result of this burst, nothing changes inside
    the recovery interval,
    or in the head position or the state, but an
    island $I$ is created on the right, outside of the recovery interval.
    Assume that the computation  from now on continues to the
    left of $(b+Q+\E)\B$.
    In some much later work period, at the last sweep before moving left from
    colony $C(b)$, a burst leaves an island within distance
    $(\E - \Rec.\Z_b - \beta)\B$ from $(b + Q + \E)\B$.
    Then, in some much later work period, during the transferring sweep to
    $C(b)$, the head hits this new island and the recovery starts.
    Now we repeat the same scenario as above, creating an island
    $I - \beta\B$ which
    will stay there.
    If we continue with this adversarial way of
    putting islands, the entire interval
    $b + \Rec.\Z_b\B + \lint{0}{(\E +\beta)\B}$ can be covered by islands.
    Then, much later, in a transfer to colony $C(b+Q)$,
    the algorithm of the Patching Lemma~\ref{lem:patching}
    may be defeated.
\end{example}


    How to prevent such scenarios?
    One way is to modify the recovery procedure such that, the recovery
    interval has a special property that prevents it from sliding:
    specific places will have specific fixed positions for the
    recovery interval.
    This approach is used in~\cite{Bursts}.
    Here, this property is redundant due to the feathering property
    (see Definition~\ref{def:feathering}) of the programs that we
    simulate. %and self-simulation.
    This property states that the machine
    does not leave a colony $b$ more than two times without
    visiting its neighbor.
    Now, the adversary from Example~\ref{ex:aligned} cannot execute
    such strategies, as the buildup of islands in the neighbor colony
    will be terminated by transferring to that colony and
    removing all islands and all stains from there.


    We will use this argument in the proof of the following lemma.

\begin{lemma}[Recovery]\label{lem:recovery}
    Let $(\eta, \Noise)$ be the trajectory of machine $M$, and
    assume that machine $M$ starts working on a code configuration
    $\xi$. %tape
%    configuration  of the form $\varphi_{*}(x)$.
    Then, $(\eta, \Noise)$ can be annotated on $A\times \tau$,
    provided that
    no $\Noise^*$-bursts occur in $A \times \tau$.
\end{lemma}

\begin{Proof}

    Assume that the history has been annotated in an
    admissible way up to a certain time at some space-time
    rectangle.
    First we show that in case a distress event occurs,
    the annotation can be extended to keep
    property~\ref{def:annotated-hist}
    (\ref{i:annotated-hist.distress}).
    Then using this, we will show that in case of no distress,
    the annotation can also be extended in an admissible
    way while keeping the other  properties.

    \begin{step+}{step:recovery.distress}
        Consider property~\ref{def:annotated-hist}
        (\ref{i:annotated-hist.distress}).
    \end{step+}
    \begin{prooofi}

        Consider the case when the distress event
        occurred when the head steps in an island $I$.
        If no further bursts
         occur %and no other islands exist within $(\E + \Rec.\Z_b + \cB)\B$
          %from $I$,
        then,
        Lemma~\ref{lem:covering-2} implies the desired relief.

        If a burst occurs during the recovery,
        then Lemma~\ref{lem:burst-in-recovery}
        implies that we end up with recovery again,
        hence Lemma~\ref{lem:covering-2} applies again.
        %If a new burst occurs, we repeat the argument.

        In this way,
        at most one island is created by a burst occurring
        during the recoveries or simulation
        may be left on the tape undetected.
        All other islands can be replaced by a stain once
        the relief is obtained.

        Similarly, if the distress event starts with a burst,
        then  Lemma~\ref{lem:burst} implies that either
        the machine continues with the simulation seamlessly and
        the island is eventually left on the tape,
        or the island becomes damage-free.
        Then, Lemma~\ref{lem:covering-2} applies.

    \end{prooofi} % step:recovery.distress

    \begin{step+}{step:recovery.progress}
        Consider property~\ref{def:annotated-hist}
        (\ref{i:annotated-hist.progress}).
    \end{step+}
    \begin{prooofi}
        Assume an admissible annotated history until
        a distress-free time $t$.
        We will show that by just keeping the islands
        constant, the annotation is extendable in an
        admissible way to $t+1$.
        In particular, there will still be a satisfying
        healthy configuration.

        Looking at Definition~\ref{def:healthy1} of
        healthy configurations, most properties are
        obviously preserved in each step by just the
        form of the transition rule.
        The exceptions are the property
        which requires that the $\cDrift$ track holds constant
        values in certain intervals at certain times.
%        and the property which requires that
%        $\cInfo$ and $\cState$ tracks hold
%        valid codewords of the code $(\varphi_{*}, \varphi^{*})$
%        defined in Section~\ref{sec:coding}.



        So we are only concerned with the recomputation of the values
        of $\cState$, $\cInfo$, $\cDrift$ in the base colony,
        during the computation phase, and then the
        transfer of $\cState$ during the transfer phase.
        (The value of $\cDrift$ in the neighbor colonies
        is inherited from earlier,
        and its spreading from $\Drift$ is watched over by
        the coordination requirement: a change would
        trigger alarm at zigging.)

        Recall the structure and the tasks of the
        computation phase given in~\ref{sec:computation-phase}.
        By properties of annotated configurations in
        Definition~\ref{def:annotated-config},
        in the base colony, besides one possible island,
        there is at most 1  stain of size $\beta\B$,
        and possibly more stains that are contained in a single interval
        of size
            \begin{align*}
                (\YardDepth + \Z_b + 5\E)\B.
            \end{align*}
        The bound comes from the length of possible penetration of the head
        in a neighboring colony while faults could occur.
        These last stains can be ignored, since our code is defined in such a
        way that it places a codeword of the $(\beta,2)$ burst-error-correcting
        code $(\upsilon_{*},\upsilon^{*})$ at a distance
        $\PenetrationLen$ away from the colony boundaries.
        hence, we set
        \begin{align*}
            \PenetrationLen = \YardDepth + 6\E.
        \end{align*}
        Now, we can set the damage attraction range $\cB$ to any
        value between $2\PenetrationLen/\B$ and $\B/2$.

        The recovery rules do not change the
        $\cHold$, $\cState$ and $\Info$ tracks, and
        given that $\Sweep<\TransferStart$,
        they do not change $\cDrift$ track either.
        Therefore, since there are at most 2 stains
        at distance $\geq \PenetrationLen\B$ from the
        boundaries, and our code is $(\beta,2)$ burst-error-correcting,
        the result of decoding from the $\Info$ and $\State$
        tracks during the computation phase
        will be the same as if the configurations
        had been stainless all along.

        %Let us make sure that the number of islands in the neighbor
%        colony does not grow more than $4$ without removing them.
%        Indeed, to plant two islands that are not detected and recovered
%        in the neighbor colony, at least 3 working periods are needed,
%        since $V>\U$.
%        However, our machine is simulating the machine
%        with the same code as itself, therefore even if the boundary
%        between the workspace $X$ and the neighbor colony $Y$ is a boundary
%        between two big simulated cells,
%        the simulation of $M_1$ will drift towards this very colony
%        after two work periods over $X$.


        Any distress event will directly affect at most one
        of the three repetitions of the computation phase:
        the configuration is centrally consistent during the others.
        Consequently, the correct values will be
        stored in track $\cHold[i]$, $i\in\{1,2,\dots, 3\}$
        for all but one $i$.
        If the sweep of the field majority computation
        during the encoding stage of the computation phase
        is distress-free, then every  cell will receive
        the correct value $\maj(\cHold[1\dots 3])$.
        But even if distress occurs in this sweep, relief
        guarantees that all cells but the ones in the
        island of the burst that caused the distress will hold the
        correct value.

        The same argument proves the property that the
        newly computed $\cState$ will be correctly transferred
        to the extended base colony in the transfer phase.
    \end{prooofi} % step:recovery.progress

    \begin{step+}{step:recovery.stains}
        Consider
        property~\ref{def:annotated-hist}\eqref{i:annotated-hist.stain}.
    \end{step+}
    \begin{prooofi}
        From the above argument it is clear that
        the only possible stains remaining in the
        base colony are the ones created by a burst
        in the current work period.
        On the other hand, we can add stains and
        islands to neighbor colonies.

        Let us see what is the farthest distance to
        which we can intrude
        into a neighbor colony and leave islands.
        A burst occurring anywhere in the rebuild cover
        or recovery interval
        may leave a stain anywhere within a distance of
        $\PenetrationLen\B$ from the colony boundary.
    \end{prooofi} % step:recovery.stains

\end{Proof}




Once we have an annotated history on a sufficiently large
interval, we can define the simulation
$(\phi_*, \Phi^*)$,
where $\phi_*$ is defined in Subsection~\ref{sec:coding}.

\begin{lemma}[Simulation]\label{lem:simulation-step}
  Let $(\eta, \Noise)$ be a trajectory of machine $M$,
  and let
     $\xi^{*}$ be a configuration of $M^*$.
     %such
    %that $\varphi_*(\xi^{*})$ is a code configuration.
%    in a set $\I$.
    Assume that
    machine $M$ starts working on a tape configuration
    of the form $\phi_*(\xi^{*})$.

    %Further, assume that for $j$, $j>i$,
    %no $(\beta_j, V_j)$-bursts occur.

    Then, provided that no $\Noise^*$-bursts occur,
    via some simulation function $\Phi^{*}$
    (to be defined in the proof of the  present lemma),
    the movement of the base colony corresponds to the
    head movement of the simulated machine $M^{*}$
    (scaled up by a factor of $Q$).
    Whenever the sweep in the free cells of the base colony
    is not one of switching to a new work period,
    the array of $\cState$ values there decodes
    into the state of $M^{*}$, and
    the array of $\cInfo$ values decodes
    into the current tape cell symbol of $M^{*}$.
\end{lemma}
\begin{proof}
    %We set $\varphi_*$ to be equal to the encoding

    Lemma~\ref{lem:recovery} gives us an annotated  history
    on a space time rectangle $A \times \tau$.
    At all distress-free times, it also defines uniquely the
    current colony.
    For distressed times, let the current colony be equal to that
    of the last distress-free time.
    Once a current colony is given for each configuration, the
    simulation function is also uniquely defined: we decode
    the simulated cell content of each cell of
    $M^{*}$ from the corresponding colony, and the simulated
    state from the $\cState$ array of the current colony.
    Part~\ref{step:recovery.progress} of the proof of
    Lemma~\ref{lem:recovery} shows that the
    decoding indeed defines a trajectory of $M^{*}$.


    What are all the lower bounds on $Q$?
    Since the program of the simulating machine must fit in a colony,
    the number of cells in a colony
    is lowerbounded by the size of the program of the simulated machine.

    We needed to be able to define the code $(\psi_{*},\psi^{*})$ in
    Section~\ref{sec:coding} fitting into the part of the colony away by
    $\PenetrationLen\B$ from the boundary.
    These requirements are satisfied with $Q$ depending linearly on
    $\log{|\Sigma^*|}$ and $\log{|\Gamma^*|}$, which in turn
    depend on $Q$.
    Further, for the zigging purposes we
    want $Q$ to be a multiple of
    $(\Z - \Z_b)$.

\end{proof}


What is the time dilation of $(\phi_*, \Phi^*)$?
    The computation phase lasts
    $\Dc Q^2$ steps of $M$, for some $\Dc >0$.
    For the transferring of the $\State$ into the neighboring
    colony will need $\Dr Q$ sweeps, for some
    $\Dr >0$, that is $\Dt (Q^{2})$ steps.
    Hence, in total, to simulate one step, machine $M$  needs
    \begin{align}\label{eq:U-value}
         \U = \Dw Q^2
    \end{align}
    steps, for some constant $\Dw >0$.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% Chapter Proof of the Main Theorem
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Proof of the Main Theorem}\label{ch:proof-main-thm}

In Lemma~\ref{lem:simulation-step} of Chapter~\ref{sec:1-level-noise},
we have defined the simulation $(\phi_*,\Phi^{*} )$.
In this chapter we will first show how our generalized Turing machine $M$
simulates any Turing machine $G$.

    Then,  we will establish the tower of simulations, consisting of
    a sequence of generalized Turing machines
    $M_1$, $M_2$, \dots,
    and a sequence of simulations
    \begin{align*}
        [(\phi_{i*},\Phi_i^{*})]_{i\geq 1},
    \end{align*}
    such that $M_1$ simulates $M_2$, $M_2$ simulates $M_3$, and so on,
    where each of these machines performs the ``side-simulation''
    of $G$.

By building the tower, establishing the appropriate constants, and
showing how it simulates any Turing machine $G$,
we will give a proof of the Main Theorem~\ref{thm:main-main}.



\section{Simulation of a given machine}\label{sec:simulationOf-G}


 Now we define the
 rule $\UsefulSimComp$, that was called during the computation
 phase of the main simulation.

 The program of the main simulation, builds an infinite
 hierarchy of self-simulating machines.
 The question here is how do we simulate  ``given'' Turing machine
 \begin{align*}
    G = \left ( \Gamma,\Sigma,\delta_G,q_{\start}, F \right ).
 \end{align*}

 We will perform the computation of the machine $G$ on a separate
 set of tracks of machine $M_i$, $i\geq 1$.
 From now on, when referring to this simulation, we will call it
 the \emph{side-simulation} to distinguish it from the central
 simulation
 that we have introduced before.

 A general way to perform the oblivious simulation
   of any Turing machine is by using three additional fields in each
   cell and one extra field of the state.
 The special fields that we introduce for this purpose are the following:
\begin{enumerate}
  \item a cell field $\cSimInfo$ that stores a tape symbol of $G$,
  \item a cell field $\cSimState$ that stores the state of machine $G$, and
  \item a field $\SimState$ of the state of $M_i$
        that stores the state of machine $G$, and
  \item a cell field $\cSimDrift$ that stores the direction of the head
        of $G$ during the last visit of the simulating head to this cell.
 % \item $\cOrigSimInfo$ and $\cOrigSimState$ fields that store
%        the initial tape symbol and initial state of $G$ respectively.
%        Their use will be explained later.
\end{enumerate}
 The transition function $\delta_G$ of $G$ is hardcoded in
 the head of $M_i$.


\subsection{Coding the initial configuration of the
 given machine $G$}\label{subsec:init-config-G}

 One cell of machine $M_i$,  ($i>0$),
 corresponds to one cell of $G$.

 Initially, the input is written
 onto  $\cSimInfo$ fields of $M_i$, ($i>0$).
 The state of $G$ is written in $\cSimState$ of the
 cell of $M_i$ at the origin of the tape of $M_i$.

 Other side-simulation fields  are empty all over.
 Later we will see how the initial configuration of $G$ is
 encoded in the initial configuration of every machine $M_i$ for
 $i>0$.



\subsection{Side-simulation}\label{subsec:sidesim}
   Whenever $\SimState$ is empty, that means that the head
   of the simulating machine is away from the current
   cell of $G$, in the opposite direction of the
   last step of $G$.
   In this case, the cell of the simulating machine
   that corresponds to the current cell of $G$ stores
   the state of $G$ in its $\cSimState$ field.
   Therefore, whenever the head steps on a cell
   when $\SimState$ is empty, it checks if this is
   the current cell of $G$ that did not complete the transition.
   Then, it compares its $\cSimDrift$ with the direction
   of the simulating machine, and if they match, it will
   set $\SimState \gets \cSimState$, and set
   $\cSimState$ to $\emptyset$, which means that this cell
   does not correspond to the current cell of $G$ anymore.

   Otherwise, when $\SimState$ is not empty, that means
   that it will do the transition of $G$ in the next step, in
   which case it will apply the transition function
   to $(\cSimInfo, \SimState)$, to obtain the new
   values for $(\cSimInfo, \cSimState, \cSimDrift)$, and
   it will set $\SimState$ to $\emptyset$.
   Then, it applies the previous case.










\subsection{Trickle-down the result}


    In our Main Theorem~\ref{thm:main-main}, we assume that for a given input of $G$,
    we know the time $T_G$ that $G$ needs to halt and write
    the result in the $0^\tth$ cell  of its tape.

    Though the computation of $G$ will be conducted at some
    $M_j$, for $j>1$, after a certain amount of time of
    the computation, we want to read the result of $G$ on a designated
    field of cell $0$ of $M_1$.

    First not all machines of the tower will performs the side-simulation:
    we will let only one of them, that is high enough such that bursts are likely to
    occur, to perform this job.
    We will call it the \df{active level}.

    How can we mark the machine that is
    performing the simulation of the given machine?
    We add an extra field $\Active\in\set{0,\pm 1}$.
    We will call the level \df{active} if
    $\Active=0$ at each cell.
    The computation of $G$ occurs at this level.
    Then, machines of the tower that are below the
    active level  will have
    $\Active = -1$, and they do not simulate $G$.
    Instead, before the end of the computation phase
    of every work period, these machines decode
    the value of $\cSimInfo^*$ from the $\Info$ track, and
    store it in their own $\cSimInfo$ track of their
    base colonies.
    We will explain the details of this procedure
    in the sequel.


 \subsection{Simulating one step of a given machine $G$}
 \label{subsec:Sim-step-G}

    Suppose that the input of $G$ is encoded in
    the initial configuration of machine $M_{K}$, for some
    large enough $K$.

    Then, once the main part of the computation stage
    in a work period of the machine $M_{K-1}$ is finished,
    rule $\UsefulSimComp$ decodes the values of $\Active$,
    $\cSimInfo$, $\cSimState$, and $\cSimDrift$
    from the codeword stored in the $\Info$ track of the base
    colony, and
    $\SimState$ from the codeword stored onto the
    $\State$ track of the base colony.

    If it appears that $\Active=0$,
    then it performs the simulation of $G$ as
    outlined in~\ref{subsec:sidesim}.

    Otherwise, it will just copy the value of $\cSimInfo^*$ and
    write it on its own $\cSimInfo$ track, and set
    the value of $\Active$ in the base colony to $-1$.

    %To make these computations resilient to eventual
%    bursts, we use multiple repetitions and majority voting.
    The details of the implementation
    are given in the rules $\UsefulSimComp$ and $\SideSim$, in
    Rule~\ref{alg:usefulComp} and Rule~\ref{alg:side-sim},
    respectively.


\begin{algorule}[h!] \caption{{\bf Rule $\UsefulSimComp$}\label{alg:usefulComp}}

   \For{$j=1, \dots, 3$}{
            Let $a$ and $g$ be the  strings found
            on the $\cInfo$ and $\cState$ track respectively of
            the base colony between addresses $\PenetrationLen$
            and $Q-\PenetrationLen$\;
            $\hat g \gets \Un(\ang{p_{\decode}}g)$\;
            $\hat a \gets \Un(\ang{p_{\decode}}a)$\;

            Call $\SideSim$\;
  }

    \For{$j=1, \dots, 2$}{
          $\cSimInfo \gets \maj(\cHold[1, \dots, 3].\SimInfo)$\;
          $\cInfo \gets \maj(\cHold[1, \dots, 3].\Info)$\;
          $\cState \gets \maj(\cHold[1, \dots, 3].\State)$\;
          $\Active \gets \maj(\cHold[1, \dots, 3].\Active)$\;
    }
\end{algorule}

\begin{algorule}[h!] \caption{{\bf Rule $\SideSim$}\label{alg:side-sim}}
%  \For{$j=1, \dots, 5$}{

      Let $a_c$, $a_G$, $s_G$, and $d_G$ be the
      values of $\Active$,
      $\cSimInfo$, $\cSimState$, and $\cSimDrift$,
      in $\hat a$\;

      Let $s'_G$ be the value of $\SimState$ in $\hat g$\;


      \If{$a_c=0$}{

        \If{$s'_G \neq \emptyset$  \algAnd
             $s_G = \emptyset$}{

            By applying the transition function
            $\delta_G$ on  $(a_G, s_G)$,
            obtain
            $(\widehat{a_G},\widehat{d_G},\widehat{s_G})$\;

                \If{$\widehat{d_G} = d \neq 0$}{
                    $\widehat{s'_G} \gets \widehat{s_G}$\;
                    $\widehat{s_G} \gets \emptyset$\;

                }
                \lElseIf{$\widehat{d_G} = -d \neq 0$}{
                    $\widehat{s_G} \gets \emptyset$\;
                    }
               \lElseIf{$\widehat{d_G} = 0$}{
                    $\widehat{s'_G}\gets \widehat{s_G}$\;
                }
            }
        \ElseIf{$s'_G = \emptyset$  \algAnd
                    $s_G \neq \emptyset$  \algAnd
                    $d_G = d$}
                {
                 $\widehat{s'_G} \gets s_G$\;
                 $\widehat{s_G }\gets \emptyset$.
        }

        In the string $\hat a$, substitute the appearance of $a_G$
        with $\widehat{a_G}$, the appearance of $s_G$ with
        $\widehat{s_G}$, and the appearance of $d_G$ with
        $\widehat{d_G}$.
        Further, in the string $\hat g$, substitute the appearance
        of $s'_G$ with $\widehat{s'_G}$\;



            Write the encoded new state $\upsilon_{*}(\hat g)=\Un(\ang{p_{\encode}}\hat g)$
            and new info $\upsilon_*(\hat a)=\Un(\ang{p_{\encode}}\hat a)$
             onto the
              $\cHold[j].\State$ and $\cHold[j].\Info$
              tracks respectively of the base colony between positions
              $\PenetrationLen\B$ and $Q-\PenetrationLen\B$\;


        Write $-1$ to $\cHold[j].\Active$ all over the
        base colony\;
       }%a=0
     \lElseIf{$a_c<0$}{
        Set $\cHold[j].\cSimInfo \gets a_G$\;
        Write $-1$ to $\cHold[j].\Active$ all over the
        base colony\;
     }
\end{algorule}



%    In order to keep the values in $\Active$ track correct,
%    we modify the
%    rule $\UsefulSimComp$ such that at its initial phase,
%    it computes the majority of $\Active$ track inside
%    the base colony 5 times, where at each repetition
%    we store the results in a specific hold track.
%    Then, we sweep the base colony three times, and
%    at each step, we set the value in the $\Active$
%    field to be equal to the majority of the values
%    stored in the hold fields of this cell.


\section{Parameters of the central simulation}

    Let
    \begin{align}\label{eq:simulations}
    \sS =[(\phi_{i*},\Phi_i^{*})]_{i\geq 1},
    \end{align}
    be the sequence of simulations, based on
    $\Phi^*$ defined in Lemma~\ref{lem:simulation-step}, and let
    \begin{align}\label{eq:machines}
       \sM = [M_i]_{i\geq 1}
    \end{align}
    be the sequence of machines such that for every $i>0$,
    $M_i$ simulates $M_{i+1}$ using
    $(\phi_{i*},\Phi_i^{*})$.


    Let $\B_i$ be a cell body size of $M_i$, $i>0$.
    We define it recursively as follows:
    \begin{equation}\label{eq:B_i}
    \begin{aligned}
       \B_1 =&1  \\
       \B_k =& Q_{k-1}\B_{k-1}, \; k>1.
    \end{aligned}
    \end{equation}


    As we have seen in Chapter~\ref{sec:blueprint} the main
    parameter of a simulation is the number of cells in colony.
    In the proof of Lemma~\ref{lem:simulation-step}, we gave its lower
    bounds.
    Let us set up this parameter for each level.
    %Also, each generalized Turing machine has the parameter
%    that indicates the level, from which it computes the size
%    of its cells and the colony size.



    The generalized Turing machine $M_1$ has the following parameters
    imposed by its hardware construction:
    \begin{equation}
        \begin{aligned}
            \B_1 & = 1\\
            \Tu{1} & = 1.
        \end{aligned}
    \end{equation}
    As the state of the machine that it simulates depends
    on $Q_1$, we can take
    $Q_1 = Q$.
%    size program of $G$, %and satisfies
    %$Q>\cQ \log Q$, for some
    %large $\cQ$ that we quantify later,
    %and
%    is divisible by $(\Z - \Z_b)$.



    %In general, for the reasons to be explained
%    in the next section, we take
%    \begin{equation}\label{eq:Q_i}
%    \begin{aligned}
%       Q_k &=  Q^{2.5^{k-1}} , \; k\in \bbN, k\geq 1,
%    \end{aligned}
%    \end{equation}
%    which clearly satisfies all the conditions above, for
%    some constant $Q$.
    %It also satisfies
%    condition~\eqref{eq:requirement-on-Q_k-B_k}.
%    Indeed, let us show by induction that
%    for every $k>1$,
%    \begin{align*}
%       1 + Q_1 + Q_1Q_2 + \cdots + Q_1\cdot \cdots \cdot Q_{k-2} < \B_k.
%    \end{align*}
%    For $k=2$, the relation is true, since $1<Q$.
%    Suppose that it holds for $k>2$, and let us show that it holds
%    for $k+1$.
%    Using the induction hypothesis
%    \begin{align*}
%       1 + Q_1 + Q_1Q_2 + \cdots + Q_1\cdot \cdots \cdot Q_{k-2}  + Q_1\cdot \cdots \cdot Q_{k-1} < \B_k + Q_1\cdot \cdots \cdot Q_{k-1}.
%    \end{align*}
%    Using~\eqref{eq:B_i}, we have $Q_1\cdot \cdots \cdot Q_{k-1}=\B_k$, hence
%    \begin{align*}
%       1 + Q_1 + Q_1Q_2 + \cdots  + Q_1\cdot \cdots \cdot Q_{k-1} < 2\B_k = 2Q^{\frac{3^{k-1}-1}{2}}<Q^{\frac{3^{k}-1}{2}} = \B_{k+1}.
%    \end{align*}
%    This completes the proof that~\eqref{eq:requirement-on-Q_k-B_k} is satisfied
%    by our choice of $Q$ and $Q_i$, $i>0$.


    %Since $Q_1 = Q$,
    A dwell period for the machine $M_2$ that is simulated
    by $M_1$ is
    \begin{align*}
          \Tu{2} = \U_1 \cdot \Tu{1} = \Dw Q_1^2.
    \end{align*}

   In general, the dwell period bound
   (\ie the time between two switching times)
   $\Tu{i+1}$ for a generalized Turing machine $M_{i+1}$, $i\geq 1$ is
   \begin{align}
     \Tu{i+1} = \U_i \cdot \Tu{i},
   \end{align}
where $\U_i$ is the number of steps in one
work period quantified in~\eqref{eq:U-value}.
By telescoping this recursive formula,
we have

   \begin{align*}
     \Tu{i+1} = & \Dw Q_i^2 \cdot \Tu{i-1} \\
              = & \Dw^i \left(Q_1\cdots Q_i \right)^2, %\\
%              = & \Dw^i\left(Q^{\frac{2.5^{i} - 1}{2.5-1}}\right)^2,
   \end{align*}

For $i>1$, let us take
\begin{align}\label{eq:Q_i}
  Q_i = Q_1 = Q.
\end{align}

Then, for $k>1$, from~\ref{eq:B_i}
we calculate
\begin{align}\label{eq:B_k-val}
   \B_k = Q^{k-1}.
\end{align}

Furthermore, condition~\ref{eq:assumption}
   of Lemma~\ref{lem:sparsiness} is fulfilled.
Indeed,
with such choice of $Q_i$,
we have
   \begin{align}\label{eq:U_i}
      \Tu{i+1} =\Dw^i (Q^{2})^i.
    \end{align}
Then,
\begin{align*}
   \lim_{i \to \infty}\frac{\log{\frac{\Dw^{i+1} (Q^{2})^{i+1}Q}{\Dw^{i} (Q^{2})^{i}}}}{1.5^i}
  = % & \\ &
  \lim_{i\to \infty}\frac{\log{\Dw Q^3}}{1.5^i}=0.
\end{align*}



%\subsection{Choosing the bursts lengths}
%We choose constants $Q_1$, \dots, $Q_k$, \dots, such that
%for the sequence $\{(\beta_i, V_i)\}_{i>0}$, where
%    \begin{equation}\label{eq:beta_i}
%    \begin{aligned}
%%            \beta_1 &= \beta \B_1 \\
%%            &\vdots
%            \beta_i &= \beta \cdot \B_i, \; i\geq 1.
%    \end{aligned}
%    \end{equation}
%and,
%    \begin{equation}\label{eq:V_i}
%    \begin{aligned}
%        V_i &=  \cV \cdot \Tu{i+1},  % \\
%%            & = \cV \cdot \Dw^i Q^{(2.5^i - 1)4/3},
%    \end{aligned}
%    \end{equation}
%for some constant $\cV>0$,
%for every $k>0$,
%$$V_1 + \dots + V_k < \beta_{k+1}/12,$$
%and for every $i$,
%\begin{align}\label{eq:condition2}
%   \log V_i < 3^i.
%\end{align}


%From here, we derive an upper bound on $Q$:
%\begin{align}\label{eq:upper-bound-on-Q}
%   Q < 2^{1.2^i}.
%\end{align}


%Using relations~\eqref{eq:Q_i} and~\eqref{eq:U_i}
%we have
%    \begin{equation}\label{eq:exmpl}
%    \begin{aligned}
%            \beta_1 &= \beta \B_1  =9  & \quad \quad  & V_1 =  \cV \cdot \Tu{2} = \cV \Dw Q_1^2 \\
%            \beta_2 &= \beta\B_2 = 9 Q_1  & \quad \quad  & V_2 =  \cV \cdot \Tu{3} = \cV \Dw^2 Q_1^{4} \\
%            \beta_3 &= \beta\B_3 = 9 Q_1^{2} & \quad \quad  & V_3 =  \cV \cdot \Tu{4} = \cV \Dw^3  Q^{6} \\
%            & & \vdots
%    \end{aligned}
%    \end{equation}




%\subsection{A bound on the probability that a fault occurs}\label{sec:prob-bound}
%
%Once we have chosen the sequences $[\beta_i]_{i>0}$ and $[V_i]_{i>0}$ that
%satisfy the conditions of Proposition~\ref{lem:sparsiness},
%bearing in mind that
%%according to the conditions of Proposition~\ref{lem:sparsiness}
%$\log{V_k} \ll 3^k$ for any $k$,
%we can compute the constant $\varepsilon_0$ of
%the Main Theorem~\ref{thm:main-main}.
%Since the sum $\sum_j{O(V_{k})\cdot \varepsilon^{3^{k}} 2^{O(3^{k})}}$
%converges,
%using Borel-Cantelli lemma we let $\varepsilon_0$ be
%the biggest $\varepsilon$ such that
%\begin{align*}
%   \inf_{K>0}{\sum_{k\geq K}O(V_{k})\cdot \varepsilon^{3^{k}} 2^{O(3^{k})}} = 0,
%\end{align*}
%that is
%\begin{align}\label{eq:varEps0}
%   \varepsilon_0 =
%   %\max\left\{\varepsilon\; : \; \inf_{k>0}O(V_{k})\cdot \varepsilon^{3^{k}} 2^{O(3^{k})} = 0\right\}.
%   \max\setOf{\varepsilon}{\inf_{K>0}{\sum_{k\geq K}O(V_{k})\cdot \varepsilon^{3^{k}} 2^{O(3^{k})}} = 0}.
%\end{align}


\section{The initial configuration}\label{sec:init}

%Recall the definition of the tower in~\ref{def:tower}.
%
%To define a tower, we need to
%define a sequence of generalized Turing machines
% $M_1$, $M_2$, \dots,
%and a sequence of simulations $(\varphi_{1*},\Phi_1^{*}, \I_1)$, $(\varphi_{2*},\Phi_2^{*}, \I_2)$,
%    \dots, such that
%    for every $i>0$,
%    $M_i$ simulates $M_{i+1}$ using $(\varphi_{i*},\Phi_i^{*}, \I_i)$.

On our way of building a tower
\begin{align*}
    (\sS, \sM)
\end{align*}
defined by~\eqref{eq:simulations} and~\eqref{eq:machines},
before we can even talk about computation of these machines,
we must initialize each of them.
So now the question is how to define the initial configurations of each
of these machines, and related to that, how to
simulate any given Turing machine $G$.
The general scheme of our construction is given in Figure~\ref{fig:tower2}.

\begin{figure}[h]
\centering
\includegraphics[width=5in]{hpics/tower-proof.pdf}
\caption[The scheme of the side-simulation]{
    The scheme of the construction: Turing machine $M_1$
    builds a tower on whose active level we do the oblivious
    simulation of a given Turing machine $G$
\label{fig:tower2}}
\end{figure}



Suppose that
\begin{align*}
    G=\left(\Gamma,\Sigma,\delta,q_{\start},F\right)
\end{align*}
is a given Turing machine, that
on input $x$, starting from the corresponding
initial configuration $\varrho$
that depends on $x$ and $q_{\start}$,
within $T_G$ steps reaches a final state $q_f\in F$
and leaves the result in $\tape[0]$.

For some sufficiently large non-negative integer
$K$, that we will compute here, we will encode the
initial configuration $\varrho$ of $G$ in an initial configuration
of $M_K$.
Let us compute the
cell of $M_K$ that contains the origin.

Before we proceed any further, we need to know the positions
of cells for each $M_i$, so let us introduce a kind of a coordinate
system for hierarchical codes.

\begin{definition}[Coordinates in a hierarchical code]\label{def:coordinates}
    Let $\xi$ be a given code configuration of a hierarchical code
    $(\varphi_i)_{i\geq 1}$ with block sizes $Q_i$.

    The \df{$k\tth$ root cell} is the
    cell $z_k$ of level $k$ that contains
    the origin of $M_1$ (see Definition~\ref{def:config}).

    A \df{root address} belonging to $\xi$ is
    an integer $a$, such that for every $i\geq 1$,
    the following holds
    \begin{bullets}
        \item  $0 \leq a < Q_i;$
         \item cell $z_i$ is the $a^\tth$ cell of the colony that
            decodes into a cell $z_{i+1}$
    \end{bullets}
%    A \df{root address sequence} belonging to $\xi$ is
%    a sequence $(a_k)_{k\geq 1}$, such that for every $i\geq 1$
%    $$0 \leq a_i < Q_i,$$
%    and cell $z_i$ is the $a_i\tth$ cell of the colony that
%    decodes into a cell $z_{i+1}$.
\end{definition}

If we are given $a$ and the
origin $z_1$ of the first level, how do we
determine
$z_k$?

For $k>1$, the Definition~\ref{def:coordinates}
implies the following relation
\begin{align}\label{eq:origin}
    z_k = z_{k-1} - a\B_{k-1},
\end{align}
which gives us
\begin{align}\label{eq:origin-closed}
    z_k =  - a\B_{1} - a\B_{2} - \cdots - a\B_{k-1}.
\end{align}
Using~\eqref{eq:B_i}, \eqref{eq:Q_i}, and~\ref{eq:B_k-val}, and by setting
 $a=1$, we obtain
\begin{align}\label{eq:origin-value}
    z_k =  - 1 - Q - Q^2 -  \cdots - Q^{k-2}.
\end{align}

We depict an example of this concept
in Figure~\ref{fig:root-address}.

\begin{figure}[h]
\centering
\includegraphics[width=5in]{hpics/rootaddress.pdf}
\caption[Root address]{
    Let $a=1$ and let all colony sizes be 3.
    Then, the $z_{k-2}$ is the second cell of
    the colony that simulates the second cell
    of colony that simulates the cell $z_k$ of $M_k$
\label{fig:root-address}}
\end{figure}





\subsection{Building the initial configuration}\label{subsec:init}

    Let $M$ be a Generalized Turing Machine, whose
    cells are initialized to $\Vacant$.

    Let $K$ be a constant that we will determine later.

    Suppose that we are given any Turing machine $G$,
    its input $x$, its starting state $q_\start$,
    and the time $T_G$ it needs to reach
    the halting state $q_f\in F$, when it writes the result
    in the origin of its tape.

    \begin{enumerate}

%
%    \item
%        Using the encoding $\varphi_{(K+c)*}$,\Inote{WOW this notation looks very ugly! Help!}
%        we encode its initial configuration
%        to the initial configuration $\xi^{K+c}$ of a Generalized
%        Turing machine
%        $M_{K+c}$, where
%        \begin{align}\label{eq:c}
%              c
%        \end{align}
%        is a constant nonnegative integer to be defined later.
%        We set the value of $\Active$ field of the tape to
%        $1$ all over the tape.

    \item
        Using the encoding $\varphi_{K*}$,
        %\Inote{WOW this notation looks very ugly! Help!}
        we encode the initial configuration of $M$
        to the initial configuration $\xi^{K}$ of a Generalized
        Turing machine
        $M_{K}$.
        %, where
%        We set the value of $\Active$ field of the tape to
%        $0$ all over the tape.

%    \item
%        Then, we encode $\xi^{K+c}$ to the initial
%        configuration $\xi^{K+c-1}$ of $M_{K+c-1}$,
%        initial configuration $\xi^{K+c-1}$ to the
%        initial configuration $\xi^{K+c-2}$ of $M_{K+c-2}$
%        and so on, up to $M_K$.


    \item
        For $i\in \bbZ$, let $x_i$ denote the position
        of the $i^{\tth}$ cell of $M_K$
        with respect to
        $z_{K}$ (determined in~\eqref{eq:origin-value}).
        That is, let
        \begin{align*}
           x_i = z_K + i\B_K.
        \end{align*}
        Then, for each $i\in\bbZ$, we set
        the
        $\cSimInfo$ field of cell $x_i$ of $M_K$
        to the corresponding value of $G(x,0).\tape[x_i]$.
        The initial state $q_{\start}$ of $G$ is stored
        in the $\cSimState$ field of cell $x_0=z_K$
        of $M_K$.

        Finally, we set the value of $\Active$ to $0$
        all over.

    \item
        We encode $\xi^K$ using $\varphi_{K-1_*}$ into
        the initial configuration $\xi^{K-1}$ of
        $M_{K-1}$.
        We set the $\Active$ field to $-1$, on
        each cell of $M_{K-1}$.

        We repeat this for the subsequent levels with specific
        encodings,
        until we reach the
        initial configuration $\xi^1$, which is a code
        configuration for $M_1$.

\end{enumerate}

\section{Combining it all together}

%Now, as we have defined the simulations and
%the code configurations, Lemma~\ref{lem:simulation-step}
%implies that the machine $M_1$ simulates $M_2$, which
%simulates $M_3$, and so on, where $M_1$ is a Turing machine
%whose set of final states is empty, and $M_i$, $(i>1)$,  are
%generalized Turing machines, whose level is $i$, cell body
%size $\B_i$ and colony size is $Q_i$.

The main purpose of this construction is
to simulate a given (customer's) machine $G$
in presence of noise.

Recall that $\cSimInfo$ field is of the same length
on $M_i$, for every $i\geq 1$.
Below,
we will use $\cSimInfo^i$
when referring to the $\cSimInfo$ of a cell
of machine $M_i$.
We will do the same for other fields whenever needed.

Now we characterize a kind of ``robustness'' that
we expect from the tower with respect to the side-simulation.
That is, we want to characterize the reliability of the
side simulation carried out by the tower.

\begin{definition}[Error-correcting property of a tower]\label{def:ec-tower}
  A tower $(\sS, \sM)$ has \df{error-correcting} property
  for the field $\cSimInfo$, if for every $k\geq 1$ the
  following holds.

  Suppose that the cell $\eta^{(k+1)}(t)(z_{k+1})$ exists,  and
  let $t'=t + u\Tu{k}$ for some $u\in[0,\U_k)$.

   If $t' + (-\Tu{k+1}, 0]\cap \Noise^{(k)}=\emptyset$,
   and $\eta^{(k+1)}.\Active(z_{k+1})\leq 0$,
   %$0\leq u \leq \U_k$
   then $\eta^{(k)}(t').\SimInfo(z_{k})$
   is equal to the $\cSimInfo^*$ field of
   the codeword $\varphi_{k*}(\eta^{(k+1)}(t))$
   stored in the $\Info$ track
   of the colony
   containing cell $z_{k}$.
%   $\eta^{k+1}(t).z$
\end{definition}

Let
\begin{equation}\label{eq:U_c}
\begin{aligned}
  \Uc &= O(Q^2) \\
  \Ut &= O(Q^2)
\end{aligned}
\end{equation}
denote the number of steps needed to
perform the computation phase of a work period, and
a transferring phase, respectively.
Obviously, $\Uc + \Ut = \U$.


\begin{lemma}[Tower]\label{lem:Tower}
   For some constants  $\Dw$, and $Q$,
%   and a sequence $Q_1, \dots, Q_k, \dots$,
   there is a tower
   $$(\sS, \sM)$$
   that has the error-correcting property for
   the field $\cSimInfo$.
\end{lemma}
\begin{Proof}

    Indeed, in Subsection~\ref{subsec:init} we
    demonstrated how one can obtain
    an initial configuration for machine $M_1$.%
%    Let $I$ be the space interval corresponding to the
%    non-vacant part of the tape in the initial configuration.

    Recall the definition of $\Noise^{(k)}$  in~\eqref{eq:noise^k}.

    We can build such a tower by
    starting from machine $M_1$ and defining
    the simulation of $M_2$ according to
    Lemma~\ref{lem:simulation-step}.
    Since $(\eta^{(1)}, \Noise^{(1)})$ is a trajectory,
    according  to Lemma~\ref{lem:trajectory},
    $(\eta^2, \Noise^{(2)})$ is a trajectory as well.
    We continue with this process for $(\eta^{(3)}, \Noise^{(3)})$, and so on.


% you need to start formally from the definition of that property,
% and prove step-for-step, how that property follows from, indeed, the fact that in the absence of
% big burst locally, you can annotate locally.
    Let us show that the tower has the error-correcting property for
    the field $\SimInfo$.
    Consider the trajectory $\eta^{(k)}$, and suppose that
    cell $z_{k+1}$  of $\eta^{(k+1)}$ exists at time $t$.
    Lemma~\ref{lem:recovery}, implies that it can be annotated on
    a space-time rectangle containing $t$ and $z_{k+1}$ as long as no
    $\Noise^{(k+1)}$-bursts occur, which we assume.

    If $z_{k+1}$ is the current cell, then by time $t'$, $t' \geq t + \U_c\Tu{k}$
    the machine has carried out parts of the program  dedicated
    to the side-simulation as described in Section~\ref{sec:simulationOf-G},
    even after an eventual burst or recovery of an island that is encountered
    during this work period.
    Namely, if $\eta^{(k+1)}(t'').\Active(z_{k+1})=0$ for any $t''>t'$, then
    a step of the side simulation is carried out and the result---
    that is stored in $\SimInfo^{(k+1)}$ and is encoded in
    $\eta^{(k)}.\Info$ track of the base colony that decodes
    to the cell $z_{k+1}$ --- gets stored in each $\SimInfo^{(k)}$ field
     of $\eta^{(k)}$ in each cell of the
    colony that decodes to $z_{k+1}$.
    Similarly, if $\eta^{(k+1)}(t'').\Active(z_{k+1})=-1$ for any $t''>t'$, then during
    the computation phase the result is only copied from
    $\eta^{(k)}.\Info$ track of the base colony that decodes
    to the cell $z_{k+1}$ into the $\SimInfo$ field of every cell of this colony.
    Since $z_{k+1}$ exists, then
    $z_{k}$ exists also.
    Hence, we repeat the same argument to show that
    the same holds true for  all levels below $k$, up to the ground
    level, where the result is read at the $\SimInfo$ field of $z_1$.
\end{Proof}


%In the proof of Lemma~\ref{lem:sparsiness},
%we have defined the event $\cF_k$ and
%computed its probability.
For $k>0$, let $\cF_k$ be the event that
$$(\h,t) + [\Tu{k+1}, 0]\times [-\B_{k+1}, \B_{k+1}] \cap \Noise^{(k)} = \emptyset.$$



Above we have seen that conditions of Lemma~\ref{lem:sparsiness}
are satisfied with our choice of constants.
It implies that
In the proof of this lemma,
 we have computed
the $\Pr[\bigcap_k\cF_k]>1-O(\varepsilon)$.

At some level $K'$,
one step of $G$ will be simulated within time $\Tu{K}$.

We want to set the active
level high enough on the tower where
bursts are highly improbable.
As
the probability that the noise around
the head is not $k$-sparse is decreasing doubly
exponentially with $k$,
we set
%From the convergence criteria for
%\begin{align}%\label{eq:prob-sum}
%   \sum_{k>0}T_G\Tu{k} 2\varepsilon 2^{- 1.5^k}
%\end{align}
\begin{align}\label{eq:K-value}
  K = c_1\log\log T_G + c_2,
\end{align}
for some $c_1, c_2>0$.
%However, at this level, one step of $G$ is not
%simulated within $\Tu{K}$.
%Indeed, consider the case when the current
%cell of $G$ is the first cell of a colony $C$ of $M_K$, and
%the head of $G$ wants to move left and in the same
%time $M_K$ is transferring far to the right and will come
%back to the first cell of $C$ much later.
%But at some level $K'$ such that
%\begin{align}\label{eq:fitting}
%  \frac{T_G\B_K}{\B_{K'}}\leq 1,
%\end{align}
%the entire space of $G$ will fit in one
%cell of $M_{K'}$, and therefore we can be sure
%that for any $G$ one step of $G$ is simulated
%within $\Tu{K'}$.
%Let $K'\geq 2K$.
%From~\eqref{eq:fitting} we obtain
%\begin{align*}
%  3^{K-1}(3^c-1) \geq 2 \frac{\log T_G}{\log Q} \\
%  3^c \geq 2 \frac{\log T_G}{3^{K-1}\log Q}.
%\end{align*}
%By taking the logarithm of both sides of the inequality, and
%using the definition of $K = c_1 \log \log T_g + c_2$,
%we obtain
%\begin{align*}
%  c &\geq K - 1 + \frac{1}{\log 3}\left(\log 2 + \log\log T_G - \log\log Q\right) \\
%    & \geq (c_1 + \frac{1}{\log 3})\log\log T_G + c_2 -1 + \frac{1}{\log 3} (\log 2 - \log\log Q).
%\end{align*}
%Therefore, we can take $K'\geq 2K$, and
%choose $Q$ such that~\eqref{eq:upper-bound-on-Q} holds for
%all $i\leq K'$.



Let $$\widehat{T_G} = T_G\Tu{K},$$
and for $t\geq \widehat{T_G}$, let
$t_k = t - (t \bmod \Tu{k})$.

Let $\cG_k$ be the event that
$\eta^k(t_k).\SimInfo(z_k)$
is $G(x,T_G).\tape[0]$.

For every $k$, $1\leq k \leq K$,
$\cG_{k} \cap \cF_k$,
the error-correcting property of the tower
implies that $\cG_{k-1}$.

%If we assume that  $\cF_k$ hold for each $k\leq K$,
%then
Event $\cG_K$ implies the event  $\cG_{K-1}$ if $\cF_K$
holds;
event $\cG_{K-1}$ implies the event  $\cG_{K-2}$ if $\cF_{K-1}$
holds; and so on, until
$\cG_1$.

%Using the % definition of $\varepsilon_0$
%%in~\eqref{eq:varEps0} and the
%union bound,
%we  estimate the probability that
%$\cF_i$ holds for all $i=1,\dots,K'$, as follows
%\begin{align*}
%   \Pr\left[\cF_1 \cap \cF_2 \cap \dots \cap \cF_{K'} \right] = &
%   \Pr\left[\neg \cF_1 \cup \neg \cF_2 \cup \dots  \cup \neg\cF_{K'} \right] \\
%   \leq &\Pr[\neg \cF_1] +\cdots + \Pr[\neg \cF_{K'}] \\
%   \leq &%\varepsilon_0 +\cdots + \varepsilon_0 =
%    O(\varepsilon_0).
%\end{align*}

We set $f$ to be a projection from the
alphabet of $M_1$ to the alphabet of $G$,
defined by $f(s)=s.\cSimInfo$.
The probability that
the $\cSimInfo$ of the origin of $M_1$
is equal to $\cSimInfo$ of the cell
$z_K$ of $M_K$ is $1 - O(\varepsilon_0)$
for all time moments $t$,
$t \in [C T_G , Q C T_G)$,
and constant  $C$
is
$$C = (\log T_G)^{O(1)},$$%and $C_2$ that we obtain
which follows from~\eqref{eq:U_i} and~\eqref{eq:K-value}.

%    Now, we set the constant $C$ in the Main Theorem
%     \begin{align*}C= D^{k} Q^{3^{k} - 1}.\end{align*}

The code of the Main Theorem is the hierarchical
code
obtained from  $(\phi_{i*}, \phi^{*}_i)$, whose
block size is
\begin{align*}
   \B_K = Q^{K-1}. %= Q^{\frac{3^{K-1} - 1}{2}}.
\end{align*}

With this, we have completed the proof of the Main Theorem~\ref{thm:main-main}.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% Chapter Proof of the Trajectory
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\chapter{Proof of the Trajectory Lemma}\label{sec:larger-damage}

In Chapter~\ref{sec:1-level-noise} we have shown that
every trajectory of a generalized Turing machine $M$ that
is annotated on a space-time rectangle $A\times \tau$,
remains annotated as long as no large bursts occur
and the head does not leave $A$.
For that purpose, the recovery procedure and
the properties of the trajectory,
were enough to remove the
damage that the head may encounter, which --- due to the
conditions of annotatedness --- is only bounded to the islands,
and further, the number of islands in each colony does not exceed
3.
%Under such circumstances, the rebuild procedure was called
%only by a burst, and it never passes the bootstrap stage of
%the procedure.
While the head of $M^*$ is in such an island of damage, the behavior of
the machine is nondeterministic, and the cell structure in it
may be ruined.
However, the trajectory properties guarantee that the damage
slowly gets eliminated each time the head steps in such
an island and stays in it.

In order to maintain this capability on every level,
it remains to prove
that the properties of trajectory remain invariant
under our simulation.
In other words, we want to prove that a simulation by a trajectory is
a trajectory.

In Section~\ref{sec:recovery-failure} we introduced the rebuild
procedure that rebuilds the colony structure on a larger
area whenever it is ruined.
In this chapter, we will  show how machine $M$ deals with a
a damage of a larger scale (see Definition~\ref{def:damage-scaleup}),
and how does the history becomes annotated again on large enough
space-time intervals.
The removal of $\Damage^*$ from a large space interval
is preceded by the removal of damage, since it is an obstacle
to the normal functioning of the rebuild procedure and the machine
in general.



For any generalized Turing machine
\begin{align*}
   M = \left(\Gamma, \Sigma, \delta, q_{\start}, F, \B,  \Tu{}\right)
\end{align*}
and
simulation
\begin{align*}
    (\varphi_*, \Phi^*)
\end{align*}
defined in Lemma~\ref{lem:simulation-step},
assuming that $(\eta, \Noise)$
is a trajectory, we want to prove
that the history
\begin{align*}
    (\eta^*, \Noise^*)
\end{align*}
is a trajectory of a generalized Turing machine
\begin{align*}
    M^* =
    \left(\Gamma^*, \Sigma^*, \delta^*, q_{\start}^*, F*^, \B^*,  \Tus\right).
\end{align*}

From now on and throughout this chapter, whenever we
use the term a ``burst'', it always refers to bursts in
$\Noise$.
Recall the definition of $\Damage^*$ given
in Definition~\ref{def:damage-scaleup}.
From now on, unless stated differently, whenever we say that
a cell is damage-free, we refer to $\Damage$ of $\eta$.

In sequel, we will first introduce the notion of a fully-annotated
configuration that encapsulates the largest spectrum of configurations
allowable in our simulations.
Then, fully annotated configurations over small intervals will be called
fragments, and we will see below that the properties of our program, and
the properties of $\eta$ lead to their growth and to, in a sense,
a ``convergence'' of the history towards an annotated one.

The main complications are due to the presence of $\Damage$ and
$\Damage^*$ simultaneously.



%We need to prove
%that for any trajectory $(\eta, \Noise)$ of $M$,
%$(\eta^*, \Noise^*)$ is a trajectory of $M^*$.





\section{Full annotations}

The notation and the definitions that we used so far, needs
to be generalized in order to include
the case when the machine is in a ``large scale damage''.


\begin{definition}[Fully annotated configuration]
    A \df{fully annotated configuration} of machine $M$
    whose cell body size is $\B$,
    on
    interval $A$, of length at least $Q\B$ that contains the head,
    is a sextuple
         \begin{align*}
             \cA=(\xi,\chi, \cI,\cS, \D, \cL),%, \Damage^*),
         \end{align*}
    with the following meaning.
    $\xi$ is a configuration,
    $\chi$ is locally healthy configuration on $A$,
    $\cI$ is a set of intervals of cells called \df{islands},
    $\cS$ is a set of intervals of cells called \df{stains},
    $\D$ is an interval containing
    the head called the \df{distress area}, and
    $\cL$ is an interval containing the head called the \df{rebuild
    area}.

    The rebuild area contains elements of $\Damage^*$ containing
    the head.
    Its size does not exceed $<12Q\B$.

    We can obtain $\chi$ from $\xi$ by:
    \begin{enumerate}
      \item Killing of at most $6Q$ cells in $\cL$;
      \item Creating a new colony of size $Q$ surrounded
      by at least $Q/2$ damage-free cells on each side;
      \item by doing admissible changes in a part
      of $\cL$ that contains cells that are not stem.
    \end{enumerate}

    Suppose that
     $|A|\geq Q\B$ and that $\xi.\pos \in A$.
    The \df{current colony} of $\cA$ is
    the base colony of $\chi$.

    We say that an interval $W$
    is the (extended) \df{workspace} of the annotated
    configuration $\cA$ if it is the
    (extended) workspace of $\chi$.

    We require the following additional properties:
    \begin{enumerate}[(a)]
        \item If $\Damage^* \cap A = \emptyset$ then $\xi$ is annotated
        on $A$.

        \item If $\cL = \emptyset$, $\Damage^* \cap A = \emptyset$, and
            $\D$ is empty then the mode is normal.
    \end{enumerate}

%    We say that a cell is \df{semi-free} in a fully annotated configuration
%    on $A$
%    when it is not in $\Damage^*$ or $\cL$.
%    The head is \df{semi-free} $\cL$ is empty.

\end{definition}


Similarly as we did for the sweep number of
the simulation, we can define the range of $\Rec.\Sweep$ and
$\Arb.\Sweep$.

\begin{definition}[Range of a recovery or rebuild sweep]\label{def:range-rec-arb}
    Let $\xi(I)$ be a fully annotated configuration such that
    $I$ does not intersect any damage.
    Suppose that the head is at a position $x$,
    $\Rec.\Addr(\xi(x))=0$ and $\Rec.\Mode=\Recovering$.

    The range of $\Rec.\Sweep=1$ is $[x, x+\loc\B)$, and the
    range of $1<\Rec.\Sweep\leq 10$ is $[x-\loc\B, x+\loc\B)$.
    Depending on $\dir(\chi.\Sweep)$,
    the range of $\Rec.\Sweep = 11$ is $[x-\loc\B, x+\E\B)$ or
    $[x - \E\B, x + \loc\B)$.
    Further, the range of all the sweeps until mopping stage
    is $[x - \E\B, x + \E\B)$.

    Suppose that $\hat\R \in\set{\R, \R_0^2, \R_2^0}$.
    The ranges of the last two sweeps in mopping
    include $\Rec.\Z_b\B$-stretches outside of the recovery
    interval.
    The range of the last sweep of mopping is reduced up to the front.

    Suppose that $\hat\R \in\set{\R_0^4, \R_2^4}$
         (resp., $\hat\R \in\set{\R_4^0, \R_4^2}$)
    The range of the last sweep of mopping is $\R$
    and it includes
    the $4\beta\B$-stretch to the left (resp., right) of $I$.

    In a similar way, we can define the \df{range} of
    a rebuild sweep.
\end{definition}





%Now, let us give the notion of a generalized history.

%\Inote{This may not be needed}
%
%\begin{definition}
%
%    Let $\tau = [t, t+k)$, for $t, k\in\bbZ_{+}$.
%
%    An \df{fully annotated history} of
%     $$M_i=(\Gamma_i,\Sigma_i,\delta_i,q_{\start},F,B,\Tl(i),\Tu(i)), \; i\in \bbN$$
%     on a space-time rectangle
%     $A\times \tau$,
%    is a sequence of $k$ fully annotated configurations on $A$,
%    if its sequence of underlying configurations is a
%    trajectory snippet of size $k$ starting from $t$ of
%    $\eta$,
%    and it satisfies some additional requirements given below.
%
%    A time that is not distress-free and was preceded by
%    a distress-free time
%    will be called a \df{disruption event} if $\cL\neq \emptyset$.
%
%    Consider a time interval $\lint{t_1}{t_1+u}$ starting
%    with a disruption event and ending with the head
%    becoming free again, in a annotated history on a
%    space interval $I\subset A$,
%    $|I|\geq 2Q_i\B_i$, and time interval $\tau'$ of
%    length at least $\U_c\Tu(i)$.
%    It is called a \df{stabilization event} %of \df{duration} $u$
%    if the only possible islands that remain from the rebuilding area
%    are due to some $(\beta_i,V_i)$-bi-burst
%    that occurred at a time intersecting $\lint{t_1}{t_1 + u}$.
%
%    Recall the definition of the parameter
%    $\K_H$ in~\eqref{eq:K_H}.
%    The additional requirements for fully annotated history are:
%
%    \begin{enumerate}[(a)]
%
%        \item \label{i:fully-annotated-hist.progress}
%            Islands (whose size does not exceed $\beta\B_i$)
%            are only created
%            by $(\beta_i, V_i)$-bursts.
%
%            Rifts are created by $(\beta_j, V_j)$-bursts, $j>i$.
%
%            Rebuild area starts as a distress area that intersects
%            a rift.
%
%       \item \label{i:fully-annotated-hist.damage-progress}
%            Rifts have
%            a \df{progress indicator} that is a pair of
%            two nonnegative integers $(\Ed, \Sd)$
%            such that $\Ed\in \set{0,\dots, 5, 6}$ is increased each time
%            the head enters into it,
%            and $\Sd$ is the total time that the head
%            stays in it.
%
%        \item\label{i:fully-annotated-hist.stabilization}
%            Each disruption event is followed by a stabilization event.
%
%%            Let $A'$ and $A''$ be two two disjoint subintervals
%%            such that $A'\cup A'' = A$.
%%
%%            1) If $\eta$ is annotated
%%            on $A'\times \tau$ and $A'' \times \tau$, but not on
%%            $A \times \tau$,
%%            then, there is an interval $I\subseteq A$, $|I|\geq Q_i\B_i$,
%%            such that $I\cap A', I\cap A'' \neq \emptyset$,
%%            $|I|\geq Q_i\B_i$.
%%            Further, $\eta$ becomes annotated
%%            on $A\times \tau'$, for $\tau'$ that begins with
%%            the time moment
%%            $t'$ such that either $\Ed(I)\geq 5$ or
%%            $\Sd(I)\geq 5\U\Tu(i)$.
%%
%%
%%            2) If $\eta$ is annotated on $A'$ (resp., $A''$)
%%            but not on $A''$ (resp., $A'$), then
%%            there is a subinterval $I\subseteq A$, $|I|\geq Q_i\B_i$,
%%            $I\cap A', I\cap A'' \neq \emptyset$, such that
%%            $\eta$ is annotated on $(A'\cup I)\times \tau'$
%%            (resp., $(A'' \cup I)\times \tau'$)
%%            for $\tau'$ that begins with
%%            the time moment
%%            $t'$ such that either $\Ed(I)\geq 5$ or
%%            $\Sd(I)\geq 5\U\Tu(i)$.
%%
%%            3) If $\eta$ is not annotated on neither $A'$
%%            or $A''$, then for some subinterval $I \subseteq A$,
%%            $|I|\geq 2Q_i\B_i$,
%%            $\eta$ becomes annotated on $I\times \tau'$,
%%            for $\tau'$ that begins with
%%            the time moment
%%            $t'$ such that either $\Ed(I)\geq 5$ or
%%            $\Sd(I)\geq 5\U\Tu(i)$.
%        \end{enumerate}
%\end{definition}
%
%


\section{Robustness of the rebuild procedure}

In conditions of Chapter~\ref{sec:1-level-noise},
 the rebuild procedure
is initiated only
by a burst, and the recovery in such
conditions never fails.
Even though the recovery procedure has its own
structure, since it runs on small intervals and has
a fixed time-frame, we did not introduce any
way to restore its state in case that, say, a burst occurs.
As we have seen, a simple restart of the recovery in
an annotated history will always result in
a relief event.

Unlike the recovery procedure, the rebuild procedure
runs over a large space interval, and its size
depends on the content of the cells.
It also uses zigging,  multiple repetitions,
and the majority voting
to make sure that bursts do not affect
the outcome of its decisions and actions.

In Subsection~\ref{subsec:RebRestore}  we have shown
how, under certain conditions,
the structure of the rebuild procedure may be
restored in the case that alarm is called for any
of the possible reasons.
In the following lemma, we give the minimal conditions
needed for the rebuild procedure to be able
to restore its structure and continue seamlessly, if
it is interrupted.

Recall the definition of the parameter $\loc$ in~\eqref{eq:loc}.


\begin{lemma}\label{lem:burst-rebuild}
  Suppose that
  alarm is called at a position $x_0$
  during the rebuild procedure
  whose cover $L$ is contained in a damage-free interval,
  and if $[x_0 - \E\B, x_0 + \E\B)$
  does not intersect $L$ in a stretch of more than
  $\Z$ cells,
  it
  intersects
  an admissible configuration
  whose direction of the sweep
  points to the cover, or
  an interval of stem cells whose drifts point
  to the cover.
%  or a restorable configuration (see Definition~\ref{def:restorable})
%  whose direction  of the $\Arb.\Sweep$ is 1 and its range
%  intersects $L$ for more than $\E\

  If alarm is called when the
  head is not farther than $\E + 2\loc$ cells apart from
  the rebuild cover,
  then, the procedure continues within
  $3\K_R\Tu{}$.
\end{lemma}
\begin{Proof}
    Let $x_0$ be the position where alarm is called.
    If $x_0$ is more than $\E$ cells inside the cover,
    then the proof follows immediately by following
    the bootstrapping stage of the rebuild procedure.

    Without loss of generality, let us assume that
    $x_0$ is to the left of the rebuild cover.

    Suppose that the head steps in an island in
    a $\loc\B$-neighborhood of $x_0$.
    As to the left of $x_0$ we have cells whose sweep direction
    point to the cover, and on the right side we have marked cells,
    the head cannot leave the island of damage (if there is one)
    without entering into it many times until it becomes
    damage-free, as guaranteed
    by the properties~\eqref{i:def.traj.attack-from-outside}
    and~\eqref{i:def.traj.damage-within}
    of Definition~\ref{def:traj}.
    Once that happens, a new alarm is called in a
    $\beta\B$-neighborhood  of $x_0$.
    From now, we assume that there is no further damage on the tape.


    \begin{step+}{step:robust.1}
        Suppose that this alarm is called farther than $\E$ cells from
        the rebuild cover.
        Now, the recovery interval does not intersect the rebuild
        cover.
    \end{step+}
    \begin{prooofi}
        \begin{step+}{step:robust.1.claim}
            We claim that a new alarm is called within $\loc$ cells from
            the cover.
        \end{step+}
        \begin{pproof}
            Indeed, if the underlying interval
            is not comprised of stem cells, then the admissibility and our assumptions
            guarantee that the head is left on the endpoint closer
            to the rebuild cover.
            Further, even if the underlying interval before the
            head stepped in it was vacant,
            the only way for the head to reach
            farther than $\loc$ cells from the cover was in
            recovery mode.
            As in such cases the recovery procedure always
            creates stem cells whose drift points to the
            center of the recovery, and
            since
            the rebuild procedure whenever it creates
            stem cells, their drift always points to the
            base colony,
            the Patching Lemma~\ref{lem:patching}
            guarantees that even when the recovery
            interval contains mostly stem cells,
            the head is left on the endpoint
            of the recovery interval that is closer to
            the rebuild cover.

%            Suppose that the recovery interval intersects a rebuild
%            cover whose $\cArb.\Sweep$ is odd and hence it
%            points to the right.
%            Then, the recovery procedure will clearly fail, and then
%            bootstrapping stage of the rebuild procedure begins.
%            Then, since this configuration is restorable, and the pivot
%            is not in it, the recovery marks will be removed and the head
%            will be left at the rightmost cell of the recovery interval,
%            where alarm is called.
%            Now, the recovery procedure will fail again as it intersects
%            the $L$ and it will restore the state of the rebuild procedure
        \end{pproof}
    \end{prooofi}

        \begin{step+}{step:robust.2}
            If alarm is called within $<0.8\E\B$
            from the cover, then
            as the recovery interval will intersect
            the rebuild cover, the
            recovery
            will fail and call $\GiveUp$.
        \end{step+}
        \begin{prooofi}
            The new rebuilding procedure starts and,   in its
            bootstrapping stage, will check for the failing marks
            left by the recovery procedure, and then it
            will restore the state of the
            previous
            rebuilding procedure, once it corrected the rebuild
            structure in at most
            $2\beta$ cells contained in the recovery interval.
        \end{prooofi}
\end{Proof}


From the proof of this lemma, we can see that whenever
alarm is called at least $\E\B$ inside the rebuild cover,
then the restoration of the structure is possible.
When alarm is called outside of a rebuild cover,
we can do the same provided that the recovery interval, besides
eventually the cover, it also intersects an admissible configuration.








\section{Fragments}

When considering  a large scale damage, the notion
of a tissue is not enough.
We need to introduce smaller entities with
certain structure that we
call fragments.

Recall the definition of a growing sweep and of the
range of a sweep given in
Definition~\ref{def:healthy1}.


\begin{definition}[Fragments]\label{def:fragments}
    A fully annotated configuration $\xi$
    on an  interval $I$, $|I|>0$
    is called a \df{fragment}.


    A fragment $\xi(I)$ is \df{active}, whenever the machine
    is in that configuration, and the head is in $I$.
    If the head of the machine is inside $I$, but in a different
    state, then $\xi(I)$ is \df{invaded}.
    In particular, if  $\xi(I)$ is active
    while $\xi'(I')$ is invaded,
    then we say that $\xi(I)$ \df{invades} $\xi'(I')$.

   % Fragment $\xi(I)$ is \df{compatible}
%    to fragment $\xi'(I')$
%    if $d(I,I')\leq 6\beta\B$ and $\xi$ is admissible
%    on the smallest interval covering $I\cup I'$.

    A fragment $\xi(I)$ is \df{inactive} whenever
    the head of the machine is not in $I$.


    %Let
%    \begin{align}
%      \si(\xi(I)) \\
%      \sa(\xi(I))
%    \end{align}
%    denote the time that fragment $\xi(I)$ was invaded
%    and the time that the fragment was active.
    Let
    \begin{align}
      \st(I) %= \sa(\xi(I)) + \si(\xi(I))
    \end{align}
    denotes the \df{total time} that the head was in
    $I$.%, \ie the time when the head was active or invaded.

    A fragment is \df{growing} to the left (resp., right)
    if the left (resp., right) boundary of the
    range of its sweep $s$ whose direction is
    to the left (resp., right) is not in $I$.

    If a fragment
    %does not contain both endpoints
%    of the range of its sweep or
    intersects $\Damage$,
    then it is \df{bad}.


We distinguish the following types of fragments.
    \begin{bullets}
        \item If $\xi$ is annotated on $I$ and $\xi(I).\D = \emptyset$,
        then the fragment is of a \df{simulation} type.

        \item If $\xi(I).\D \neq \emptyset$, then it is of a \df{recovery}
        type.

        \item Finally, if $\cL\neq \emptyset$ on $\xi(I)$,
        then it is of a \df{rebuild} type.
    \end{bullets}


With some abuse of notation, we will usually refer
to a fragment by just specifying the underlying
space interval.
\end{definition}

Since zigging, besides in simulation
is used in recovery and rebuild procedures
as well,
we can define a corresponding notion to the front.

\begin{definition}[Pivot]\label{def:pivot}
    Consider a fragment $\xi(I)$, where $I$ does not
    intersect damage.

    The farthest position to which the head has
    advanced before starting a
    new backwards zig during the recovery (resp., rebuild)
    procedure
    is called the \df{pivot} of the recovery (resp., rebuild)
    fragment $\xi(I)$.
%    and is defined by
%     \begin{align*}
%         \piv(\xi) = \xi.\pos + \ZigDepth\cdot d,
%     \end{align*}
%    where
%    $d$ is the parity of $\xi.\Rec.\Sweep$ (resp., $\xi.\Arb.\Sweep$),
%    and $\xi.\pos$ is the head position.
\end{definition}



Let us now consider an important feature of fragments.

\begin{example}[Crippled fragments]\label{xmp:crippled}
%    How can a fragment become crippled?

    Let us consider the case of a simulating fragment
    during the transferring sweep, when the machine
    attacks the damage to the right, at a cell $y$.

    Suppose that a burst occurs and increases the $\Sweep$
    for one, and hence changes the direction.
    In this case, the head moves to the left
    for at most $(\Z - \Z_b)\Tu{}$, and then zigging brings
    the head back to the damage.
    Suppose that the head continues to the right, and that it
    returns again much later, after at least $\Tus$,
    and repeats the same.
    However, with each attempt, the front is pushed further left,
    and when the front is more than $\Z\B$ far from $y$,
    our program does not allow the head to step inside
    the fragment in normal mode without calling an alarm,
    as the direction of the sweep from the front to
    $y$ now is to the left.
    Hence, from this moment the head cannot
    step inside the fragment in normal but only in one of the
    recovery procedures.% which will guarantee damage removal.

    The head cannot ``avoid'' returning to this fragment for a
    long time, as this restricts its range of movement, during
    which, other damage will be removed, as guaranteed by the
    trajectory assumption for $\eta$.
    Then, the feathering property of our program
    guarantees that the head
    returns to this area, while removing the damage in between.

    In sequel, we will pursue this idea further.

\end{example}



Let us characterize an important kind of fragments
that cannot be activated without the use of a recovery
procedure or rebuild procedure.

\begin{definition}[Crippled
and condemned
fragments]\label{def:condemned}


  Consider a recovery (resp., rebuild) fragment $\xi(I)$,
  and suppose that the
  head is in direction
  $-\dir(\xi.\Rec.\Sweep)$
  (resp., $-\dir(\xi.\Rec.\Sweep)$, where $\dir$ is defined
  in~\eqref{eq:Dir}.

  A  recovery or rebuild fragment (resp., simulation fragment)
   is \df{crippled} if
  the pivot (resp., the front)
  is at least $\Rec.\Z\B$ (resp., $\Z\B$) inside
  $I$.

  If cells of a fragment do not point towards the head,
  then the fragment is \df{condemned}.


\end{definition}

  A recovery and a rebuild procedure
  may restore a crippled fragment.
  In contrast to that, condemned fragments will be killed
  once invaded by a rebuild fragment.

The following statements follow immediately from
the definitions and from the program of the simulation
described in Chapter~\ref{sec:blueprint} and the program
of the recovery and rebuild procedures.

\begin{fact}\label{fact:fragment}
  \begin{enumerate}

    \item\label{i:fact:fragment.rec-reb-strength}
    Recovery and rebuild fragments can invade
    fragments of any type.

    \item Rebuild fragments always start out
    as recovery ones.

    \item \label{i:fact:fragment.annotated}
      Simulation fragment $\xi(I)$ can invade
      simulation fragment $\xi'(I')$
      if
      $d(I, I')\leq 3\beta\B$ and
      $\xi$ is annotated on $I\cup I'$, where
      $|I|, |I'|\geq 3\E\B$.

      %If any of the first two conditions
%      are not satisfied, a rebuild
%      fragment on $I\cup I'$ is created.


    \item
    \label{i:fact:fragment.interaction}
       Whenever a simulation fragment invades
       a recovery  fragment, they both get invaded
       by a recovery fragment.
       If the latter fragment is annotated,
       then the simulation fragment's
       underlying interval expands for
       $0.8\E\B$ after the recovery fragment
       vanishes, and the simulation
       fragment becomes activated again.


   % \item ? Simulation fragment of size $<Q\B$
%      can be passed at most twice.
%      After that, it can only be invaded.

  \end{enumerate}
\end{fact}



\subsection{Growing to attack}


%Consider a fragment $\xi(I)$ that is
%annotated and $\xi.\D=\emptyset$,  whose $\xi.\Sweep$ is
%growing.
%Suppose that $I$ does not contain the part of
%the space where it is growing into.
%Then, such a fragment is \df{growing}.
%
%We can define the growing fragments of
%other fragments in a similar fashion.

Recall the notion of a \df{damage attack} given
in Definition~\ref{def:traj}.


%Let $F:=[a,b]$ be any damage-free fragment that is
%growing.
%
%A program has a \df{persisting damage attack property}
%if
%whenever the head steps off a growing fragment
%onto damage,
%the attacks will be continued until at least
%$\E\B$ cells in the direction of the growth of $F$
%next to the range endpoint of its sweep is damage-free, while
%no bursts occur when the head is,


In Lemma~\ref{lem:damage-cover} we have seen
that in an admissible configuration,
islands of damage that are inside the range
of the sweep of a satisfying healthy configuration
will always be removed.

In the following lemma, we will see that
the same is true for all three distinguished types
of fragments.

\begin{lemma}[Persisting attacks]\label{lem:persistent}
    Consider a fragment $F$ that is surrounded
    by damage in one side, and is
    surrounded by a damage-free interval
    on the other side.

    When a damage-free recovery (or rebuild)
    fragment $F$ is growing over damage,
    then attacks
    on the damage %whose size is greater
%    than $6\loc\B$
    do not cede until the damage
    is removed from the range of the
    fragment's sweep.
\end{lemma}
\begin{Proof}

 We will show our claim for the recovery type
 fragments.
 The proof for the rebuild type fragments
 is similar.


    Consider a recovery fragment $F=[a,b]$, and
    suppose that it is growing to the right side.
\begin{step+}{step:lem:persistent.nobursts}
    Assume first that no bursts occur.
\end{step+}
\begin{prooofi}

    Whenever the head steps
    off such a fragment, hence attacking the damage,
    then by the properties of the trajectory,  %and by the emergence
%    property of the program (see Definition~\ref{def:generic}),
    assuming that no bursts occur,
    %alarm is called at a cell that is $<2\B$ from
    %the fragment, and the space in between it and the fragment
    %is damage-free.
    %either the transition function is carried out and
    %the neighbor cell of $b$ to the right is
    %damage-free and $b$ becomes flagged;
    %or
    by the time when the head returns back to $b$,
    $[b, b+2\B)$ is damage-free. %
    The machine at this time can either be in
    the recovery mode and continue the recovery seamlessly
    or start a new recovery;
    or it can be in normal mode, which will cause alarm
    as soon as the head steps to the left
    of $b$; or it can be in rebuild mode.



    %Indeed, if $b$ does not die, then $b + \B + [0, \B)$ is
%    an emerging cell.
%    If $b$ dies, then alarm is called at a cell
%    $y$, where $y-b<2\B$.

    In the former two possibilities,
    the damage attack continues further outside
    of $F$ to its right,
    until the space between
    it and $F$ is damage-free.
    In the latter case, if
    the rebuild is properly initialized,
    then our claim already holds.
    Otherwise, alarm is called, and hence, the attacking continues.
\end{prooofi}

\begin{step+}{step:lem:persistent.bursts}
    Suppose now that bursts occur.
\end{step+}
\begin{prooofi}
    The only way how a burst can prevent
    the attacks is by increasing the sweep of the
    fragment and letting the head move further
    to the left of $b$.
    Clearly, the mode after such a burst cannot
    be normal, as that would invoke alarm and then
    attacks would continue to the right.

    \begin{step+}{step:lem:persistent.bursts.big}
      Suppose that $b$ is $>2\beta\B$ from the range
      of the sweep of $F$.
    \end{step+}
    \begin{prooofi}

        If a burst sets the state to a left moving
        sweep over $F$ of the recovery procedure,
        then zigging guarantees that the head will
        return back to $b$ from such sweeps.
        Indeed, a burst may set the sweep to either the
        next sweep (so it does not cause an alarm) until
        the head is not farther than $\Z_b\B$ from $b$,
        hence crippling it;
        or to a marking sweep (since it ignores the content
        of the tape).
        However, bursts are $\Tus$ apart, which means
        that the head will need to
        return again to the right and return later,
        hence attacking the damage again from the other side.
        %Then, attacks will occur from the right side when
%        the head comes to $F$, hence a damage-free fragment
%        exists to the right of $b$.
%        But then, feathering property guarantees that
%        the head will step inside $F$ from
%        such a fragment to the  right of $F$.
    \end{prooofi}
    \begin{step+}{step:lem:persistent.bursts.big2}
        Suppose that $b$ is $\leq 2\beta\B$ from the range
        of the sweep of $F$.
    \end{step+}
    \begin{prooofi}
        Then, a burst can fill in
        the interval of $2\beta\B$ with
        cells to complete the range of
        $F$, and let the machine complete the computation
        over $F$.
        Clearly, these cells must be damage-free and have
        appropriate recovery marks, as otherwise,
        alarm will be called.

        Recovery procedure has a constant time limit
        to finish, and hence it will either
        end in calling $\GiveUp$ or continuing in normal.

        In the first case, we are guaranteed the growth of
        $F$ in both sides by the design of the
        rebuild procedure.

        In the second case, since the left side of
        $F$ is damage-free and recovery did not fail,
        we are guaranteed the growth
        of $F$ to the right by the feathering property
        of our program, if $F$ is $\Damage^*$-free.
        Otherwise, another recovery will start there, and
        it is destined to call $\GiveUp$, and the
        previous case applies.
    \end{prooofi}


\end{prooofi}
\end{Proof}


How long does a damage-free fragment need to be active in order
to reach a growing stage?
What is the correlation between
the number of attacks and the time that a fragment was active?


\begin{lemma}\label{lem:dw}
    There is some constant $\cdw > 0$ with the following property.
    Let
    $F(t)$ be a damage-free fragment at time $t$.
    Suppose that as long as  $t$ is in some noise-free
    time interval, the fragment $F(t)$ can grow.
    Suppose its size is bounded by $l\B$, for
    $l \leq 2Q$.

    Suppose that the amount of total time that
    the head spends in $F(t)$ is $s$.

    If $l < Q$ then at least
    \begin{align}\label{eq:attacks-small}
        \left\lfloor\frac{s}{\cdw l \Tu{}}\right\rfloor
    \end{align}
    times, the transition function will
    attack the damage from %within
    $F(t)$.
%    in the sense introduced in the trajectory property.

    If $l \geq Q$ then the lower bound
    on the number of attacks is
    \begin{align}\label{eq:attacks-big}
        Q\left\lfloor\frac{s}{\cdw \Tus}\right\rfloor,
    \end{align}
    and
    the lower bound applies to the number of
    attacks both to the left and to the right.
\end{lemma}
\begin{Proof}

\begin{step+}{step:lem:dw.1}
    Consider the case when $ l < Q$.
\end{step+}
\begin{prooofi}

    Let us consider first the case when a fragment does not have
    appropriate colony structure or its size is less than the size of
    a colony.
    The use of zigging during the simulation and
    the assumption that $\eta$ is a trajectory,
    guarantee  that
    simulation fragments that do not contain a proper colony
    structure, turn to either the recovery type or to
    a rebuild type.
    Indeed, since we assumed that the
    fragment grows, this means that
    such fragments necessarily will get included inside
    a rebuild cover of a rebuild procedure once the
    head steps off it and calls alarm, or if another
    fragment grows into it.

    For this reason, we restrict our attention
    on the fragments of rebuild and recovery type.

    What is the minimum amount of time that the head needs
    to spend in $F(t)$ in order to grow?

    1) Suppose that $F(t)$ is a recovery fragment.
    The minimum amount of time needed to grow outside of $F(t)$ is
    lowerbounded by the time needed to reach the first zigging
    during the mopping stage,
%    \begin{align*}
  %       O(\beta)\Zg(\loc, \Rec.\Z, \Rec.\Z_b) + 2\Zg(\E, \Rec.\Z, \Rec.\Z_b),
 %   \end{align*}
    which is a constant depending solely on $\beta$.

   % When this happens and the head steps on damage,
%    alarm

%
%    The program  has a property that if such an attack did
%    not succeed, it will restart again until it succeeds.
%    \footnote{We have seen this property in
%        parts~\ref{step:lem:transfer1.damage-free.claim3}
%        and~\ref{step:lem:transfer2.damage-free.claim3} of the
%        proof of Lemma~\ref{lem:transfer1}
%        and Lemma~\ref{lem:transfer2} respectively.}


    2) Suppose that $F(t)$ is a rebuild fragment.
    The rebuild procedure runs in
    $\Sreb$ sweeps, where constant $\Sreb$ is defined
    in~\eqref{eq:RebSweeps}, and is larger than the total
    number of sweeps used by the recovery procedure.
    Further, zigging is used throughout the rebuild procedure.
    Hence, if  $s$ is the total time the
    head spent in our fragment until the time $t$,
    then
    whenever
    $s \geq \Zg(l, \Z, \Z_b)\Tu{}$, %for some constant $c>0$ that depends on $\Z$ and $\Z_b$,
    the fragment is attacking outside of $F(t)$, as shown
    in Lemma~\ref{lem:persistent}.
    Hence, the desired lowerbound
    \begin{align*}
        \left\lfloor \frac{s}{\cdw l \Tu{}}\right\rfloor
    \end{align*}
    for $\cdw$ that depends solely on $\beta$.
\end{prooofi}
\begin{step+}{step:lem:dw.2}
    Consider the case when $Q \leq l \leq 2Q$.
\end{step+}
\begin{prooofi}
    If the fragment is of a rebuild type, then
    the previous case applies.
    Hence, we restrict our attention to the
    fragments of the simulation type.

    Suppose that a base colony is formed in $F(t)$,
    and the mode is normal.
    Then, this colony corresponds to the
    the current cell of $M^*$.

    The program of $M^*$ does not allow the head to stay
    in one colony continuously for more than $2\Uc$,
    where
    \begin{align*}
        2\Uc = 2 d Q^2\Tu{}\leq O(\Tus)
    \end{align*}
    denotes the time needed to complete the computation
    phase, for some $d>0$.
    (The bound is obtained by allowing the possibility that
    the drift of the work period was $0$.)

    At the moment when the transition phase begins,
    the head starts transferring in the direction of
    the drift.
    The properties of $M^*$ guarantee that the head will
    not stay in $F(t)$ longer than
    \begin{align*}
        \frac{l}{Q}O(\Tus)\leq c'\Tus,
    \end{align*}
    for $c'>0$
    before attempting to move outside of
    it in any direction.
    This attempt will create
    at least $c''Q$
    attacks away from $F(t)$, for some constant $c''>0$.

    Let $s$ be  the total time the
    head has spent in $F(t)$ in a union of some
    time intervals.
    Then to reach the growing stage of the fragment
    that leads the head outside of $F(t)$ we need
    \begin{align*}
        \frac{s}{c'\Tus},
    \end{align*}
    work periods over $F(t)$.
    Now, once this fraction is at least 1, the attacks
    outside $F(t)$ begin.
    %As we have seen in Lemma~\ref{lem:persistent},
%    the attacks persist until either the damage is removed
%    from its range.
    But the $F(t)$ can be included fully inside a rebuild
    cover only after the damage is removed,
    hence the lower bound is
    \begin{align*}
        c''Q\left \lfloor\frac{s}{c'\Tus}\right \rfloor
        \geq
        Q\left\lfloor\frac{s}{\cdw\Tus}\right\rfloor.
    \end{align*}

\end{prooofi}

\end{Proof}









\section{Transition function and attack property}



Recall the definition of $\Uc$ and $\Ut$ in~\eqref{eq:U_c}.


To prove that $\eta^*$ has the property
\ref{i:def.traj.transition} of Definition~\ref{def:traj},
we start our observations from a colony $x + [0, Q\B)$ that is
$0.5Q\B$ apart from $\Damage^*$.

The following lemma is a simple corollary of Lemma~\ref{lem:recovery}.

\begin{lemma}\label{lem:traj-I-c}
   Consider an annotated history $\eta$ on a space-time
   rectangle $A\times\tau$, where  $\tau$ ends in $t_0$
 %  such that
%   $t_1 - t_0\geq 1.5\U\Tu{}$, and
   and interval $A$ that will be defined below,
   that contains
   at least the current colony $x+[0, Q\B)$. %,
%   such that $x + [-0.5Q\B, 1.5\B)$ does not intersect
 %  $\Damage^*$.

   Suppose that $\eta(t_0).\Sweep = \TransferStart-1$.

   Let $t_1 =t_0 + \Ut\Tu{}$ and $t_2 = t_0 + \U\Tu{}$.
   We assume that no bursts of $\Noise^*$ occur
   throughout $\tau$ until $t_2$.


   Then, one of the following is true.

\begin{enumerate}
  \item  Suppose that $\eta(t_0).\Drift = 1$,
         that $x + Q\B + [0, Q\B)$ is vacant at time $t_0$, and
         $A:=[x-0.5Q\B, x + 2.5Q\B)$.

         Then, for $t \in   [t_1,t_2)$,
         interval $x + Q\B + [0, Q\B)$ is the current
         colony of $\eta$, and
         $\eta$ is annotated on $A \times [t_0, t_2)$.

  \item  Suppose that $\eta(t_0).\Drift = 1$,
         that in a distance of $<2Q\B$ from $x$
         an outer colony $y + [0,Q\B)$ exists, such that
         interval  $A:=[x-0.5Q\B, y + 1.5Q\B)$.

         Then, at every $t \in   [t_1,t_2)$,
         interval $y + [0,Q\B)$ is the current
         colony of $\eta$, and
         $\eta$ is annotated on $A\times [t_0, t_2)$.

  \item  Suppose that $\eta(t_0).\Drift = -1$ and
         that $[x - Q\B, x)$ is vacant at time $t_0$,
         and let $A:=[x-1.5Q\B, x + 1.5Q\B)$.

         Then, at every $t \in  [t_1,t_2)$,
         interval $[x - Q\B, x)$ is the current
         colony of $\eta$, and
         $\eta$ is annotated on $A\times [t_0, t_2)$.

  \item  Suppose that $\eta(t_0).\Drift = -1$ and
         that in a distance of $<Q\B$ from $a$,
         an outer colony $[y,y+Q\B)$ exists, such that
         interval  $A:=[y-0.5Q\B, x + 1.5Q\B)$.

         Then, for $t \in   [t_1,t_2)$,
         interval $y+[0, Q\B)$ is the current
         colony of $\eta$, and
         $\eta$ is annotated on $A\times [t_0, t_2)$.

  \item  Suppose that $\eta(t_0).\Drift = 0$ and
          $A:=[x - 0.5Q\B, x + 1.5Q\B)$.

         Then, for $t\in t_0 + \Uc +[0, \Uc)$
         interval $x + [0,Q\B)$ remains
         to be the current colony of
         $\eta$ that
         is annotated on $A\times t_0 + \Uc +[0, \Uc)$.
\end{enumerate}

\end{lemma}
\begin{Proof}
    Since $Q$ is large enough such that
    $\PenetrationLen<Q/2$,
    regardless of the islands and bursts of $\Noise$ that may occur,
    the head of $M$ will not come close
    to the boundaries of $A$.
    As we started from annotated history,
    on $A$ and since no large bursts occur,
    Lemma~\ref{lem:recovery} implies that
    the trajectory will remain annotated
    the entire time on $A$.
\end{Proof}

Now we can prove the following

\begin{corollary}\label{cor:1c}
    The property~\eqref{i:def.traj.transition}
    of Definition~\ref{def:traj} holds for $\eta^*$.
\end{corollary}
\begin{Proof}
    Follows from Lemma~\ref{lem:traj-I-c} and Lemma~\ref{lem:simulation-step}.
\end{Proof}


\subsection{Outer attacks on damage}

In the next lemma, we consider the case how
the damage is cleared when the head steps
on it from a damage-free workspace.

Recall that the head of the machine steps
outside of a colony during zigging and during
yarding.


\begin{lemma}\label{lem:yard-attack}
    Let $\eta(t_0)$ be an annotated configuration whose
    union  of the workspace and extended workspace is $W$, and
    let the current colony be
    $C := x + [0,  Q\B)$.

    Suppose that trajectory
    $\eta$ remained annotated on
    $W$
        until time $t_1$ when the head
        steps outside of $W$,
        when $\dir(\chi.\Sweep)=1$
        (resp., $\dir(\chi.\Sweep)=-1$),
        where $\chi$ is the satisfying healthy
        configuration of $\eta(t_1 - 1)$.
        Let $\delta = \dir(\chi.\Sweep)$.

        We assume that if
        $\eta(t_1-1).\Sweep = \TransferSw(d)$, $d=\eta(t_1-1).\Drift$,
        then, $W$ is damage-free and it contains the
        neighbor colony  properly.


        Suppose that $\delta = 1$ (resp., $\delta = -1$), %and suppose
%        that at time $t_1 - 1$, to the right (resp., left) of
%        $C$, no right (resp., left) outer colony exist
%        at a distance $<Q\B$ from $C$.
        and that  $W$ is at least $0.5Q\B$ removed
        from the $\Damage^*$ to the left (resp., right).

    Then, one of the following is true.

    \begin{enumerate}


        \item\label{i:lem:yarding.attack.success}
              The simulation over $W$ continues
              in the direction $-\delta$.

        \item\label{i:lem:yarding.attack.clean}
              $W$ is killed, and
              the new current
              colony $C'' =: x' + [0,Q\B)$
              is $0.5Q\B$ apart from $\Damage^*$, such
              that
              $|x' - x|<2Q\B$.

              The $\State$ field of $C''$ is emerging.
    \end{enumerate}
\end{lemma}
\begin{Proof}

During the simulation, besides yarding and zigging,
the head can step outside of $W$ due to a distress event
(see Definition~\ref{def:annotated-hist}).

Without loss of generality, assume that the direction of
 $\chi.\Sweep$ that satisfies $\eta(t_1 - 1)$ is 1.



\begin{step+}{step:lem:yard-attack.alarm}
    Suppose that the machine when stepping outside of $W$
    was in the recovery mode.
    Let $z_1$ be the center of the recovery interval $\R$, and
    assume that either the front is at least $\Z\B$ to the left
    of the head, or $z_1 + [-\loc\B, \loc\B)$ is marked with
    recovery marks.
\end{step+}
\begin{prooofi}

    Then, according to
    Lemma~\ref{lem:persistent}, attacks on the damage will be conducted
    until at least $$I:= z_1 + [0, (\E + \Rec.\Z - \Rec.\Z_b)\B)$$
    becomes damage-free.
    The simulation on $W$ cannot continue without removing this
    damage and the distress area that was created during the
    damage removal.
    In other words, no bursts can switch the machine to continue
    with the simulation before the damage is removed.

    Now, we need to consider two possible cases.
    \begin{step+}{step:lem:yard-attack.alarm.no-bursts}
        Suppose first that no burst occurs.
    \end{step+}
    \begin{prooofi}
        While spreading of the rebuild interval $L$ to the right,
        further damage will be encountered, and we apply
        Lemma~\ref{lem:persistent}.
        During this process, $L$ may be taken over
        by another rebuild interval $L'$ on its right.
        However, any rebuild cover that intersects $W$ in a
        stretch of at least $\E\B$, will contain $W$ fully as $L$
        would.


        Suppose that to the right of $W$, there is no other tissue, but
        eventually a right outer colony.
        Then, according to part~\ref{i:mediation:transfer-slow-clearing} of
        the mediation rule, the rebuild cover will be enlarged until
        %its size does not exceed $2\PenetrationLen\B$ and
        it contains the entire workspace fully inside.
        Then, interval that is outside of $W$ will be renewed,
        and the visitor's structure outside of $W$ will be
        restored.
        At the end, the head is left at the front of $\chi$.

        Suppose that to the right of $W$, there is a left-transferring arm
        or another workspace.
        Then, the rebuild cover will be enlarged, until both tissues
        are fully included in it, and both of them will be killed, and
        a new emerging colony $C''$ is created that is within $2Q\B$ from
        $C$.
    \end{prooofi}

    \begin{step+}{step:lem:yard-attack.alarm.bursts}
        Let us now consider what happens if a burst occurs.
    \end{step+}
    \begin{prooofi}
        Since for at least $0.5Q\B$ to the left, there is no
        $\Damage^*$, Lemma~\ref{lem:burst-rebuild}
        implies that we can safely ignore bursts and islands that
        may be encountered when the head is not closer than $\E\B$
        to the right endpoint of $W$ when only one rebuild cover
        contains $W$.

        1) If a burst occurs when the head is at least $\E\B$
        to the left of the right endpoint of $W$, and the head is building
        a new rebuild cover $L'$ over $L$, then a new rebuild cover $L''$
        is opened that contains only $W$, and then the head is put at the
        front, after the marks are removed.
        From this moment, we repeat the same reasoning as above, once the head encounters
        marked cells of $L$ or $L'$ outside of $W$.

        2) If a burst occurs to the right of $W$, then the reasoning when
        no bursts occur applies for a new rebuild cover $L''$.

        3) If a burst occurs during the creation of a new colony and the head
        is over it, then
        we are guaranteed to be removed from the damage,
        hence Lemma~\ref{lem:burst-rebuild}
        applies.
        If a burst occurs before the marks from the newly created colony
        are removed and the head is on the right endpoint of the rebuild
        cover, then we repeat the same reasoning as in the case
        when no bursts occur.
        The new rebuild interval --- if it ever gets opened and covers
        $L$ --- will contain the newly created colony fully, since marks
        on the stripe of size $\geq 0.5Q\B$
        to its left are already removed and it is
        damage-free already.
    \end{prooofi}
\end{prooofi}

\begin{step+}{step:lem:yard-attack.normal}
    Suppose that the machine when stepping outside of $W$
    was in the normal mode.
\end{step+}
\begin{prooofi}

   \begin{step+}{step:lem:yard-attack.normal.nozigging}
        Consider the case when
        the machine was not zigging when the head stepped on $y$ that
        may belong to the damage or $\Damage^*$.
   \end{step+}
   \begin{prooofi}
        Then the simulation cannot continue until the damage
        from the range of the $\chi.\Sweep$ is removed.
        Indeed, if the head leaves $W$ and moves further right,
        the head cannot return in $W$ and continue with the
        simulation without completing the
        previous sweep since zigging will
        bring the head back to the right of $y$,
        hence attacking the damage repeatedly.
        The head of $M$ may move far to the
        right and then, as guaranteed by the feathering
        property of the program, return back to $y$.

        When the  head returns to $y$% changes,
        according to property~\ref{i:def.traj.attack-from-outside}
        of $\eta$,
        $[y - 0.5\B, y + 2\B)$ is damage-free and
        the machine is in the recovery mode.
%        $y$ will either die, and a new cell $y'$
 %       will be created at a distance
 %       $<2\B$ from $y'$, such that $y'+0.5\B$ is damage-free,
 %       or the head will step onto a new created
 %       cell $y''$ that is adjacent to $y$.
 %       In the meantime,

     %   Since $y'$ and $y'' $ are emerging cells,
%         alarm will be called.
        Further, the head cannot move to the left of $y$ in normal
        mode by more than $\Z\B$ without calling an alarm.
        If no burst occurs when the head is over $y$, then
        attack will be carried out further by the recovery procedure
        and eventually rebuild procedure, hence
        case~\ref{step:lem:yard-attack.alarm} applies.
    \end{prooofi}


   \begin{step+}{step:lem:yard-attack.normal.zigging}
      Suppose that the head stepped
      on the damage in a zigging sweep.
   \end{step+}
   \begin{prooofi}
       Then
        it must have been the first zigging sweep
        outside, since it is the longest.

        A burst can make the head return to $W$
        without removing eventual damage, if it is
        at least  $(\Z-\Z_b)\B$ from the front.
        Furthermore, if the sweep was the longest
        sweep of the work period,
        then the damage may not be removed, and
        the simulation may continue until
        the end without any interruption
        while keeping $W$ damage-free and the history on it annotated.
        Otherwise, if this was not the longest sweep of the work period, or
        the damage is not $(\Z-\Z_b)\B$ from the front,
        the damage will get attacked.
        If for any of the possible reasons,
        the head steps into $W$, zigging
        guarantees that it will return back
        to the right until either the damage
        gets attacked again and alarm is called,
        or $W$ becomes a crippled fragment.
        From this point, in both cases part~\ref{step:lem:yard-attack.alarm}
        applies.
    \end{prooofi}
\end{prooofi}
\end{Proof}



\subsection{Transferring}

In the following lemma, we analyze the transfer from the current
colony where in the direction of the $\Drift$, there is no
outer colony.

\begin{lemma}\label{lem:transfer1}
    Let $\eta(t_0)$ be an annotated configuration
    with the current colony $C := x + [0,  Q\B)$.

    Suppose that trajectory
    $\eta$ remained annotated on
    $C$
        until time $t_1$ when the head
        steps outside of the base colony,
        when $\eta(t_1).\Sweep = \TransferSw(\delta)$,
        where
        $\delta$ is the drift
        of a satisfying healthy
        configuration of  $\eta(t_1-1)$.


        Suppose that $\delta = 1$ (resp., $\delta = -1$), and suppose
        that at time $t_1 - 1$, to the right (resp., left) of
        $C$, no right (resp., left) outer colony exist
        at a distance $<Q\B$ from $C$.


    Then, one of the following is true.

    \begin{enumerate}

        \item\label{i:lem:transfer1.success-new}


              Then,
              after the end of the work period
              the new current colony $C'$
              is created, and it is adjacent
              to $C$, whose cells now have
              $\cSweep = \Last(\delta)$, $\cDrift = \delta$,
              and $\cKind = \Member$.


        \item\label{i:lem:transfer1.clean}
              $C$ is $\Damage^*$ - free, and
              the new current
              colony $C''=x' + [0,Q\B)$
              is $0.5Q\B$ apart from $\Damage^*$, such
              that
              $|x' - x|<2Q\B$.

    \end{enumerate}
\end{lemma}



\begin{Proof}



        Suppose first that $\eta(t_1)$ is annotated
        on $x+[-0.5Q\B,  2.5Q\B)$.
        Then, Lemma~\ref{lem:traj-I-c}
        guarantees
        that while transferring to the right,
        the machine creates
        an adjacent colony,
        yielding the outcome~\ref{i:lem:transfer1.success-new}.






        Suppose now that we are attacking
        the damage to the right.
        Let the current cell $y$ be
        inside the transferring arm.
        Without loss of generality, assume that $y$ is
        at most $0.5Q\B$ from $C$.


        The head can leave $y$ and move to the right.
        The feathering property of the program guarantees that
        the head will return on $y$.
        According to property~\ref{i:def.traj.attack-from-outside}
        of $\eta$, when this happens,
        $[y, y+2\B)$ is damage-free, and
        the machine is in the recovery mode.



%
%        When the state of $y$ changes,
%        according to property~\ref{i:def.traj.attack-from-outside}
%        of $\eta$,
%        $y$ will either die, and a new cell $y'$
%        will be created at a distance
%        $<2\B$ from $y'$, such that $y'+0.5\B$ is damage-free,
%        or the head will step onto a new created
%        cell $y''$ that is adjacent to $y$.
%        In the meantime, the head of $M$ may move far to the
%        right and return back to $y$, as guaranteed by
%        the feathering property of the program.
%
%        Since $y'$ and $y''$ are emerging cells, %is an emerging cell and $y''$ is %generic,
%        in both cases, alarm will called.
        Further, the head cannot move to the left of $y$ in normal
        mode by more than $\Z\B$ without calling an alarm.
        If no burst occurs when the head is over $y$, then
        attack will be carried out further by the recovery procedure
        and eventually rebuild procedure (see Lemma~\ref{lem:persistent}).

        Once the damage to the right of $C$ is eliminated, the
        entire transferring arm is covered by a rebuild cover
        $$L.$$

        Suppose first
        that no bursts occur and
        that no $\Damage^*$ exists
        for at least $Q\B/2$ to the left of $C$.
        Then, our claim follows from Lemma~\ref{lem:yard-attack}.

        %From the mediation rules of the rebuild procedure we
%        have the following outcomes.
%
%            \begin{step+}{step:lem:transfer1.no-neighbor.wsp}
%                Suppose that a workspace exists
%                on the right half of the rebuild cover.
%            \end{step+}
%            \begin{prooofi}
%                %Suppose that no bursts occur during the rebuild.
%                Then, both these tissues will be killed, and a new
%                colony will be $1.5Q\B$ apart from damage on the right,
%                and $0.5Q\B$ on the left.
%                From this point, Lemma~\ref{lem:recovery} implies
%                the outcome~\ref{i:lem:transfer1.clean}
%                of our claim.
%
%%                Suppose that a burst occurs during the rebuild procedure.
%
%
%
%            \end{prooofi}
%
%
%            \begin{step+}{step:lem:transfer1.no-neighbor.turn-back}
%                Suppose that to the right of $C$, in a distance
%                of $<1.4Q\B$,  there is no
%                transferring arm or workspace.
%            \end{step+}
%            \begin{prooofi}
%              Then, $C$ will be extended with a
%              an interval of $1.5Q\B$ of damage-free cells, hence
%              outcome~\ref{i:lem:transfer1.success-new}
%                of our claim holds.
%
%            \end{prooofi}
%
%            \begin{step+}{step:lem:transfer1.no-neighbor.arm}
%                Suppose that $L$ contains
%                a left-transferring arm on its right part.
%            \end{step+}
%            \begin{prooofi}
%                Then, we kill $C$ and everything to its right
%                until the rightmost cell of the base colony
%                of the transferring arm on the right.
%
%                Then, the new colony will be created in the center
%                of the rebuild cover.
%                Hence, the new current colony is
%                $0.5Q\B$ apart from damage in both sides.
%                Hence, outcome~\ref{i:lem:transfer1.success-new}
%                holds.
%            \end{prooofi}
%
%            If a burst occurs during the rebuild procedure
%            when the head is inside $L$ %and
%%             at least $\E\B$ to the right
% %           of $x$,
%            then Lemma~\ref{lem:burst-rebuild} guarantees
%            that the rebuild procedure continues seamlessly.




        Suppose now that damage exists to the left of $C$.

    \begin{step+}{step:lem:transfer1.damage-sim}
        If the rebuilding procedure ended up in extending
        $C$ to the right with an adjacent colony, then
        the simulation continues, and the head returns to
        $C$.
        Lemma~\ref{lem:yard-attack} is applicable, and
        guarantees one of the two outcomes of our lemma.
    \end{step+}
    \begin{prooofi}
        Indeed, by its design, when in the rebuild procedure
        a decision is made to renew an interval that is at least
        $Q\B$ in length next to the base colony, it always
        makes sure that the interval $1.5Q\B$ next to the base
        is damage-free.

        Then, once the transferring sweep finishes, the
        sweep next to it brings the head at the left
        endpoint of $x$ and even further to the left.
        Now, Lemma~\ref{lem:yard-attack} applies.
    \end{prooofi}

     \begin{step+}{step:lem:transfer1.damage.reb}
        Let us consider the case when the head steps
        on the damage to the left of $C$ before the rebuild
        procedure finished.
        Clearly, since the front is
        to the right of $C$, and
        since
        $C$ is marked with rebuild marks, we can only
        return to $C$ with a rebuild procedure.
        %, since
%        $C$ is condemned.
     \end{step+}
     \begin{prooofi}
        This means that if the head attempts to step
        inside $C$ in normal mode, alarm is called.

        If the head comes inside $C$ in any other mode,
        then the damage to its left must have been eliminated
        already.
        The feathering property of the program guarantees that the
        head will return to $C$ once the damage to its left
        is eliminated.

        Then, the rebuild cover will spread all over $C$,
        and eliminate it completely.
        If on the left side, the rebuild cover contains a
        workspace or a left-transferring arm,
        then everything under the cover will be killed
        and a new colony $C'$ surrounded by at least
        $0.5Q\B$ stem cells around will be created.


%        As $C$ is condemned, it may be killed partially
%        by the simulation that is taking place to the left of
%        $C$.
%        Furthermore, the
%         feathering property guarantees that it will
%        be erased completely.
     \end{prooofi}

%        Let us consider now what happens when
%        a burst occurs.
%
%        If a burst occurs when the head is at
%        least $2\E\B$ inside a rebuild cover, then
%        by its design, the rebuild cover will restore its
%        state, and since operations are repeated many
%        times with the use of majority computation, bursts do not
%        affect its end result.
%
%        If a burst occurs when the head is at the right end of $L'$
%        where it meets with the rebuild cover $L$,
%        then the recovery will fail, and the rebuild procedure
%        will not restore the state of the previous rebuild procedures
%%        \Inote{Though a simple modification can do it!}
%        but a new rebuild procedure will start from scratch.
%        Depending on the position of the center of the rebuild
%        cover $L''$ we have the following outcomes.
%
%            If the center is at least $3\E\B$ to the right of $x$
%            then one of the cases~\ref{step:lem:transfer1.no-neighbor.arm},
%            \ref{step:lem:transfer1.no-neighbor.turn-back}, \ref{step:lem:transfer1.no-neighbor.wsp}
%            apply.
%
%        Otherwise,
%        either case~\ref{step:lem:transfer1.no-neighbor.left-left-arm}  or
%        case~\ref{step:lem:transfer1.no-neighbor.left-wsp}
%        is applicable.
%
%        If yet another burst occurs, we repeat the same reasoning again.
%
%        The only damage that can be left in the area that was cleaned
%        comes from the possible two bursts that may have occurred
%        during the last sweep of the rebuild procedure.
\end{Proof}



In the following lemma we consider the case when
a neighboring colony exists in a distance $<Q\B$
from the base colony.



\begin{lemma}\label{lem:transfer2}
    Let $\eta(t_0)$ be an annotated configuration
    with the current colony $C := x + [0,  Q\B)$.

    Suppose that trajectory
    $\eta$ remained annotated on
    $C$
        until time $t_1$ when the head
        steps outside of the base colony,
        when $\eta(t_1).\Sweep \geq \TransferSw(\delta)$,
        where
        $\delta$ is the drift
        of a satisfying healthy
        configuration of  $\eta(t_1-1)$.


    Then, one of the following is true.

    \begin{enumerate}

        \item\label{i:lem:transfer2.success-old}
              At the end of the work period whose
              current colony was $C$,
              the new current colony
              $$C' = y' + [0,Q\B)$$
              is within a distance of $<Q\B$
              apart of $C$, in direction $\delta$ from it.

              All cells of $C$ have either
              $\cSweep = \Last(\delta)$, $\cDrift = \delta$,
              and $\cKind = \Member$,
              or all cells have $\cKind = \Stem$ and
              $\cDrift = \delta$.

        \item\label{i:lem:transfer2.success-new}
             % Suppose that $\delta = 1$ (resp., $\delta = -1$), and suppose
%              that at time $t_1 - 1$, to the right (resp., left) of
%              $C$, no right (resp., left) outer colony exist
%              at a distance $<Q\B$ from $C$.

              %Then,
              After the end of the work period
              the new current colony $C'$
              is created, and it is adjacent
              to $C$, whose cells now have
              $\cSweep = \Last(\delta)$, $\cDrift = \delta$,
              and $\cKind = \Member$.
%              ;
%              or
%              if $\delta = 1$, the new current cell is
%              at most $1.5Q\B$ to the right of $C$.


        \item\label{i:lem:transfer2.clean}
              $C$ is $\Damage^*$ - free, and
              the new current
              colony $C''=x' + [0,Q\B)$
              is $0.5Q\B$ apart from $\Damage^*$.
              such
              that
              $|x' - x|<2Q\B$.

              In particular, if $C$ was at least $0.5Q\B$
              apart from $\Damage^*$ in direction $-\delta$,
              then $x'$ is to the right of $x$.

    \end{enumerate}
\end{lemma}

\begin{Proof}

    Let us follow the simulation and the recovery mechanisms
    starting from $t_1$.
    Without loss of generality, let us consider
    the case when the drift of a satisfying healthy
    configuration of $\eta(t_1 -1 )$ is 1.


    \begin{step+}{step:lem:transfer2.damage-free.easy-case}
        Suppose that $C$% and $C'$ are
        is at least $0.5Q\B$ from $\Damage^*$ to the left.
    \end{step+}
    \begin{prooofi}
        %Indeed, if there is no damage in between,
%        Lemma~\ref{lem:traj-I-c} implies the
%        outcome~\ref{i:lem:transfer2.success-old}
%        of our claim.

        Consider the case when a damaged interval $I$
        exists between $C$ and $C'$.

    If our trajectory is annotated on
    $C\cup C'$, then outcome~\ref{i:lem:transfer2.success-old}
    follows from Lemma~\ref{lem:recovery}.

    Suppose now that $C$ and $C'$ are two tissues and
    $\eta(t_1)$ is not pre-annotated (see Definition~\ref{def:permissible})
    on the smallest interval $H$ covering $C\cup C'$.

    %\begin{step+}{step:lem:transfer-attack-C'.Damage*-free}
%        Suppose that the only damage in $H$
%        is contained in islands of size $<\beta\B$.
%    \end{step+}
%    \begin{prooofi}
%        Then, since $\eta(t_1)$ is not pre-annotated on $H$,
%        alarm is called when the head steps in $I$
%        from the left side.
%        The recovery is doomed to
%        fail, hence $\GiveUp$ is called.
%
%        The rebuild cover will include $C$ and $C'$.
%
%        1) Assuming that no $\Damage^*$ exists for at least
%        $0.5Q\B$ to the right of $C'$,
%        the rebuild procedure (even in the presence of bursts)
%        will renew the space between them with
%        empty cells, and leave the head at the rightmost cell
%        of $C$.
%        Once the transferring sweep completes, the head
%        turns towards $C$ when $\eta(t).\Sweep = \TransferSw(1)+1$.
%
%
%        2) Suppose that $\Damage^*$ exists to the right of $C'$.
%        If a bi-burst occurs and the head steps on it, then
%        the head may leave $C'$ and then return back later
%        in the recovery mode.
%        Since cells of $C'$ are marked with rebuild marks,
%        a rebuild will start and it will spread over
%        $C'$.
%        Since $C'$ is on the left part of the rebuild cover,
%        and it is a right outer colony, it will be killed.
%        Then, the feathering property implies that
%        the head will reach $C$, which will get killed, and
%        a new current colony created instead.
%    \end{prooofi}

    \begin{step+}{step:lem:transfer-attack-C'.Damage*-notfree}
        Suppose that interval between $C$ and $C'$
        is not damage-free.
    \end{step+}
    \begin{prooofi}
        Then, the damage will be attacked during the
        right transfer from $C$, and by recovery and rebuild from $C'$.
        This means that once the space between $C$ and $C'$
        becomes damage-free, it will get covered by
        a rebuild cover $$L=:[a,b]$$
        that covers a right transferring
        arm on the left part of $L$, and a right
        outer colony $C'$ on the right.


        Lemma~\ref{lem:burst-rebuild} implies that we can ignore
        burst that occur during the rebuild procedure over $L$,
        when the head is to the left of $b-\E\B$.
        We can also ignore the bursts that occur in the remaining
        part, if there is no $\Damage^*$ to the right of $L$.

        Suppose that there is damage to the right of $b$ and the
        head steps to the right of $b$ for any of the possible reasons.
        If alarm is called, attacks will be carried out further by
        recovery and rebuild according to Lemma~\ref{lem:persistent}.
        Once a new rebuild cover $L'$ is spreading over $H$,
        from the right to the left, it will kill $C'$.
        Once $C$ gets invaded by another rebuild fragment from the right
        (the feathering property guarantees this),
        then, $C$ will be killed and
        a new colony $C''$ created such that the
        distance between $C$ and $C''$ is $<2\B$.
    \end{prooofi}


    \begin{step+}{step:lem:transfer-attack-C'.Damage*-wsp}
        Suppose now that the smallest
        interval $H$ covering $C\cup C'$
        is one tissue and
        $\eta(t_1)$ is pre-annotated on it.
        Then, since there is no $\Damage^*$ to the left
        of $C$, the eventual attacks on the damage can occur only
        to the right of $C'$ while yarding.
        Then, Lemma~\ref{lem:yard-attack} implies our claim.
    \end{step+}
%
 \end{prooofi}

 \begin{step+}{step:lem:transfer2.damage-left}
     Suppose that the $0.5Q\B$-stripe on the left of $C$% and $C'$ are
     intersects $\Damage^*$ or $\Damage$.
 \end{step+}
 \begin{prooofi}

    \begin{step+}{step:lem:transfer2.workspace-left-rebuild}
        Suppose now that the head steps to the left of $C$
        during the rebuild procedure whose rebuild cover
        is $L =: [a,b]$, that covers $C$ and $C'$, and
        its center is to the right of $C'$.
    \end{step+}
    \begin{prooofi}
      %  Without loss of generality, suppose that the center
%        of this rebuild cover is to the right of $C'$.

        Once the head steps off $C$ to its left, it may continue
        moving to the left.


        \begin{step+}{step:lem:transfer2.workspace-left-rebuild-oldseamlessly}
            Suppose that the head returns to $C$ and continues the rebuild
            procedure seamlessly.
        \end{step+}
        \begin{prooofi}
            (This can only happen if a burst switched the state to
            the one that was interrupted before the head
            stepped off $C$.)
            In this case, $C$ and $C'$ may be killed and a new
            current colony created, the $\Damage^*$ that is
            to the right of $C'$ is removed and the simulation
            continues.
            If before the end of the work period, the head
            steps on the damage that is to the left of $C$ again,
            then case~\ref{step:lem:transfer-attack-C'.Damage*-wsp} applies.
            Otherwise, once the work period finishes, $C'$ is
            the new current colony.
        \end{prooofi}



        \begin{step+}{step:lem:transfer2.workspace-left-rebuild-new-rebuild}
            Suppose that the previous rebuild procedure
            does not continue seamlessly, but alarm is called instead.
        \end{step+}
        \begin{prooofi}

            Then, damage will be
            attacked to the left if there is any.
            Then, a new rebuild cover $L'$ spreads
            over $C$ and $C'$.

            1) Suppose that a burst occurs while the head is spreading the new
            rebuild cover over the old one, and the
            head is at least $4\E\B$ inside $C$ and $C'$ (\ie at least
            $4\E\B$ from the left endpoint of $C$ and right endpoint
            of $C'$).
            Then, if the rebuild procedure that is spreading $L'$ does not
            continue seamlessly, alarm is called, which initiates
            a recovery that fails, hence $\GiveUp$ is called.
            This rebuild procedure will
            create a cover that contains $C$ and $C'$ only.
            It will fill the correction data all over it, and leave
            the head at the front, once all the marks are removed.

            2) Suppose that a burst occurs while the rebuild is
             spreading $L'$, and the head is not
             $4\E\B$ removed from the right end of $C'$ to its left.
             Then, $L'$ will essentially cover the same
             tissues as $L$, hence
             the analysis of part~\ref{step:lem:transfer2.workspace-left-rebuild-oldseamlessly}
             applies.
             Suppose that a burst occurs during the rebuild procedure,
             when the head
             is not inside more than $4\E\B$ to the right of $x$ (recall
             that $x$ is the leftmost cell of $C$).
             Since in both sides of the head, cells are marked with rebuild
             marks, alarm is called, and
             a new rebuild procedure is initiated.
             It will contain
             $C$ and $C'$  on the right side.
             According to the mediation rules,
             depending if there is a tissue on the left
             part of the rebuild cover, either
             $C$ and $C'$ may be killed and a new
              current colony created, or the $\Damage^*$ that is
             to the left of $C$ is removed and the simulation
             continues.
             If the head steps on some damage to the right of
             $C'$ before the work period ends, then
             we apply part~\ref{step:lem:transfer-attack-C'.Damage*-wsp}.
        \end{prooofi}
    \end{prooofi}

  %   \begin{step+}{step:lem:transfer2.workspace-left}
%        Suppose that the head steps to the left of $C$
%        during some later stage of the simulation.
%    \end{step+}
%    \begin{prooofi}
%
%        If there is no $\Damage^*$ to the right of $C'$, then
%        when the head steps to the left of $C$ in simulation,
%        then we apply Lemma~\ref{lem:yard-attack} multiple
%        times until either the simulation finishes, or
%        $C$ gets killed.


        \begin{step+}{step:lem:transfer2.workspace-left}
            Suppose that the head steps to the left of $C$
            during some later stage of the simulation.
        \end{step+}
        \begin{prooofi}
            Using the analysis given in the proof of
            Lemma~\ref{lem:yard-attack},
            we need to consider the following two
            possibilities.

            \begin{step+}{step:lem:transfer2.workspace-left.1}
               Suppose that the rebuilding procedure starts and it covers
               $C$ and $C'$ completely inside the rebuild cover
               $$L=:[a,b].$$
            \end{step+}
            \begin{prooofi}
                Suppose that the rebuild procedure finishes with success.
                Then
                either the entire damage to the left of $C$ is removed,
                and the simulation continues, or
                $C$ and $C'$ is killed, and a new
                current colony $C''$ is created, yielding
                outcome~\ref{i:lem:transfer2.clean}.
                In the first case, if, after the simulation continues,
                the head steps out of $C'$ to the
                right, we apply Lemma~\ref{lem:yard-attack}, until
                either $C$ and $C'$ are killed, or
                the $C'$ becomes the new current colony.

                Suppose that during the rebuild procedure, the head
                steps to the right of $C'$.
                Then, if the rebuild procedure does not continue seamlessly,
                once the damage is removed, a new rebuild cover $L'$
                spreads over $C'$ and $C$.

                1) Suppose that the rebuild over $L'$ succeeds.
                Then, either $C$ and $C'$ gets killed and a new current
                colony is created to the right of $C$,
                or the simulation continues and damage and $\Damage^*$ to the right of
                $C'$ is removed, hence we apply Lemma~\ref{lem:yard-attack}, until
                either $C$ and $C'$ are killed, or
                a new colony $C''$ is created.

                2) If a burst occurs while spreading $L'$ over $L$,
                and the spreading
                of $L'$ does not continue, then
                alarm will be called since the head cannot continue in
                normal (due to marks),
                nor it can continue the rebuild procedures
                over $L$ and $L'$.
                Hence, the recovery centered at $z_1$ will start and fail, and
                the  bootstrap stage will initialize
                a new rebuild procedure centered at $z_1$.
                If $z_1$ is at least $3\E\B$ from the left end of $C$
                and at least $3\E\B$ from the right end of $C'$,
                then the new rebuild cover will contain only
                $C$ and $C'$ and the space in between them.
                Then, once it finishes, the head will be left at the front, so
                once the simulation continues, we apply the same analysis.
                Otherwise, since no
                damage is removed, but the simulation cannot continue neither,
                so damage is attacked either to the right of $C'$
                or left of $C$, hence we apply~\ref{step:lem:transfer2.workspace-left-rebuild}.
            \end{prooofi}


            \begin{step+}{step:lem:transfer2.workspace-left.2}
              Suppose that a rebuilding procedure starts and it covers
              only a part of $C$.
            \end{step+}
            \begin{prooofi}
              Suppose first that no burst occurs during
              the rebuild procedure.
              Then, the damage and $\Damage^*$ from the
              $0.5Q\B$-stripe to the left of $C$ is removed.
              From now on, whenever the head steps to the right of $C'$,
              we apply Lemma~\ref{lem:yard-attack}.

              If a burst occurs during the rebuild procedure while
              the head is inside $C$, then Lemma~\ref{lem:burst-rebuild}
              implies that the state of  it will be restored.

              Otherwise, if a burst occurs when the head is to the left
              of the rebuild cover and the conditions of
              Lemma~\ref{lem:burst-rebuild} do not apply,
              then a new rebuild cover will be opened and it will contain
              now $C$ and $C'$ fully, hence part~\ref{step:lem:transfer2.workspace-left.1}
              is applicable.
            \end{prooofi}

        \end{prooofi}

%    \end{prooofi}


    \begin{step+}{step:lem:transfer2.damage-free.CC'-notD*-free}
        Let $L$ be the rebuild cover $L$ that
        covers $C$, $C'$ and the $\Damage^*$ between them.
        (In other words, the head steps to the left
        of $C$ before the transferring to $C'$ is completed.)
    \end{step+}
    \begin{prooofi}

    \begin{step+}{step:lem:transfer2.damage-free.CC'-notD*-free.right}
        Suppose that no bursts occur during the rebuild procedure, and that
        the head did not step onto the damage to the left and to the right
        of $L$.
        Then
        according to the rule~\ref{i:mediation:transfer-completion}
        of the mediation rule, the space between $C$ and $C'$ will
        be cleaned and filled with stem cells.
        Then, marks will be removed first from $C$, and then from
        the right end of $C'$ up to the rightmost cell
        of $C$, where the mode is switched to normal.
    \end{step+}

    \begin{step+}{step:lem:transfer2.damage-free.CC'-notD*-free.right2}
        Suppose that the head steps to the right of $L$.
        Then, case~\ref{step:lem:transfer-attack-C'.Damage*-notfree}
        applies.
    \end{step+}
%    \begin{prooofi}
%        Then it may hit the damage to the right.
%       % However, the left of $C$ now is damage-free,
%%        hence we can apply
%%        part~\ref{step:lem:transfer-attack-C'.Damage*-notfree}, since
%%        after a bi-burst that may occur to the left of $C$,
%%        the
%
%
%        If alarm is called, then the attack continues to the right,
%        until at least $\E\B$ interval to the right of $L$ becomes
%        damage-free, in which case the recovery will end in a failure,
%        and either the rebuild procedure will continue (after the bootstrapping
%        stage has recovered its state) or a new one starts, continuing the
%        attack to the right.
%        The head may leave this region and move to the right.
%        It can return back inside $L$ by either continuing seamlessly
%        the rebuild
%        procedure
%        that ran before, or by covering it
%        with a new rebuild cover $L'$.
%        However, the head cannot step into $L$ in normal mode without
%        calling alarm since it is marked.
%        Since $C'$ is a right outer colony and it is
%        covered on the left side, it will not be a tissue on $L'$.
%        This means that it will be killed slowly as guaranteed
%        by feathering property of the program.
%        Once, for the same reason $C$ is reached,
%        then we apply Lemma~\ref{lem:transfer1}.
%    \end{prooofi}

    \begin{step+}{step:lem:transfer2.damage-free.CC'-notD*-free.left}
        Otherwise, suppose that the head steps to the left
        of $C$.
    \end{step+}
    \begin{prooofi}
        In this case, Lemma~\ref{lem:transfer1}
        is applicable.
    \end{prooofi}
 \end{prooofi}
\end{prooofi}

\end{Proof}



%From Lemma~\ref{lem:transfer1} and Lemma~\ref{lem:transfer2}, we
%obtain the following
%lemma that claims that even when we step in
%damage that is not bounded to islands, we end up in
%an annotated history.
%
%
%\begin{lemma}\label{lem:transfer}
%    Let $\eta(t_0)$ be an annotated configuration
%    with the current colony $C := x + [0,  Q\B)$.
%
%    Suppose that trajectory
%    $\eta$ remained annotated on
%    $C$
%        until time $t_1$ when the head
%        steps outside of the base colony,
%        when $\eta(t_1).\Sweep = \TransferSw(\delta)$,
%        where
%        $\delta$ is the drift
%        of a satisfying healthy
%        configuration of  $\eta(t_1-1)$.
%
%
%    Then, one of the following is true.
%
%    \begin{enumerate}
%
%        \item\label{i:lem:transfer.success-old}
%              At the end of the work period whose
%              current colony was $C$,
%              the new current colony $C'$
%              is within a distance of $<Q\B$
%              apart of $C$, in direction $\delta$ from it.
%
%              All cells of $C$ have either
%              $\cSweep = \Last(\delta)$, $\cDrift = \delta$,
%              and $\cKind = \Member$,
%              or all cells have $\cKind = \Stem$ and
%              $\cDrift = \delta$.
%
%        \item\label{i:lem:transfer.success-new}
%              Suppose that $\delta = 1$ (resp., $\delta = -1$), and suppose
%              that at time $t_1 - 1$, to the right (resp., left) of
%              $C$, no right (resp., left) outer colony exist
%              at a distance $<Q\B$ from $C$.
%
%              Then,
%              after the end of the work period
%              the new current colony $C'$
%              is created, and it is adjacent
%              to $C$, whose cells now have
%              $\cSweep = \Last(\delta)$, $\cDrift = \delta$,
%              and $\cKind = \Member$.
%%              ;
%%              or
%%              if $\delta = 1$, the new current cell is
%%              at most $1.5Q\B$ to the right of $C$.
%
%
%        \item\label{i:lem:transfer.clean}
%              $C$ is $\Damage^*$ - free, and
%              the new current
%              colony $C''=x' + [0,Q\B)$
%              is $0.5Q\B$ apart from $\Damage^*$, such
%              that
%              $|x' - x|<2Q\B$.
%
%    \end{enumerate}
%\end{lemma}
%

%Using Lemma~\ref{lem:transfer1} and Lemma~\ref{lem:transfer2}, we
%can prove
%that property~\eqref{i:def.traj.transition(b)} holds
%for $\eta^*$.
%The
%property~\eqref{i:def.traj.attack-from-outside}
%of $\Phi^*(\eta)$ follows from Lemma~\ref{lem:yard-attack}.


\begin{corollary}\label{cor:1ab+2}
    Properties~\eqref{i:def.traj.attack-from-outside}
     and~\eqref{i:bound-on-damage}
    of Definition~\ref{def:traj} hold for $\eta^*$.
\end{corollary}
\begin{Proof}
    The claim follows from the definition of
    $\Damage^*$ given in Definition~\ref{def:damage-scaleup},
%    and definition of emerging cells given in Definition~\ref{def:generic},
    and by applying the simulation function
    from Lemma~\ref{lem:simulation-step}
    on appropriate cases of
    Lemma~\ref{lem:transfer1}, Lemma~\ref{lem:transfer2}, and
    Lemma~\ref{lem:yard-attack}.

    To establish the latter property, we observe the
    design of the rebuild procedure.

    Suppose that $A=:[a,b]$ is a large interval, and
    interval $H:=(b, b + 10Q\B)$ is $\Damage^*$-free.
    Assume that the head is inside $A$ close to its right endpoint,
    and that the rebuild procedure starts.
    As $(b, b+10Q\B)$ is $\Damage^*$-free, it only contains
    right outer colonies, hence, the rebuild cover can reach
    at most $2Q\B$ to its right.
    During the rebuild procedure, the head may leave $A$
    and may leave a stretch of at most $2Q\B$ of
     $H$ marked with the rebuild marks.
    If we apply decoding now, the first part of~\eqref{i:bound-on-damage}
    follows.
    As the feathering property guarantees that the head
    will reach $H$ again, the machine will either continue the
    previous rebuild over $L$ seamlessly, or a new rebuild procedure
    will cover $L\cap H$ and remove the marks, hence
    removing the $\Damage^*$ that was left there.

\end{Proof}





%\section{Surrounded by damage}
%
%Let us now consider the case
%when the machine starts in a middle of
%an interval $I$ of size $\geq Q\B$ that may not
%contain a proper colony structure.
%

%We need to prove that properties~\ref{def:traj}\eqref{i:def-traj:progress-fresh}
%\ref{def:traj}\eqref{i:def-traj:progress-attack}















%
%Let us consider a fragment $I$ that is not bad and
%is growing.
%Now, if the fragment gets activated with the
%same sweep number, the head will attack eventual
%damage next to $I$.
%If it gets activated with the incremented sweep,
%then the head will move inside $I$, and hence
%pushing the front (resp., the pivot) inside for at most
%$(\Z-\Z_b)\B$.
%However, within
%$2(\Z-\Z_b)$ steps, zigging brings the head back outside
%of $I$, hence attacking the damage.
%
%
%Suppose that the fragment got activated again.
%Now, the front (resp., the pivot) moves further inside, and
%the head steps off $I$ again, attacking the damage again.
%
%Since $\eta$ is a trajectory,
%during these attacks, at least an interval of size $u$
%next
%to $I$ became damage-free, where the constant $u$ depends
%on the choice of $\Z$ and $\Z_b$.
%However, the time between the returns may be long, and
%hence, each time when the head returns back to $I$, a burst may occur,
%thus keeping the damage next to $I$ still there.
%
%However, this will be repeated until the
%front (resp., the pivot) is $\Z\B$ from the endpoint of
%$I$ on which side the fragment is growing, that is, until
%it gets condemned.
%Now, since the fragment is condemned,
%the fragment can only be invaded by a recovery or a rebuild
%fragment that is born within, or is growing into it from
%a farther distance.
%As $I$ is damage-free, the fragment that is taking over it
%will continue attacking the damage further in the direction
%of the growth of $I$.
%Indeed, during marking stage of the recovery and expanding
%of the rebuild cover during the rebuild procedure,
%zigging is used.
%This means that $I$ cannot be covered by the recovery interval
%or rebuild cover until the damage to the left of $I$ has
%receded sufficiently.
%
%
%Let us consider this general scheme  in a particular case
%when the fragment is of a simulation type, consisting of
%a current colony that is at least $0.5Q\B$ far
%from $\Damage^*$.
%









%\subsection{Dwelling}


%The floors in the estimates make sure that the lower bound only kicks in after
%    the time spent in F(t) reaches some minimum amount.
%    In the proof, as long as no colony is formed in F(t), one should be able to
%    rely on the properties of the recovery and healing procedures. This is the case
%    with l < Q.
%    Once a colony is formed in F(t), it will simulate the head of M on a cell
%    of M. The properties of M guarantee that the head will not stay longer than
%    O(T) before attempting to move outside F(t). This attempt will create
%    (Q)
%    attacks (in this many sweeps). And the properties of M will guarantee that not
%    all these attempts will go in one direction.






%\subsection{Spreading}
%
%
%Suppose that $\xi(I)$ is a fragment
%that is not bad, and suppose
%that it is growing on a side where damage
%exists.
%In the next lemma we show how does this growth
%eliminate the damage next to it.
%
%
%\begin{lemma}\label{lem:dwelling}
%    Let $\xi(I)$ be a damage-free fragment of size
%    $>2\loc\B$ that is growing on its left (resp., right).
%    Suppose that no bursts occurs.
%
%    From the moment when the fragment starts growing,
%    for every $2\Zg(\loc, \Rec.\Z, \Rec.\Z_b)\cdot \cT$ steps that
%    the head spends in $I$,  at least one cell next to $I$
%    becomes damage-free.
%\end{lemma}
%\begin{Proof}
%
%    Suppose that the head
%    steps off a fragment of a recovery type on $I$.
%    Without loss of generality, suppose that the head
%    steps out from the left
%    side.
%    Suppose that the  cell $x$ next to $I$ is damaged.
%
%    As at this time, the machine switches its state
%    to an arbitrary one, the head may continue moving
%    left, or right.
%    The head cannot move to the right inside $I$
%    without calling alarm as
%    this fragment is growing to the left.
%    If it moves to the left, it may leave, and then
%    return again.
%    Once alarm is called, a fragment of a recovery type
%    that includes
%    $\loc\B$ leftmost cells of $I$ is created.
%    To sweep this interval in one direction
%    we need $\Zg(\loc, \Rec.\Z)$
%    steps of $M$.
%    As the head returns, it steps on $x$ again.
%    We repeat this process until $x$ becomes damage-free, that is,
%    since $\eta$ is a trajectory,
%    according to Definition~\ref{def:traj}, we need
%    to repeat this
%    $\cT$ times.
%
%    In general, for every
%    $2\Zg(\loc,\Rec.\Z)\cT$ steps inside $I$,
%    one cell next to it becomes damage-free.
%\end{Proof}
%




%\section{Transition function properties}
%
%
%
%
%
%
%
%
%
%Parts (Ia), (Ib) of the transition function property
%of trajectories only require that the damage do not
%intersect the body of the cells in question.
%In simulation, this means that the damage does not
%intersect the body of the colonies simulating
%the cells (and the space between).
%During simulation, there can be interaction
%with damage outside these colonies during the work
%period (for example while
%zigging, or in case (Ia) even while transferring).
%But it follows from the construction
%of the simulation program that this cannot rewrite the information in
%these colonies, so the computation of the transition will
%not be affected unless a
%big enough alarm kills the whole colony of $x$.
%In case (Ib), it is assumed that it
%does not kill the colony of $y$.
%Part (Ic) should be the simplest to prove, since $\Damage*$ does not even come
%into play then.





\section{Proof of Lemma~\ref{lem:trajectory}}\label{sec:trajectory-proof}



Now, let us prove  Lemma~\ref{lem:trajectory}.


\begin{Proof}[Proof of Lemma~\ref{lem:trajectory}]

    Consider a trajectory $(\eta, \Noise)$ of $M$.
    We need to show that $\eta^*= \Phi^*(\eta)$ is a trajectory as well,
    that is, that $\eta^*$ satisfies
    properties of Definition~\ref{def:traj}
    when no $\Noise^*$-bursts,
    occur.


    \begin{step+}{step:lem:main.1abc2}
        Properties~\eqref{i:def.traj.transition},
%        \eqref{i:def.traj.transition.(b)}, and%
        \eqref{i:def.traj.attack-from-outside},
        and~\eqref{i:bound-on-damage}
        of $\eta^*$
        are established in Corollary~\ref{cor:1ab+2} and
        Corollary~\ref{cor:1c}.
    \end{step+}


    \begin{step+}{step:lem:main.restoration.fresh}
        It remains to show
        that $\eta^*$ has the property~\ref{i:def.traj.damage-within}
        as well.
    \end{step+}
    \begin{prooofi}
        Consider a fragment $I$ of size
        $3Q\B$ on which the head
        spends some time $s$ in possibly different
        time intervals.
%        Suppose that the head spends
%        a total time $\cT \Tus$ in it.

        Suppose that $I$ consists of many fragments.
        Then, as the head passes over it, it may jump
        from one fragment to another one, in a way
        that fragments do not invade each other.

        Each bad fragment of size  $2 l\B$ will have the
        property that the time $s$ spent in
        it is at most $c_1 l\Tu{}$,
        where the constant $c_1$
        was introduced in the trajectory property.
        Indeed, if $s>c_1 l\Tu{}$,  then the head
        dwelled at least $c_1\Tu{}$ time in some
        interval of size $3\B$,
        which, since $\eta$ is a trajectory
        becomes damage-free.%, and hence a new fragment
%        that is not bad is born.
        Therefore, after a certain moment,
        we can balkanize $I$ into
        a set of fragments that are
        bad and those that are not.



        Lemma~\ref{lem:dw} helps bound the time
        spent in any fragment that is not bad.
        On a segment of size $l\B$ for
        $l < Q$, when the time becomes
        $l^2\cdw l \Tu{}$,
        there will be at
        least $l$ attacks,
        so fragments that are not bad grow by a
        constant factor, due to the
        damage attack property of $\eta$.
        So as long as the segment has size $l\B$ for
        $l < Q$, the time spent in it is bounded by
        $O(l^2\cdw\Tu{})$.

        On a fragment of size $> Q\B$,
        when the time becomes $\Tus \cdw$,
        there will be
        at least $Q$ attacks,
        and therefore again an increase by a constant factor.
        The total time spent on such fragments  is
        bounded by
        $O(\Tus\cdw)$, and there are at most
        two such fragments that can be covered
        by an interval of size not exceeding $7Q\B$.
        This  shows that the total time
        spent in $I$ up to any time moment while the
        damage lasts,
        never exceeds a constant factor times
        \begin{align*}
        \cdw\Tus + \Tu{}\sum_i{(c_1 l_i + \cdw l_i^2)},\end{align*}
        where $l_i \B $
        are the lengths of the fragments smaller
        than $Q$ present
        at that.
        Since the maximum is achieved when only one
        fragment exists,
        the total time spent before all damage in $I$
        disappears is at most
        \begin{align*}
            K((\cdw lQ^2 + c_1Q)\Tu{}+ \cdw\Tus),
        \end{align*}
        for some constant $K$.

        We want this to be smaller than $c_1\Tus$.
        Assuming without
        loss of generality $c_1 < Q$, $\cdw > 1$ (we can choose it so),
        we want
        \begin{align*}
            K(3 \cdw l Q^2\Tu{} + \cdw \Tus) &\leq  c_1\Tus,\\
            3K \cdw lQ^2\Tu{} &\leq  (c_1 - K\cdw)\Tus
        \end{align*}

        By setting $c_1 = 3K \cdw$,  this says
        \begin{align*}
            Q^2 \Tu{} \leq 3 \Tus
        \end{align*}
        which will certainly be true with our choice of $\Tus$ (see~\eqref{eq:U_i}).

    %    By its design, the rebuild procedure eliminates
%        all damage-free cells whose $\cDir$ does not
%        point towards the head, and replaces
%        them with emerging cells (see Definition~\ref{def:generic})
%        which do so.
        Once we apply decoding on $I$,
        we obtain $\Damage$-free interval $I$ of size $3\B$.


\end{prooofi}



      %  \begin{step+}{step:lem:main.restoration.fresh.1}
%          Fragments that are not bad and are growing, will
%          eliminate the damage in $I$.
%        \end{step+}
%        \begin{prooofi}
%            According to Lemma~\ref{lem:dwelling},
%            for every $2\Zg(\loc, \Rec.\Z)$ steps
%            inside a fragment, one damaged cell becomes
%            damage-free and joins the fragment.
%            As $|I|=Q\B$, we need at most
%            $2\loc\Zg(\loc, \Rec.\Z)Q$ for all the damage
%            in $I$ to be eliminated.
%            From this moment, all the fragments are
%            damage-free, and then they start interacting
%            with each other, until only one fragment %of rebuild
%            %type
%            covers $I$.
%            Once that happens, within $O(Q)$ steps
%            over $I$, it will be included in a rebuild
%            cover.
%            As the rebuild procedure finishes,
%            we will end in an
%            admissible history on an interval containing $I$.
%            But $I$ is guaranteed to be $\Damage^*$-free
%            by the design of the rebuild procedure, hence
%            $\varphi^*(I)$ is damage-free.
%        \end{prooofi}



\end{Proof}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%% Chapter Proof of the Trajectory
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\chapter{Conclusion}

    Below we mention some open problems.

    To the best of our knowledge, this is the first construction
    of a reliable sequential machine that can withstand independent
    faults that occur with some small probability.
    An interesting question is if the Turing machines are the
    simplest machines that can perform universal computation
    even under isolated bursts of noise.
    It seems that simpler models, like the counter machines of~\cite{Minsky},
    are insufficient, but
    there are some interesting questions open concerning the nature of their
    insufficiency.
    Further,
    it remains open if a simpler non-hierarchical construction of a reliable Turing machine
    could be obtained.

    The Main Theorem of the thesis is stated in a way that the bound on the time
    that the given Turing machine $G$ uses on a given input $x$, must be known in advance in
    order to determine the active level while creating the initial configuration
    of the reliable Turing machine.
    It remains unknown if it is possible to remove this limitation.
    Also, it is desirable that
     $M_1$  starts its computation from an initial configuration
    in which all positions of $M_2$, $M_3$, \dots are vacant.
    In this case, lower level cells would organize in colonies,
    hence creating cells of the next level and so on.
    Our construction does have this property, but we did not define
    the property formally, and hence we did not give
    a proof that the program has this ``self-organizing'' property.


\bibliographystyle{amsplain}
\begin{thebibliography}{bib}
\addcontentsline{toc}{chapter}{Bibliography}
\bibitem{asarin} Asarin, E., Collins, P.:
                 Noisy Turing Machines.
                 In: \emph{Lecture Notes in Computer Science},
                 Vol. 3580/2005 (2005) 1031--1041

%\bibitem{EhudKobi}
%              	 Benenson, Y.,  Gil, B., Ben-Dor, U., Adar, R.,  Shapiro, E.:
%                 An autonomous molecular computer for logical control of gene expression,
%                 Nature, 429, 423--429 (published online on April 28, 2004)

\bibitem{EhudKobi}
              	 Benenson, Y.,  Shapiro, E.:
                 Molecular Computing Machines.
                 In: \emph{
                 Dekker Encyclopedia of nanoscience and Nanotechnology}.
                 DOI: 10.1081/E-ENN 120013375

\bibitem{Bennett}
                Bennett, C.H. The thermodynamics of computation
                A review.
                In: \emph{International Journal of Theoretical Physics} 1982, 21 (12), 905-940.

\bibitem{SOFSEM}
              \c{C}apuni I., G\'{a}cs, P. :
              A Turing machine resisting isolated bursts of faults.
              In: M. Bielikova et al. (Eds.): SOFSEM 2012, Lecture Notes in Computer Science 7147 (2012)
              165-176.

\bibitem{Bursts}
           \c{C}apuni I., G\'{a}cs, P. :
              A Turing Machine Resisting Isolated Bursts Of Faults.
              Technical report, Boston University, Department
             of Computer Science, Boston, MA 02215, 2012. arXiv:1203.1335.

\bibitem{DurShenRomTil} Durand, B., Romaschenko, A., and Shen, A.:
Fixed-point tile sets and their applications.
In: \emph{Journal of Computer and System Sciences}, Volume 78, Issue 3, (2012),
731--764


\bibitem{PG:1986}
           G\'{a}cs, P.:
           Reliable computation with cellular automata.
           \emph{Journal of Computer System Science}, {\bf 32}/1,
            (1986) 15-78.

\bibitem{GacsSorg97} G\'{a}cs, P.:
 Reliable cellular automata with self-organization. \emph{Journal of
  Statistical Physics} {\bf 103}/1-2 (2001), 45-267.
  See also
  {\tt math.PR/0003117} on {\tt arXiv.org},
  and the proceedings of the Symposium on Foundations of Computer Science 1997.

\bibitem{PGReif} G\'{a}cs, P., Reif, J.A:
            Simple three-dimensional real-time reliable cellular array.
            \emph{Journal of Computer and System Sciences} {\bf 36}/2 (1988) 125-147.

\bibitem{TMwithMaps} Gra\c{c}a, D., Campagnolo, M.L., Buescu, J.:
    Robust simulations of Turing machines with analytic maps and flows.
    In \emph{Computability in Europe 2005, New computational Paradigms},
    Lecture Notes in Computer Science 3526 (2005) 169 --179


\bibitem{Kurdjumov}
          Kurdyumov, G.L.: An example of a nonergodic one-dimensional
          homogenous random medium with positive transition probabilities.
          \emph{Soviet Mathematics - Doklady} {\bf 19}/1 (1978) 211-214.

\bibitem{Minsky} Minsky, M.: \emph{Computation: Finite and infinite machines},
  Englewood Cliffs 1967.

\bibitem{misra} Misra J., Gries D.: Finding repeated elements.
             \emph{Science of Computer Programming}
             {\bf 2} (1982) 143-152.

\bibitem{Nowostawski04anarchitecture}
     Nowostawski, M.,  Purvis, M.,   Cranefield ,S.:
     An architecture for self-organising evolvable virtual machines.
     In: \emph{Engineering Self Organising Sytems: Methodologies and Applications},
     no. 3464, in Lecture Notes in Artificial Intelligence,Springer Verlag (2004)


\bibitem{Kihong}
      Park, K.: \emph{Ergodicity and Mixing Rate of One-Dimensional Cellular Automata}.
      Dissertation. Boston University, 1996.

\bibitem{NC}
       Pippenger,N.: On networks of noisy gates.
       In: \emph{Proceedings of the 26th Annual Symposium on Foundations of Computer Science }
       (1985) 30-38.

\bibitem{Savage} Rachlin, E., Savage, J.E.: A framework for Coded Computation.
        In: \emph{IEEE International Symposium on Information Theory} (2008) 2342-2346.

\bibitem{Rothemund}
    Rothemund, P.W.K. A DNA and Restriction Enzyme
    Implementation of Turing Machine.
    In \emph{DNA
    Based Computers: DIMACS Series in
Discrete Mathematics and Theoretical Computer Science }, April 4, 1995, Princeton University;
    Lipton, R.J., Baum, E.B., Eds.; American Mathematical
    Society: Providence, RI, 1996; 75-119.

\bibitem{DSpielman}
         Spielman, D.: Highly fault-tolerant parallel computation.
         In: \emph{Proceedings of the 37th  Annual Symposium on Foundations of Computer Science }
         (1996) 154-163.

\bibitem{Toom} Toom, A.: Stable and attractive trajectories in multicomponent
                    systems.
                    In \emph{Multicomponent Systems} (R.L. Dobrushin, ed.),
                    Advances in Probability {\bf 6}, Dekker, New York, (1980) 549-575.

\bibitem{Turing:CanMachinesThink}
        Turing, A. : Computing machinery and intelligence.
        In: \emph{Mind}. {\bf 59} (1950)  433-460.


\bibitem{vonNeumann}
        von Neumann, J.: Probabilistic logics and the synthesis of
        reliable organisms from unreliable components.
        In: \emph{Automata Studies} (C. Shannon and McCarthy eds.),
        Princeton University Press, Princeton, NJ. (1956)


\bibitem{ShenVer}
        Shen, A.,
        Vereshchagin, N. K. :
%        and Dubrovskij ,V. N.
        \emph{Computable functions}.
        Providence (R.I.): American Mathematical Society. (2003)







\end{thebibliography}

%\printindex
\newpage

\chapter*{Vita}
\addcontentsline{toc}{chapter}{Vita}
Ilir \c{C}apuni
received his Diploma in Mathematics and Computer Science
in 2003 from the School of Science at University of Montenegro, Montenegro,
where he worked as a teaching assistant and obtained his MSc in Computer Science in
2006.
He enrolled in the PhD program in Computer Science Department
at Boston University, U.S.A.,in 2006.

Ilir \c{C}apuni was supported by Konrad Adenauer Foundation from 2004 to 2006.
%\TODO{Check with Steve what is was the grant of the summer and this fall}

In 2008 he coauthored the book
``Medova 1916-2008  u spomen potopljenim crnogorskim dobrovoljcima'',
 published by the Montengrin Center for Diaspora.



Current Address: Gjerana pn, 85360 Ulqin, Montenegro.


\end{document}
